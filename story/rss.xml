<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Wener Live &amp; Life Blog</title>
        <link>https://wener.me/story</link>
        <description>Wener Live &amp; Life Blog</description>
        <lastBuildDate>Mon, 21 Feb 2022 08:07:21 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[人生第四阶段]]></title>
            <link>https://wener.me/story/stage-four-of-life</link>
            <guid>stage-four-of-life</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[人生阶段]]></description>
            <content:encoded><![CDATA[<h2>人生阶段</h2><p>鲁道夫·施泰纳的人智学理论，定义人的发展每七年一个阶段。</p><blockquote><p>鲁道夫·施泰纳 - Rudolf Steiner，1861 年 2 月 27 日－1925 年 3 月 30 日，奥地利的哲学家、改革家、建筑师和教育家</p></blockquote><p>不知曾几何时听说过这样一个理论，听到的当年当时便深刻的记忆在了脑海里。如果仔细去想，这是一个非常有意思的理论，往往我们习惯说人生阶梯这样的词语，但少有想过我们的阶梯是什么样的。七年是我认为对人生阶段定义很好的里程碑式事件。</p><p>七年，不长不短。第一个七年，有了自我意识；第二个七年，有了生活生存意识；第三个七年，有了情感情绪意识；第四个七年，有了责任。</p><h2>第四阶段</h2><blockquote><p>4 ⨉ 7 = 28</p></blockquote><p>结束了生如虎的少年时代，结束了无所畏惧，结束了无忧无虑。</p><p>There are a lot of people that not make it go throught the 28, like my favorite DJ Avicii, sorry for them.</p><p>I know, need a lot courage to live, but only need one step to die. Life never gose easy until the end.</p><p>I don&#x27;t know what&#x27;s next I have to face, but I think I&#x27;m prepared for whatever it is.</p><p>每一次的结束当然是新的开始。</p><p>在这个阶段，28-35，为人，将迎来生命力的巅峰，似乎一直都在为所肩负进行准备。有所期待，沿途的风景或许才是最大的动力；有所期望，看着“她”的开始或许是每天快乐的源泉；有所陪伴，以至于不在孤单。</p><p>So, I can keep going.</p><p>在这个阶段，或许会有很多对不起。对不起那些照顾陪伴你的人，因为你将没有那么多时间留在他们身边；对不起那些期望着你回家的人儿，因为会有很多个日夜都会辜负他们的等待；或许，也会对不起那个期待的自己，今天的承诺不知在某天才能达成。</p><p>But, I have to keep going.</p><blockquote><p>May the path be with you.</p></blockquote><h2>参考</h2><ul><li><a href="https://tommonte.com/the-7-year-cycles-of-life/">https://tommonte.com/the-7-year-cycles-of-life/</a><ul><li>The 7-Year Cycles of Life</li></ul></li><li>原文 - <a href="https://wener.me/blog/stage-four-of-life">https://wener.me/blog/stage-four-of-life</a><ul><li>Markdown - <a href="https://github.com/wenerme/wener/blob/master/story/2020/2020-08-16-stage-four-of-life.md">https://github.com/wenerme/wener/blob/master/story/2020/2020-08-16-stage-four-of-life.md</a></li></ul></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kubernetes vs OpenStack]]></title>
            <link>https://wener.me/story/kubernetes-vs-openstack</link>
            <guid>kubernetes-vs-openstack</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[10年趋势]]></description>
            <content:encoded><![CDATA[<p><img src="./2020-09-28-kubernetes-vs-openstack-10y-trend.jpg" alt="10年趋势"/></p><h2>简介</h2><table><thead><tr><th>vs</th><th>OpenStack</th><th>Kubernetes</th></tr></thead><tbody><tr><td>起源</td><td>2010 年 NASA+Rackspace</td><td>1.0 2015 年 Google</td></tr><tr><td>定位</td><td>私有云</td><td>容器编排</td></tr><tr><td>主要调度资源</td><td>计算/VM<br/>存储<br/>网络</td><td>容器<br/>及配套周边资源<br/>自定义资源</td></tr><tr><td>主要编写语言</td><td>Python</td><td>Golang</td></tr></tbody></table><h2>区别</h2><p>OpenStack 与 Kubernetes 的区别就等同于虚拟机与容器的区别，Docker 与 VirtualBox 的区别。</p><h3>OpenStack</h3><p>OpenStack 的存在主要解决基础设施管理，那年代也正值大数据快速发展，容器还没有出现于公众视野。
OpenStack 提供了一整套的私有云解决方案，提供最为基础的设施层云化。因为是设施层云化，OpenStack 是需要在裸机服务器上运行的，基础平台即需要相当的资源。
OpenStack 出现后兴起过一段潮流，不少企业开始组建云，并提供服务，我印象深刻的便是京东云。但在 2015 年 Kubernetes 1.0 发布后，大量企业开始迁出 OpenStack，转向 Kubernets。</p><p>那么什么时候应该使用 OpenStack 呢？</p><ol><li><strong>核心业务是提供公有云</strong></li></ol><ul><li>虚拟机</li><li>虚拟网络</li><li>虚拟存储</li></ul><ol start="2"><li>有 OpenStack 专用机房</li><li>有 OpenStack 专家团队</li><li>有足够的资金支付 OpenStack 咨询/支持费用</li></ol><p>OpenStack 只负责解决基础设施的管理隔离，不负责解决服务部署运维，不负责支撑 Web 规模的应用。</p><h3>Kubernetes</h3><p>Kubernetes 的出现和兴起是容器发展后的结果。</p><ul><li>2007 年 cgroups 的出现实现了进程资源隔离 - 来源于 Google</li><li>2008 年 lxc 基本实现了 Linux 的系统级虚拟化 - 基于 cgroups 和 命名空间</li><li>2013 年 google 开源可内部容器技术栈 <a href="https://github.com/google/lmctfy">lmctfy</a> 实现了 Linux 下应用隔离</li><li>2013 年 Docker 出现在公众视野 - 基于 LXC</li><li>2014 年 CoreOS 的 RTK 出现，推进容器的发展<ul><li>只提供容器的系统，就好比 xen 的 dom0 只提供虚拟化</li></ul></li><li>2015 年 Kubernetes 1.0</li><li>2016 年 Windows 支持容器化技术</li></ul><p>到今天，Kubernetes 不只是用于调度容器，更像是一个泛用的集群资源调度平台。</p><p>Kubernetes 也可以被定义为 IaaS，因为提供了计算、存储、网络的能力，但又与传统的基础设施不太相同，更加轻量便捷。这时候如何选择，就看需要基础设施运维层交付什么样的资源内容。</p><p>Kubernetes 的出现使得运维概念更加泛化，DevOps 的概念兴起，基础设施与开发人员距离变得更为接近。
Kubernetes 除了提供基础的容器部署，还提供了实现规模服务需要的所有资源类型，例如 服务、Ingress、配置、密钥 等等，这一层是 OpenStack 不可能涉及的。</p><p>什么时候使用 Kubernetes ？</p><ol><li>当主机不止一台、应用不只一个</li><li>核心交付产品是服务</li></ol><h2>互补</h2><ul><li>Kubernetes 可以选择运行在 OpenStack 中</li><li>OpenStack 可以通过 LXD 就行调度容器</li><li>Kubernetes 可以提供虚拟机的体验<ul><li>容器安装 SSH</li><li>使用 Kubvirt 调度虚拟机</li></ul></li><li>Kubernetes 可以提供虚拟机程度的隔离</li></ul><h2>非常规平台</h2><p>OpenStack 和 Kubernetes 都是通用的云平台 - 通用计算、通用存储、通用网络。
有些时候平台场景并不是泛用的场景，例如</p><ul><li>私有存储云</li><li>流数据处理平台</li><li>边缘节点调度</li><li>大数据 - 计算、存储</li><li>GPU 计算</li></ul><p>这时候则需要按需选择对应的调度平台或工具。例如 存储使用 Ceph，并不是一定需要部署在 Kubernetes 之上，大批量的边缘节点调度可能 Nomad 会更加适合，大数据平台可能有 Hadoop 更加适合的场景。</p><p>但不可否认的是，99% 的企业都是属于通用的一类，因此 99% 的场景选择 Kubernetes 即可。</p><h2>参考</h2><ul><li><a href="https://yq.aliyun.com/articles/139446">京东如何从 OpenStack 迁移至 Kubernetes</a></li><li><a href="https://www.suse.com/c/the-future-of-openstack/">The future of OpenStack?</a></li><li><a href="https://qr.ae/pNPMWM">What is the future of Openstack?</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Firecracker 运行 AlpineLinux]]></title>
            <link>https://wener.me/story/alpine-in-firecracker</link>
            <guid>alpine-in-firecracker</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[Firecracker 是亚马逊 AWS 为了解决虚拟化运行 serveless 服务实现的 VMM/Virtual Machine Monitor，作为 QEMU 的替代品，专注于为云上环境提供虚拟化。]]></description>
            <content:encoded><![CDATA[<p>Firecracker 是亚马逊 AWS 为了解决虚拟化运行 serveless 服务实现的 VMM/Virtual Machine Monitor，作为 QEMU 的替代品，专注于为云上环境提供虚拟化。</p><p><strong>优点</strong></p><ul><li>启动快 &lt; 125ms</li><li>内存占用少 &lt; 5mb</li><li>Rust 实现</li><li>musl 静态链接</li><li>firecracker 自身约 <strong>1.6 MB</strong> - <strong>无依赖</strong></li></ul><p><strong>设计目标/缺陷</strong></p><ul><li>基于 KVM 实现<ul><li>只有 Linux 平台</li><li>只能运行相同架构</li></ul></li><li>专注于虚拟化场景<ul><li>支持的虚拟设备少<ul><li>virtio-net - 虚拟化网络</li><li>virtio-block - 虚拟化块设备</li><li>virtio-vsock - unix sock</li><li>串口 - ttyS0 终端登陆</li><li>最简键盘控制器</li></ul></li><li>没有 bios</li><li>通过 vmlinux+initramfs+rootfs 启动</li></ul></li><li>要求 Kernel 4.14+</li></ul><p><strong>为什么选择 Alpine？</strong></p><ul><li>最容易构建</li><li>最容易使用</li><li>构建 Firecracker 能使用的 CentOS, Debian, Ubuntu, Fedora 真太难了 - 如果没掌握内部启动机制不建议尝试</li></ul><h2>注意</h2><p>一些注意事项写在前面：</p><p>:::info Firecracker 注意点</p><ul><li>没有电源管理，因此不支持重启，会直接退出</li><li>系统内 poweroff 或 halt 不会退出 - reboot 会</li><li>可以发送 SendCtrlAltDel 退出</li><li>不支持 QCOW2 格式，可以考虑配合 NDB 使用</li><li>alpine 内核需要 boot-source.initrd_path =&gt; initramfs-virt</li><li>alpine netboot 的 initramfs-virt 没有 ext4</li></ul><p>:::</p><h2>安装</h2><p>Firecracker 的<a href="https://github.com/firecracker-microvm/firecracker/releases">发布页</a>可直接下载每个版本。这里使用 curl 下载最新版并安装到 <code>/usr/loca/bin</code>。</p><pre><code class="language-bash"># 下载安装 firecracker 到 /usr/local/bin/firecracker
latest=$(basename $(curl -fsSLI -o /dev/null -w  %{url_effective} https://github.com/firecracker-microvm/firecracker/releases/latest))
sudo curl -L -o /usr/local/bin/firecracker https://github.com/firecracker-microvm/firecracker/releases/download/${latest}/firecracker-${latest}-$(uname -m)
sudo chmod +x /usr/local/bin/firecracker
</code></pre><h2>rootfs</h2><p>启动 firecracker 需要 kernel 和 rootfs，实际使用的时候可能大部分时间都是在准备 rootfs。这里使用 alpinelinux，功能完善构建简单。</p><p>因为 alpine 都会提供基础的 rootfs，这里直接下载解压到 ext4 的 loopdev 中。</p><pre><code class="language-bash"># 创建 root 盘
qemu-img create -f raw alpine.rootfs.ext4 1G
# 格式化为 ext4
mkfs.ext4 ./alpine.rootfs.ext4
# 挂载到 /tmp/rootfs
mkdir /tmp/rootfs
sudo mount alpine.rootfs.ext4 /tmp/rootfs

# 下载 rootfs
curl -OJ https://mirrors.aliyun.com/alpine/v3.12/releases/x86_64/alpine-minirootfs-3.12.0-x86_64.tar.gz
# 安装到 /tmp/rootfs
sudo tar zxvf alpine-minirootfs-3.12.0-x86_64.tar.gz -C /tmp/rootfs/
</code></pre><p>基础 rootfs 还不足以启动系统，因为无法进行系统 init，因此还需要在 rootfs 中安装必要的包启动必要的服务。</p><p>进入 rootfs 之前需要 resolv.conf，包含了 DNS 信息。</p><pre><code class="language-bash"># 拷贝 dns 配置 - 没有会无法进行 dns 解析
sudo cp /etc/resolv.conf /tmp/rootfs/etc
# 如果主机是 alpinelinux 可以从主机拷贝配镜像置文件
# 如果不是建议设置镜像
# sudo cp /etc/apk/repositories /tmp/rootfs/etc/apk/repositories

# chroot 进入 rootfs 安装环境
sudo chroot /tmp/rootfs/ /bin/sh
</code></pre><p>此时进入了 rootfs，因为没有挂载 procfs、sysfs 等目录，并不是一个能完整使用的 rootfs，但对于安装包来说已经足够。</p><ul><li><a href="https://pkgs.alpinelinux.org/package/v3.12/main/x86_64/alpine-base">alpine-base</a><ul><li>基础系统</li><li>依赖了 openrc，layout，busybox，apk，conf 等基础包</li></ul></li><li>linux-virt<ul><li>virt 内核 - 不包含固件（200MB 左右），默认 init 包含 virtio 等内核模块</li><li>安装后能获取到内核和 initramfs</li><li>/boot 下 vmlinuz+initramfs+System.map 约 15MB - 启动是不需要的，拿到后可以删除</li></ul></li><li>haveged<ul><li>随机熵服务</li><li>虚拟化环境能更快启动，否则熵初始化可能需要几分钟</li></ul></li></ul><pre><code class="language-bash">apk add alpine-base linux-virt haveged
# 开机启动
rc-update add haveged
# root 账号密码
echo root:root | chpasswd
# 基础服务
for svc in devfs procfs sysfs; do ln -fs /etc/init.d/$svc /etc/runlevels/boot; done
exit

# firecracker 使用 ttyS0
ln -s agetty /etc/init.d/agetty.ttyS0
echo ttyS0 &gt; /etc/securetty
rc-update add agetty.ttyS0 default

# 从 rootfs 获取到 vmlinuz 和 initramfs
sudo cp /tmp/rootfs/boot/initramfs-virt initramfs-virt
sudo cp /tmp/rootfs/boot/vmlinuz-virt vmlinuz-virt

# 取消挂载
sudo umount /tmp/rootfs
</code></pre><p>rootfs 准备完成。</p><h2>vmlinux+initrd</h2><p>这里解释一下 rootfs 拿到的 Linux 内核 vmlinuz-virt 和初始内存镜像 initramfs-virt</p><ul><li>vmlinuz-virt<ul><li>压缩后的 Linux 内核 - 需要解压后 firecracker 才能识别</li><li>解压后为 ELF 格式可执行文件 - 与一般 Linux 下可执行文件相同</li></ul></li><li>initramfs-virt<ul><li>压缩后的 cpio 格式</li><li>包含了 Linux 内核需要的 virtio 和 ext4 等模块</li><li>包含了 Alpine 的 init 系统<ul><li>加载内核模块</li><li>找到并挂载 rootfs</li></ul></li></ul></li></ul><p>因为内核是压缩后的，因此还需要进行解压</p><pre><code class="language-bash"># 下载安装 extract-vmlinux
sudo curl -L -o /usr/local/bin/extract-vmlinux https://raw.githubusercontent.com/torvalds/linux/master/scripts/extract-vmlinux
sudo chmod +x /usr/local/bin/extract-vmlinux
# 解压 vmlinuz-virt
extract-vmlinux vmlinuz-virt &gt; vmlinux-virt
</code></pre><h2>启动</h2><p>所有准备工作已完成，得到</p><ul><li>alpine.rootfs.ext4 - 系统盘</li><li>vmlinux-virt - 内核</li><li>initramfs-virt - 初始内存镜像</li></ul><p>firecracker 有两种启动方式</p><ol><li>监听端口/socket</li></ol><ul><li>通过调用接口配置 rootfs、内核等</li><li>配置完成后请求 InstanceStart 进行启动</li></ul><ol start="2"><li>通过配置文件配置</li></ol><ul><li>配置文件等同于接口请求</li><li>参数内容和路径与接口一致</li></ul><p>这里使用方法 #2，因为方便书写编辑简单。</p><pre><code class="language-bash"># 生成 alpine.json 配置
cat &lt;&lt;CONF &gt; alpine.json
{
  &quot;boot-source&quot;: {
    &quot;initrd_path&quot;: &quot;initramfs-virt&quot;,
    &quot;kernel_image_path&quot;: &quot;vmlinux-virt&quot;,
    &quot;boot_args&quot;: &quot;console=ttyS0 reboot=k panic=1 pci=off modules=virtio_mmio,ext4 rootfstype=ext4&quot;
  },
  &quot;drives&quot;: [
    {
      &quot;drive_id&quot;: &quot;rootfs&quot;,
      &quot;path_on_host&quot;: &quot;alpine.rootfs.ext4&quot;,
      &quot;is_root_device&quot;: true,
      &quot;is_read_only&quot;: false
    }
  ],
  &quot;machine-config&quot;: {
    &quot;vcpu_count&quot;: 1,
    &quot;mem_size_mib&quot;: 1024,
    &quot;ht_enabled&quot;: false
  }
}
CONF

# 配置完成 - 启动
# 进入后使用 root:root 登陆
firecracker --api-sock /tmp/firecracker.socket --config-file alpine.json
</code></pre><h2>停止</h2><p>:::caution Firecracker 不能正常关机</p><p>firecracker 不能使用 poweroff 关机，如果使用了 poweroff 则只能 kill 进程来退出。</p><p>:::</p><p>在系统之外可以请求 <code>Ctrl+Alt+Del</code> 进行关机，实质上是重启的效果，但因为 firecracker 不能重启，因此 init 退出后就关机了。</p><pre><code class="language-bash">curl --unix-socket /tmp/firecracker.socket -i \
    -X PUT &quot;http://localhost/actions&quot; \
    -H  &quot;accept: application/json&quot; \
    -H  &quot;Content-Type: application/json&quot; \
    -d &#x27;{&quot;action_type&quot;: &quot;SendCtrlAltDel&quot;}&#x27;
</code></pre><p>系统内可以直接 <code>reboot</code> 进行关机。</p><h2>总结</h2><p>Firecracker 使用起来蛮惊艳，能成功的快速的启动系统，启动速度会比 QEMU 快不少，因为少了 bios、bootloader、内核解压 等过程。</p><p>因为 Firecracker 优缺点非常明显，这里总结一下适用场景：</p><ul><li>serveless 场景 - 需要快速起停，安全隔离，环境独立</li><li>处于安全考虑进行容器执行环境隔离 - 作为容器运行时</li><li>将应用打包为系统进行分发，使用 firecracker 屏蔽系统差异</li></ul><p>不适用场景也很明显：</p><ul><li>如果需要使用 CentOS、Debian、Ubuntu 之类系统，非常不建议<ul><li>构造一个可使用的 rootfs 和 initramfs 非常麻烦</li></ul></li><li>需要用到的设备 firecracker 可能不支持</li><li>需要透传设备到 VM</li></ul><p>Firecracker 相对较新，集成使用方面还有所欠缺，但在 Firecracker 擅长的领域使用起来是非常舒服的。</p><h2>参考</h2><ul><li><a href="https://gist.github.com/wenerme/97a2f088496bb3e6492ef7e8fe23da8a">boot-alpine-in-firecracker.sh</a> - 以上所有代码</li><li><a href="https://github.com/firecracker-microvm/firecracker">firecracker-microvm/firecracker</a> - 核心仓库</li><li><a href="https://github.com/firecracker-microvm/firectl">firecracker-microvm/firectl</a> - Golang 实现用于管理 firecracker 虚拟机的辅助工具</li><li><a href="https://github.com/firecracker-microvm/firecracker-go-sdk">firecracker-microvm/firecracker-go-sdk</a> - Golang 直接操作 Firecracker</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rancher vs. Kubesphere]]></title>
            <link>https://wener.me/story/rancher-vs-kubesphere</link>
            <guid>rancher-vs-kubesphere</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[| info.                 | Rancher                                                 | Kubesphere                                                          |]]></description>
            <content:encoded><![CDATA[<table><thead><tr><th>info.</th><th>Rancher</th><th>Kubesphere</th></tr></thead><tbody><tr><td>开发者</td><td>Rancher/SUSE</td><td>青云开源</td></tr><tr><td>源码</td><td><a href="https://github.com/rancher/rancher">rancher/rancher</a></td><td><a href="https://github.com/kubesphere/kubesphere">kubesphere/kubesphere</a></td></tr><tr><td>Stars</td><td>15.5k</td><td>4.6k</td></tr><tr><td>开源协议</td><td>Apache-2.0</td><td>控制器 Apache-2.0 <br/> 前端 <strong>AGPL-3.0</strong> / 不允许商业闭源修改前端</td></tr><tr><td>安装</td><td>Helm</td><td>ks-installer(Ansible)+CRD</td></tr><tr><td>部署 K8S</td><td>rke/rancher</td><td>kubekey</td></tr><tr><td>版本</td><td>v2.5</td><td>v3.0</td></tr><tr><td>监控</td><td>Grafana+Prometheus</td><td>Prometheus+前端集成</td></tr><tr><td>告警</td><td>Grafana/Altermanager</td><td>邮件、企业微信、Slack</td></tr><tr><td>日志</td><td>Banzi Operator</td><td>Elasticseach, fluentbit + 前端集成<br/>事件日志，审计日志</td></tr><tr><td>ServiceMesh</td><td>Istio</td><td>Istio</td></tr><tr><td>DevOps</td><td>2.5 之后 Fleet GitOps<br/><del>2.5 之前 Pipeline/Jenkins</del></td><td>Jenkins</td></tr><tr><td>应用商店</td><td>Helm Repo</td><td><a href="https://github.com/openpitrix/openpitrix">openpitrix/openpitrix</a></td></tr><tr><td>角色权限管理</td><td>✅</td><td>✅</td></tr><tr><td>配置方式</td><td>Web UI/CRD</td><td>编辑 CRD/yaml</td></tr><tr><td>应用</td><td>Helm</td><td>Helm/<a href="https://github.com/kubernetes-sigs/application">CRD</a></td></tr><tr><td>实现依赖</td><td>-</td><td>etcd+redis+minio+openldap+mysql</td></tr><tr><td>实现服务</td><td>rancher+fleet</td><td>ks-controller-manager<br/>ks-apiserver+ks-console</td></tr><tr><td>多集群</td><td>✅</td><td>✅</td></tr><tr><td>UI 美观</td><td>⭐️⭐️</td><td>⭐️⭐️⭐️</td></tr><tr><td>UI 功能</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️</td></tr><tr><td>云平台集成</td><td>⭐️⭐️</td><td>❌</td></tr><tr><td>文档</td><td>⭐️⭐️</td><td>⭐️</td></tr><tr><td>开发友好</td><td>⭐️</td><td>⭐️⭐️⭐️</td></tr><tr><td>运维友好</td><td>⭐️⭐️⭐️</td><td>⭐️</td></tr><tr><td>使用者对 K8S 掌握程度</td><td>高</td><td>低</td></tr><tr><td>核心体验</td><td>多集群运维部署</td><td>友好的一体化开发<br/>友好=美观的界面<br/>一体化开发=Jenkins+Elastic</td></tr><tr><td>核心竞争力</td><td>多集群<br/>资源管理运维<br/>核心应用集成</td><td>集成多功能的<strong>美观界面</strong> / AGPL-3.0</td></tr></tbody></table><p>:::tip</p><ul><li>选择 Kubesphere<ul><li>如果犹豫 - 因为使用简单</li><li>如果追求界面美观</li><li>如果工作以开发为主</li><li>如果希望定制化产出自己平台管理<ul><li>界面 AGPL-3.0 ,定制后的闭源商业产品需付费</li></ul></li></ul></li><li>选择 Rancher<ul><li>如果对 Kubernetes 掌握透彻</li><li>如果需要管理多集群</li><li>如果工作以运维部署为主</li><li>如果需要整合云平台资源</li></ul></li></ul><p>:::</p><p>综合使用下来后觉得 Kubesphere 与 Rancher 应用场景并不特别重复，按自己的需求选择即可，实际情况可能是两个都用。Ranher 用于管理和开通集群，Kubesphere 用于给开发者操作单个集群。</p><h2>Rancher</h2><h3>优点</h3><ul><li>更大的开发团队</li><li>更好的 K3S 支持</li><li>更好的云平台支持</li><li>更好的多集群管理</li><li>默认 HTTPS</li><li>为什么更好？<ul><li>2.5 的 Exploere</li><li>WebShell 会显示 Helm 安装过程</li><li>内置 Helm 仓库包含 Rancher 集成应用</li><li>Helm Values 能被映射为 Form 表单</li><li>集群备份恢复</li><li>Fleet GitOps</li></ul></li></ul><h3>缺点</h3><ul><li>要求使用人员对 Kubernetes 有一定认知和运维能力</li><li>WebUI 使用起来总有种卡顿的感觉</li><li>2.5 的新 UI 目前加载总会闪烁 - Loadding</li><li>资源分类有点混乱 - 没有 Lens 清晰</li><li>~2.5 还在 latest 阶段，尚未进入 stable~</li><li>~2.5 的 Exploere 还没有中文，不过已有多语言支持~</li></ul><h2>Kubesphere</h2><h3>优点</h3><ul><li><strong>界面友好美观</strong></li><li>集成监控</li><li>集成日志</li><li>集成 DevOps</li><li>集成应用一体化体验 - 不需要去 Grafana 看监控，不需要去 Kibana 看日志</li><li>面向内部的应用商店比 Helm Repo 在实际开发时更有实际意义</li></ul><h3>缺点</h3><ul><li><strong>不兼容 k8s v1.19</strong> - 在 v1.19 已经发布两个月后<ul><li>csr v1 <a href="https://github.com/kubesphere/kubesphere/issues/2928">#2928</a></li></ul></li><li>通过编辑 CRD 启动功能<ul><li>不知道状态和错误 - 只能看日志</li></ul></li><li>Ansible 控制功能<ul><li>开启容易，关闭难</li><li>Ansible 本身无状态，没有 Helm 的卸载概念</li></ul></li><li>列表不能设置每页数量 - 默认 10 条目/页 - 对于 K8S 资源管理来说有点少了</li><li>翻页不便操作</li><li>包含青云集成功能</li></ul><h2>安装维度</h2><h3>Rancher</h3><p>Rancher 注重管理，v2.5 没有 Pipeline 和内建的监控集成，自身非常轻量，甚至目前在尝试单二进制启动，RancherD。
Rancher 的用户，项目，集群等配置均使用 CRD，因此不需要数据库存储，使用 CRD 相当于接口，利于自动化集成。</p><p>一般通过 Helm 安装 Rancher，方便升级、管理、配置。</p><pre><code class="language-bash"># stable
helm repo add rancher https://releases.rancher.com/server-charts/stable
# 配置项 https://rancher.com/docs/rancher/v2.x/en/installation/resources/chart-options
cat &lt;&lt;YAML &gt; rancher.values.yaml
hostname: rancher.my.corp
# 不使用 cert-manager 则需要开启 - 建议使用 cert-manager
# privateCA: true
# rancher 系统镜像
systemDefaultRegistry: registry.cn-hangzhou.aliyuncs.com
# 默认 3 副本
replicas: 1
YAML
# 安装或升级
helm upgrade -i rancher rancher/rancher -n cattle-system --create-namespace -f rancher.values.yaml
</code></pre><h3>Kubesphere</h3><p>Kubesphere 默认有大量集成，有点类似于 v2.5 之前的 Rancher。
功能较多，且控制器通过数据库进行存储，部署 Kubesphere 时需要部署数据库，运维层面来说会变得麻烦，因为 K8S 上数据库涉及到存储问题，除了数据库，Kubesphere 还默认依赖了 etcd+redis+minio+openldap，可以算是比较复杂的一个系统了。</p><p>实际部署配置使用 Ansible，角色定义位于 <a href="https://github.com/kubesphere/ks-installer/tree/master/roles">ks-installer/roles</a>。
该部署模式优缺点明显：</p><ul><li>优点<ul><li>Ansible 部署操作幂等</li><li>Ansible 擅长集成部署各种服务</li></ul></li><li>缺点<ul><li>失去了 K8S 的 声明式 Yaml<ul><li>Ansible 涉及大量的模版操作，还有大量的直接 kubectl</li></ul></li><li>即懂 Ansible 又懂 K8S 的人占少数 - 确保能用，但想要修改或深入了解有门槛</li><li>Ansible 无状态 - 基本等同于 <strong>无法删除</strong></li></ul></li></ul><p>Kubesphere 体系复杂，也能理解选择 Ansible，但曾经使用过 Ansible 运维 K8S，复杂后真的会很难受。</p><pre><code class="language-bash"># 部署安装器 - Operator
kubectl apply -f https://raw.githubusercontent.com/kubesphere/ks-installer/v3.0.0/deploy/kubesphere-installer.yaml
# 添加 CRD 资源 - 定义 ks 安装配置
kubectl apply -f https://raw.githubusercontent.com/kubesphere/ks-installer/v3.0.0/deploy/cluster-configuration.yaml

# 安装过程
kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-install -o jsonpath=&#x27;{.items[0].metadata.name}&#x27;) -f
</code></pre><h2>开发维度</h2><p>开发主要分为 CI 和 CD 两部分，CI 偏向代码到产出物的过程，CD 偏向产出物到线上运行的过程。</p><p>两者的核心都是流程自动化处理，但面向的对象和场景却差别很大。</p><ul><li>CI - 代码到产出物的过程<ul><li>提交代码 - 触发 Hook - 选择执行器 - 执行定义的 Pipeline</li><li>依赖: 代码仓库、产出物仓库、动态调度的执行节点</li><li>亮点: <strong>快</strong>、灵活的流程定义、可视化的执行过程、与代码仓库的集成程度</li><li>产品<ul><li>Jenkins</li><li>DroneCI</li><li>Github Action</li><li>Gitlab CI/CD</li></ul></li></ul></li><li>CD - 产出物部署到线上的过程 - 现在的主流做法是 GitOps<ul><li>提交部署定义 - 触发 Hook/定时扫描修改 - 应用 yaml</li><li>亮点: 可视化、多集群、自动修复</li><li>产品<ul><li>ArgoCD - 可视化依赖、可视化日志、多集群(偏弱)、健康管理</li><li>rancher/fleet - rancher 集成管理、多集群、才出不久尚不完善</li><li>fluxcd - v1 废弃维护阶段，v2 变化较大变为工具集 - 选择 fluxcd 会有点尴尬</li></ul></li></ul></li></ul><p>CD 逻辑体验相对简单，但 CI 的体验却可以区别很大。
我认为私有 CI 最好的体验是 Gitlab 自行部署 Runner，其次是 DroneCI，最后才是 Jenkins。</p><ul><li>Gitlab CI/CD<ul><li>靠近代码仓库 - 开发本能</li><li>支持自行部署 Runner - Docker/Shell - <strong>快</strong>, 可以在私有环境</li><li>yaml 定义 ci 处理 - 功能强大</li><li>Gitlab 提供了 Docker 仓库，当然 Push 的时候也可以 Push 到其他仓库</li><li>Gitlab 提供了开发仓库 - 相当于节省一个 Nexus</li></ul></li><li>DroneCI<ul><li>大体上类似 Gitlab Runner</li><li>但独立于代码仓库</li></ul></li><li>Jenkins<ul><li>太重</li><li>界面不太友好</li></ul></li></ul><p>我理解 CI 与 CD 还有一个中间临界点，应用商店或 Helm Repo，开发好的应用可以很好呈现给需要的人，需要的人可以非常便捷的部署应用到集群。</p><h3>Rancher</h3><p>2.5 之前的 Pipeline 便是 Jenkins 的封装，基本等同于 Kubesphere 的 DevOps。
2.5 之后 Rancher 废弃了 Pipeline 转而默认部署 Fleet。</p><p><a href="https://github.com/rancher/fleet">rancher/fleet</a> 是面向多集群的 GitOps，与 Pipeline 完全是两个方向。rancher 注重运维，fleet 使得 rancher 的运维能力步上新的台阶。</p><p>fleet 多集群比 argocd 强</p><ul><li>默认支持一个应用部署到多个集群 - 集群选择器</li><li>不同集群支持不同 overlay 进行定制化</li><li>fleet agent 安装简单</li><li>支持集群属性 - 打标、选择</li></ul><p>但 fleet 还有很多弱项</p><ul><li>必须要资源先不存在 - 无法迁移</li><li>可视化较弱 - 对比 ArgoCD</li></ul><p>如果的确是需要多集群运维，那么 fleet 的确是不二之选，如果只要场景只有一个或少数集群，建议使用 ArgoCD。</p><h3>Kubesphere</h3><p>Kubesphere 包含 DevOps 模块和 Elastic 日志采集集成。
集成功能都提供了美观的界面（<strong>界面才是 KS 的核心竞争力</strong>），使得体验的确非常好。</p><p>DevOps 基于 Jenkins、Harbor、Mino、SonarQube 等，因此所有相关组件的问题也会变成 KS 的问题，也会发现社区有非常多关于 Jenkins、Harbod 之类的问题，我认为 Rancher 放弃基于 Jenkins 的 Pipeline 是十分正确的选择。</p><p>至于 Elastic 日志集成，我认为，如果使用外部运维的 Elastic 结合 KS 的界面是值得的，因为要在 K8S 上运维好 Elastic 这种体量的应用还是不容易。</p><h2>运维维度</h2><p>我理解的运维包含了 K8S 资源可视化、资源编辑、指标可视化、多集群支持、用户权限体系、集成应用管理能力等。</p><h3>More Than Kubernetes Dashboard/Lens</h3><p>Kubernetes Dashboard 和 Lens 都是非常简洁明了的集群管理工具，Lens 甚至也能支持多集群。Kubernetes Dashboard 占用异常少的资源提供集群资源的 CRUD，资源可视化。</p><p>之所以选择其他的管理平台，是因为集群管理中必须的一些功能不在 Kubernetes Dashboard 和 Lens 的领域范畴。</p><ol><li>角色权限管理 - 多用户</li><li>应用生命周期管理 - Helm 应用</li><li>资源集成管理 - 使用 UI 而非 Yaml 的方式编辑资源</li><li>多集群</li></ol><p>Rancher 和 Kubesphere 都很好的完成了这些目标。</p><p>但遗憾的是 Kubesphere 最基础的资源管理功能还没有 Lens/Kubernetes Dashboard 直观，因为追求了界面集成和美观，所以对于有 Kubernetes 经验的使用者来说反而觉得繁琐。</p><p>Rancher 2.5 的 集群资源浏览器 算是追赶上了 Lens/Kubernetes Dashboard 所提供的功能，但依然没有 Lens 直观。</p><p>Rancher 和 Kubesphere 都没有很好的集成 metric-server，导致没有安装特定的监控应用时无法查看资源使用情况。
而监控的安装又因为平台集成方式不同，安装方式不同，即便已经存在也可能看不到监控，这一点还没有 Kubernetes Dashboard 的资源使用情况来的直观。</p><p>Rancher 和 Kubesphere 从管理上超越了 Kubernetes Dashboard/Lens，但实际体验和使用上却仍有不足。</p><h3>多集群</h3><p>讨论多集群时，优先明确场景</p><ol><li>大量集群 - Rancher - 以运维为主</li></ol><ul><li>应用部署</li><li>资源管理</li><li>Agent 易于安装，占用资源少</li></ul><ol><li>少量集群 - Kubesphere - 开发体验</li></ol><ul><li>DevOps</li></ul><p>因为 Kubesphere 本身资源管理能力弱于 Rancher，因此当多集群资源过多的时候只能选择 Rancher。Rancher 的资源浏览器和 Fleet 都是针对这样的场景设计的。
Rancher agent 和 fleet agent 资源占用都较少，因此大量部署时负担也不会大。</p><p>如果需要 DevOps 则可以考虑单独集群安装 Kubesphere 或者选择 Argocd、Gitlab 等对应场景的应用产品。</p><h1>总结</h1><p>选择 Rancher 和 Kubesphere 并不冲突，两者发展方向也不尽相同。因此根据实际情况和项目需要选择即可。</p><h1>参考</h1><ul><li><a href="https://github.com/rancher/rancher">rancher/rancher</a></li><li><a href="https://github.com/kubesphere/kubesphere">kubesphere/kubesphere</a></li><li><a href="https://info.rancher.com/hubfs/eBooks,%20reports,%20and%20whitepapers/%5BBuyers%20Guide%5D%20Rancher,%20Openshift,%20Tanzu,%20Anthos%2020200911.pdf">A Buyer’s Guide to Enterprise Kubernetes Management Platforms</a><ul><li>Rancher 对自己的定位不同于 Kubesphere</li></ul></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CRM 基础 - 线索、商机、账户、联系人]]></title>
            <link>https://wener.me/story/crm-basic-leads-opportunities-accounts-contacts</link>
            <guid>crm-basic-leads-opportunities-accounts-contacts</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[CRM 基础 - 线索、商机、账户、联系人]]></description>
            <content:encoded><![CDATA[<h2>CRM 基础 - 线索、商机、账户、联系人</h2><ul><li>线索 - leads<ul><li>是 营销/marketing 与 销售/sales 的交界点</li><li>营销负责创造、发现线索，销售人员需要从线索挖掘商机进行销售转化</li><li>挖掘过程就是判断线索是否合格（qualify）或不合格（disqualify）的过程，如果合格则能被转化为商机</li><li>线索表示的 <strong>潜在</strong> 的 <strong>销售目标</strong></li><li>包含基础的指向信息 - 例如 名片、电话号码+名字</li></ul></li><li>商机 - opportunities<ul><li>商机可由线索转化，也可直接录入</li><li>商机同时也是联系人（contact），在创建商机时自动创建关联的联系人和账户</li><li>商机=潜在销售目标（lead+contact）+潜在可销售服务</li></ul></li><li>账户 - accounts<ul><li>B2B 关系往来目标 - 通常对方为公司</li><li>关系往来类型不只是销售客户关系，还可能是 合作伙伴（partner）、供应商（vendor） 等</li><li>有层级关系，支持复杂的组织结构</li></ul></li><li>联系人 - contacts<ul><li>B2B 关系中对方公司实际操作的人 - 例如 下单、审核、处理发票收据 的 <strong>人</strong></li></ul></li></ul><h2>从 Issues 看 CRM 基础概念</h2><p>作为一个开发者，对 Issues/工单/议题 更加熟悉。管理的好的工单会使得整个开发流程更加顺畅，管理的不好则会导致工单暴增导致无法收尾最终只有大批量关闭。</p><p>工单经历发现、创建、确认、修复、关闭。这个过程与 CRM 的 线索、商机、成交过程十分相似。</p><p>工单看似是线性的，但实际处理的时候又是流程化的，这个流程并不固定，而是取决于当前问题的状态、类型、指派人。</p><p>以 kubernetes 的 <a href="https://github.com/kubernetes/kubernetes/issues">issues</a> 为例，大量的 issues 都会打上<a href="https://github.com/kubernetes/kubernetes/labels?sort=count-desc">各种标签</a>。</p><table><thead><tr><th>Label</th><th>CRM</th></tr></thead><tbody><tr><td>needs-triage</td><td>待跟进</td></tr><tr><td>triage/unresolved</td><td>无效的</td></tr><tr><td>triage/accepted</td><td>已确认</td></tr><tr><td><code>kind/*</code></td><td>划分类型</td></tr><tr><td><code>area/*</code></td><td>划分服务范围</td></tr></tbody></table><p>CRM 的核心是 <strong>协作</strong>，工单的标签系统也是为了方便协作，不同的项目使用的体系不尽相同，因为场景和处理流程不同，但核心目的都是为了协作解决问题。</p><p>通过工单的标签定义可观测出处理流程，这样的处理流程是一套 <strong>项目管理框架</strong>，CRM 中销售也需要一套行之有效的框架，只有当销售人员遵循一套框架体系时流程才可能得以优化。</p><p>大小项目的标签分发流程体系不同，就好比大小公司对 CRM 要求不同，初期的需求只要记录信息，中阶的要求需要能按人员按指责去流转跟进，高阶的则需要集成大量的外部系统使得流程自动化。</p><p>工单系统这样的自动化比传统 CRM 一条一条记录更加智能，例如 Github 能集成各种第三方的 CI/CD 体现状态，集成各种机器人对 issue 进行自动打标，还有最常见的机器人标记 issue 过期并自动关闭。</p><p>不管是工单还是 CRM 的跟进体系最重要的是达到最终完成状态，这个过程需要推进则需要系统进行辅助，最常见的就是确定下一件事的时间节点，将不同的工单/跟进分流给不同的人去处理。</p><p>工单/跟进都是非常原始/原子（primitive）的对象，在这样的体系之上可以构建</p><ul><li>看板</li><li>里程碑</li><li>待办列表/Todo List</li><li>Epic</li><li>外部集成</li><li>自动化</li></ul><p>作为驱动 CRM 销售日常事务来说是非常有用的。</p><p>但，工单系统与跟进也有很多不同点：</p><table><thead><tr><th>-</th><th>工单</th><th>销售跟进</th></tr></thead><tbody><tr><td>可见性</td><td>公开、小组</td><td>个人、小组</td></tr><tr><td>内容</td><td>文本、评论、活动</td><td>表单、活动、附件</td></tr><tr><td>内容目标</td><td>事</td><td>人+事</td></tr><tr><td>协作人员</td><td>开发+测试+设计+PM</td><td>销售个人+销售小组+客服+经理</td></tr><tr><td>KPI</td><td>小组相关</td><td>个人相关、小组相关</td></tr><tr><td>频度</td><td>高</td><td>低</td></tr><tr><td>工作内容</td><td>PR, 提交</td><td>电话、沟通、日常事务</td></tr></tbody></table><h2>线索、商机、账户、联系人</h2><p>回到本来的关注点，先参照现有的系统设计。</p><h3>Dynamic 365</h3><ul><li><a href="https://docs.microsoft.com/en-us/dynamics365/customerengagement/on-premises/developer/entities/lead">Lead Entity</a></li><li><a href="https://docs.microsoft.com/en-us/dynamics365/customerengagement/on-premises/developer/entities/opportunity">Opportunity Entity</a></li><li><a href="https://docs.microsoft.com/en-us/dynamics365/customerengagement/on-premises/developer/entities/account">Account Entity</a></li><li><a href="https://docs.microsoft.com/en-us/dynamics365/customerengagement/on-premises/developer/entities/contact">Contact Entity</a></li><li><a href="https://docs.microsoft.com/en-us/dynamics365/customerengagement/on-premises/developer/entities/activitypointer">ActivityPointer</a><ul><li>已完成或未完成的事务</li></ul></li><li><a href="https://docs.microsoft.com/en-us/dynamics365/customerengagement/on-premises/developer/entities/activityparty">ActivityParty</a><ul><li>活动参与方</li></ul></li></ul><p>其中的 Activity 活动概念其实就对应了工单中的活动记录，所有的跟进过程都以活动呈现。似乎接下来该了解一下工单系统的实现了</p><h2>参考</h2><ul><li><a href="https://yaweriqbal.com/2016/01/10/understanding-leads-opportunities-accounts-and-contacts-in-crm/">Understanding leads, opportunities, accounts and contacts in CRM</a></li><li><a href="https://www.salesforcetraining.com/salesforce-manages-leads-contacts-accounts-opportunities/">How Salesforce Manages Leads, Contacts, Accounts and Opportunities</a></li><li>Gitlab <a href="https://docs.gitlab.com/ee/user/project/issues/">Issues</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[工单系统设计实现]]></title>
            <link>https://wener.me/story/issues-system-design</link>
            <guid>issues-system-design</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[工单/Issues 系统都不会陌生，Github、Gitlab、Gitea 中每天都在接触的系统。想要学习如何设计实现最简单的是直接从别人的系统逻辑参考理解。]]></description>
            <content:encoded><![CDATA[<p>工单/Issues 系统都不会陌生，Github、Gitlab、Gitea 中每天都在接触的系统。想要学习如何设计实现最简单的是直接从别人的系统逻辑参考理解。</p><p>我理解的工单系统</p><ul><li>元数据丰富</li><li>分类标签体系</li><li>基于时间线呈现活动</li><li>可扩展性强</li><li>能封装出上层管理体系<ul><li>看板</li><li>里程碑</li><li>日历</li></ul></li></ul><h2>Gitea</h2><ul><li>Issues 特性<ul><li>上下文切换 - 组织、当前用户</li><li>模板</li><li>里程碑</li><li>标签</li><li>指派</li><li>时间跟踪</li><li>回应 - 表情</li><li>过滤<ul><li>Open</li><li>Closed</li><li>你的仓库</li><li>被指派工单</li><li>你创建的工单</li><li>仓库</li></ul></li><li>排序： 最老的、最近更新、评论数量</li><li>搜索、评论、附件</li></ul></li><li>数据模型位于 <a href="https://github.com/go-gitea/gitea/tree/master/models">models</a><ul><li>13 个关于用户的模型文件</li><li>23 个关于仓库的模型文件</li><li><strong>28</strong> 个关于工单的模型文件 - 是系统中最多的模块</li></ul></li><li>评论作为活动/指令，Issues 基于时间关联评论修改操作</li></ul><p>核心 Issue 模型</p><pre><code class="language-go">// Issue represents an issue or pull request of repository.
type Issue struct {
    ID               int64       `xorm:&quot;pk autoincr&quot;`
    RepoID           int64       `xorm:&quot;INDEX UNIQUE(repo_index)&quot;`
    Repo             *Repository `xorm:&quot;-&quot;`
    Index            int64       `xorm:&quot;UNIQUE(repo_index)&quot;` // Index in one repository.
    PosterID         int64       `xorm:&quot;INDEX&quot;`
    Poster           *User       `xorm:&quot;-&quot;`
    OriginalAuthor   string
    OriginalAuthorID int64      `xorm:&quot;index&quot;`
    Title            string     `xorm:&quot;name&quot;`
    Content          string     `xorm:&quot;TEXT&quot;`
    RenderedContent  string     `xorm:&quot;-&quot;`
    Labels           []*Label   `xorm:&quot;-&quot;`
    MilestoneID      int64      `xorm:&quot;INDEX&quot;`
    Milestone        *Milestone `xorm:&quot;-&quot;`
    Project          *Project   `xorm:&quot;-&quot;`
    Priority         int
    AssigneeID       int64        `xorm:&quot;-&quot;`
    Assignee         *User        `xorm:&quot;-&quot;`
    IsClosed         bool         `xorm:&quot;INDEX&quot;`
    IsRead           bool         `xorm:&quot;-&quot;`
    IsPull           bool         `xorm:&quot;INDEX&quot;` // Indicates whether is a pull request or not.
    PullRequest      *PullRequest `xorm:&quot;-&quot;`
    NumComments      int
    Ref              string

    DeadlineUnix timeutil.TimeStamp `xorm:&quot;INDEX&quot;`

    CreatedUnix timeutil.TimeStamp `xorm:&quot;INDEX created&quot;`
    UpdatedUnix timeutil.TimeStamp `xorm:&quot;INDEX updated&quot;`
    ClosedUnix  timeutil.TimeStamp `xorm:&quot;INDEX&quot;`

    Attachments      []*Attachment `xorm:&quot;-&quot;`
    Comments         []*Comment    `xorm:&quot;-&quot;`
    Reactions        ReactionList  `xorm:&quot;-&quot;`
    TotalTrackedTime int64         `xorm:&quot;-&quot;`
    Assignees        []*User       `xorm:&quot;-&quot;`

    // IsLocked limits commenting abilities to users on an issue
    // with write access
    IsLocked bool `xorm:&quot;NOT NULL DEFAULT false&quot;`

    // For view issue page.
    ShowTag CommentTag `xorm:&quot;-&quot;`
}
</code></pre><p>关联内容</p><ul><li>上下文关联: Repo, Project</li><li>元信息关联: Poster, OriginalAuthor, PullRequest</li><li>分类关联: Labels, Milestone</li><li>指派关联: Assignee, Assignees</li><li>内容关联: Attachments, Comments, Reactions</li></ul><p>评论核心模型</p><pre><code class="language-go">// Comment represents a comment in commit and issue page.
type Comment struct {
    ID               int64       `xorm:&quot;pk autoincr&quot;`
    Type             CommentType `xorm:&quot;INDEX&quot;`
    PosterID         int64       `xorm:&quot;INDEX&quot;`
    Poster           *User       `xorm:&quot;-&quot;`
    OriginalAuthor   string
    OriginalAuthorID int64
    IssueID          int64  `xorm:&quot;INDEX&quot;`
    Issue            *Issue `xorm:&quot;-&quot;`
    LabelID          int64
    Label            *Label   `xorm:&quot;-&quot;`
    AddedLabels      []*Label `xorm:&quot;-&quot;`
    RemovedLabels    []*Label `xorm:&quot;-&quot;`
    OldProjectID     int64
    ProjectID        int64
    OldProject       *Project `xorm:&quot;-&quot;`
    Project          *Project `xorm:&quot;-&quot;`
    OldMilestoneID   int64
    MilestoneID      int64
    OldMilestone     *Milestone `xorm:&quot;-&quot;`
    Milestone        *Milestone `xorm:&quot;-&quot;`
    AssigneeID       int64
    RemovedAssignee  bool
    Assignee         *User `xorm:&quot;-&quot;`
    AssigneeTeamID   int64 `xorm:&quot;NOT NULL DEFAULT 0&quot;`
    AssigneeTeam     *Team `xorm:&quot;-&quot;`
    ResolveDoerID    int64
    ResolveDoer      *User `xorm:&quot;-&quot;`
    OldTitle         string
    NewTitle         string
    OldRef           string
    NewRef           string
    DependentIssueID int64
    DependentIssue   *Issue `xorm:&quot;-&quot;`

    CommitID        int64
    Line            int64 // - previous line / + proposed line
    TreePath        string
    Content         string `xorm:&quot;TEXT&quot;`
    RenderedContent string `xorm:&quot;-&quot;`

    // Path represents the 4 lines of code cemented by this comment
    Patch       string `xorm:&quot;-&quot;`
    PatchQuoted string `xorm:&quot;TEXT patch&quot;`

    CreatedUnix timeutil.TimeStamp `xorm:&quot;INDEX created&quot;`
    UpdatedUnix timeutil.TimeStamp `xorm:&quot;INDEX updated&quot;`

    // Reference issue in commit message
    CommitSHA string `xorm:&quot;VARCHAR(40)&quot;`

    Attachments []*Attachment `xorm:&quot;-&quot;`
    Reactions   ReactionList  `xorm:&quot;-&quot;`

    // For view issue page.
    ShowTag CommentTag `xorm:&quot;-&quot;`

    Review      *Review `xorm:&quot;-&quot;`
    ReviewID    int64   `xorm:&quot;index&quot;`
    Invalidated bool

    // Reference an issue or pull from another comment, issue or PR
    // All information is about the origin of the reference
    RefRepoID    int64                 `xorm:&quot;index&quot;` // Repo where the referencing
    RefIssueID   int64                 `xorm:&quot;index&quot;`
    RefCommentID int64                 `xorm:&quot;index&quot;`    // 0 if origin is Issue title or content (or PR&#x27;s)
    RefAction    references.XRefAction `xorm:&quot;SMALLINT&quot;` // What hapens if RefIssueID resolves
    RefIsPull    bool

    RefRepo    *Repository `xorm:&quot;-&quot;`
    RefIssue   *Issue      `xorm:&quot;-&quot;`
    RefComment *Comment    `xorm:&quot;-&quot;`

    Commits     *list.List `xorm:&quot;-&quot;`
    OldCommit   string     `xorm:&quot;-&quot;`
    NewCommit   string     `xorm:&quot;-&quot;`
    CommitsNum  int64      `xorm:&quot;-&quot;`
    IsForcePush bool       `xorm:&quot;-&quot;`
}
</code></pre><p>因为评论同时表示了 Issue 的评论和 Commit 评论，因此包含了很多提交相关的信息。评论有相当多的类型</p><pre><code class="language-go">const (
  // 普通评论 - 可关联到提交和行
    CommentTypeComment CommentType = iota
    CommentTypeReopen
    CommentTypeClose

    CommentTypeIssueRef         // 工单引用
    CommentTypeCommitRef        // 提交引用
    CommentTypeCommentRef       // 评论引用
    CommentTypePullRef          // PR 引用
    CommentTypeLabel            // 标签修改
    CommentTypeMilestone        // 里程碑修改
    CommentTypeAssignees        // 指派人修改
    CommentTypeChangeTitle      // 标题修改
    CommentTypeDeleteBranch     // 删除分支
    CommentTypeStartTracking    // 开始时间跟踪
    CommentTypeStopTracking     // 结束时间跟踪
    CommentTypeAddTimeManual    // 手动添加时间跟踪信息
    CommentTypeCancelTracking   // 取消时间跟踪
    CommentTypeAddedDeadline    // 添加截止日期
    CommentTypeModifiedDeadline // 修改截止日期
    CommentTypeRemovedDeadline  // 删除截止日期
    CommentTypeAddDependency    // 添加依赖
    CommentTypeRemoveDependency // 删除依赖
    CommentTypeCode             // 评论代码行
    CommentTypeReview           // PR 评论反馈
    CommentTypeLock             // 锁定工单为协作者
    CommentTypeUnlock           // 解锁工单
    CommentTypeChangeTargetBranch // 修改 PR 目标分支
    CommentTypeDeleteTimeManual // 删除时间跟踪
    CommentTypeReviewRequest    // 添加或删除审核请求
    CommentTypeMergePull        // 合并 PR
    CommentTypePullPush         // 推送到 PR head 分支
    CommentTypeProject          // 修改项目
    CommentTypeProjectBoard     // 修改项目面板
)
</code></pre><p>评论类型非常详细，因为 Issues 是基于时间线的事件，评论等同于注释，每个注释都是一个命令，使用命令的方式才能实现时间线变化。</p><h2>Gitlab</h2><p>Gitlab 相比 Gitea 的 Issues 功能更加强大</p><p><strong>Issues <a href="https://docs.gitlab.com/ee/user/project/issues/">功能特性</a></strong></p><ul><li>内容: 标题, 描述, 任务</li><li>人员: 作者, 指派人</li><li>状态: 打开/关闭, 健康状态, 可信度, 任务完成度</li><li>计划和跟踪: 里程碑, 截止日期，权重，时间跟踪，标签，投票，表情，工单关联，Epic 关联，唯一的编号和地址</li><li>其他相关功能<ul><li>看板</li><li>Epic</li><li>服务台/Service Deck</li><li>外部集成</li><li>带范围支持层级的 Label</li><li>用户 Todo List</li><li>燃尽图</li><li>分组管理 - 组级别可统计和管理组内项目</li><li>迭代</li><li>设计管理</li><li>价值流</li><li>洞察</li></ul></li></ul><p>Issues 对于 Gitlab 来说不只是工单管理，在最基础的功能上实现了更多管理和分析相关的功能，作为有一定规模的团队，这些附加的功能都是很有必要的。</p><p>核心 <a href="https://github.com/gitlabhq/gitlabhq/blob/2eaa60e4555bb11ad5c0af905217f0fa61cf7cc9/db/structure.sql#L13105">issues</a>  表</p><ul><li>API <a href="https://docs.gitlab.com/ee/api/api_resources.html">Reference</a></li><li>GraphQL <a href="https://gitlab.com/-/graphql-explorer">explorer</a></li></ul><pre><code class="language-sql">CREATE TABLE issues (
    id integer NOT NULL,
    title character varying,
    author_id integer,
    project_id integer,                       -- 项目管理
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    description text,
    milestone_id integer,                     -- 里程碑
    iid integer,                              -- 项目内 ID
    updated_by_id integer,
    weight integer,
    confidential boolean DEFAULT false NOT NULL,  -- 隐秘
    due_date date,                            -- 截止日期
    moved_to_id integer,                      -- 迁移
    lock_version integer DEFAULT 0,
    title_html text,
    description_html text,
    time_estimate integer,                    -- 时间预估
    relative_position integer,
    service_desk_reply_to character varying,
    cached_markdown_version integer,
    last_edited_at timestamp without time zone,
    last_edited_by_id integer,
    discussion_locked boolean,
    closed_at timestamp with time zone,
    closed_by_id integer,
    state_id smallint DEFAULT 1 NOT NULL,     -- 状态
    duplicated_to_id integer,                 -- 重复标志
    promoted_to_epic_id integer,              -- epic
    health_status smallint,                   -- 健康状态
    external_key character varying(255),      -- 外部关联
    sprint_id bigint,                         -- sprint 关联
    issue_type smallint DEFAULT 0 NOT NULL,   -- 类型
    blocking_issues_count integer DEFAULT 0 NOT NULL,
    CONSTRAINT check_fba63f706d CHECK ((lock_version IS NOT NULL))
);


-- 提及的用户
CREATE TABLE issue_user_mentions (
    id bigint NOT NULL,
    issue_id integer NOT NULL,
    note_id integer,
    mentioned_users_ids integer[],
    mentioned_projects_ids integer[],
    mentioned_groups_ids integer[]
);
-- 指派关系
CREATE TABLE issue_assignees (
    user_id integer NOT NULL,
    issue_id integer NOT NULL
);
-- 邮件 - service desk
CREATE TABLE issue_email_participants (
    id bigint NOT NULL,
    issue_id bigint NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    email text NOT NULL
);
-- slas
CREATE TABLE issuable_slas (
    id bigint NOT NULL,
    issue_id bigint NOT NULL,
    due_at timestamp with time zone NOT NULL
);
-- 严重程度
CREATE TABLE issuable_severities (
    id bigint NOT NULL,
    issue_id bigint NOT NULL,
    severity smallint DEFAULT 0 NOT NULL
);
-- epic
CREATE TABLE epic_issues (
    id integer NOT NULL,
    epic_id integer NOT NULL,
    issue_id integer NOT NULL,
    relative_position integer
);
</code></pre><p>Gitlab 不是通过注释来关联活动，而是通过 events 进行关联。例如</p><pre><code class="language-sql">-- 迭代事件
CREATE TABLE resource_iteration_events (
    id bigint NOT NULL,
    user_id bigint NOT NULL,
    issue_id bigint,
    merge_request_id bigint,
    iteration_id bigint,
    created_at timestamp with time zone NOT NULL,
    action smallint NOT NULL
);
-- 标签事件
CREATE TABLE resource_label_events (
    id bigint NOT NULL,
    action integer NOT NULL,
    issue_id integer,
    merge_request_id integer,
    epic_id integer,
    label_id integer,
    user_id integer,
    created_at timestamp with time zone NOT NULL,
    cached_markdown_version integer,
    reference text,
    reference_html text
);
-- 里程碑事件
CREATE TABLE resource_milestone_events (
    id bigint NOT NULL,
    user_id bigint,
    issue_id bigint,
    merge_request_id bigint,
    milestone_id bigint,
    action smallint NOT NULL,
    state smallint NOT NULL,
    created_at timestamp with time zone NOT NULL
);
-- 状态事件
CREATE TABLE resource_state_events (
    id bigint NOT NULL,
    user_id bigint,
    issue_id bigint,
    merge_request_id bigint,
    created_at timestamp with time zone NOT NULL,
    state smallint NOT NULL,
    epic_id integer,
    source_commit text,
    close_after_error_tracking_resolve boolean DEFAULT false NOT NULL,
    close_auto_resolve_prometheus_alert boolean DEFAULT false NOT NULL,
    source_merge_request_id bigint,
    CONSTRAINT check_f0bcfaa3a2 CHECK ((char_length(source_commit) &lt;= 40)),
    CONSTRAINT state_events_must_belong_to_issue_or_merge_request_or_epic CHECK ((((issue_id &lt;&gt; NULL::bigint) AND (merge_request_id IS NULL) AND (epic_id IS NULL)) OR ((issue_id IS NULL) AND (merge_request_id &lt;&gt; NULL::bigint) AND (epic_id IS NULL)) OR ((issue_id IS NULL) AND (merge_request_id IS NULL) AND (epic_id &lt;&gt; NULL::integer))))
);
-- 权重事件
CREATE TABLE resource_weight_events (
    id bigint NOT NULL,
    user_id bigint,
    issue_id bigint NOT NULL,
    weight integer,
    created_at timestamp with time zone NOT NULL
);
</code></pre><p>使用事件的模式则都是反向关联，扩展性相对通过 Type+条件字段 更好，模块之间影响也会更小。但需要查询所有的事件则会麻烦一点。</p><p>Gitlab 的 Issues 页面是在服务端生成的，且生成的内容会缓存，Markdown 生成的 HTML 会直接写入表中，某种程度上减少了需要客户端拉取所有事件的复杂度。</p><h2>总结</h2><p>虽然只看了 Gitea 和 Gitlab 的实现，但也足够有参考意义，如果要实现简单的工单系统，可能会选择第一种，但要实现复杂的逻辑则考虑选择第二种方式。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[理解孩子的视力]]></title>
            <link>https://wener.me/story/understand-baby-vision</link>
            <guid>understand-baby-vision</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[新生儿的视力是非常弱的，只能看到非常近距离的物体。在六七周后孩子的眼睛应该会随着物体转动。]]></description>
            <content:encoded><![CDATA[<p>新生儿的视力是非常弱的，只能看到非常近距离的物体。在六七周后孩子的眼睛应该会随着物体转动。
前一两岁的时候，孩子的视力发育会非常迅速，到两岁时视力基本等同于正常成年人的视力。</p><p>父母应该关注孩子的眼睛有没有以下现象</p><ul><li>双眼不对称转动或交叉</li><li>小孩子不对脸和玩具感兴趣</li><li>眼球转动有轻微颤抖</li><li>看东西头部倾斜</li><li>看东西挤眼</li></ul><p>一两岁的孩子视力正处于发育阶段，因此是否需要佩戴眼镜，眼睛是否有视力问题需要先检测并且进行一定的观察。</p><h2>孩子的视力</h2><p>人们通常对佩戴眼镜有错误的认识：</p><ul><li>小的时候佩戴了眼镜，长大后便不需要了</li><li>小的时候佩戴了眼镜，会产生依赖，导致以后一直会佩戴眼镜</li></ul><p>上述的说法并不正确，小孩子之所以需要佩戴眼镜，更多的原因是 <strong>先天性</strong> 的 近视、远视、散光导致的。
如果不通过眼镜干预，眼睛的情况并不会自己得到改善甚至可能加重。</p><p>近视通常发生在 8-15 岁，但也可能更早。
远视则更为常见，只要远视不过于严重都不需要进行人为干预。但严重的远视会导致看不清近处的物体，甚至看近处物体时会变成“斗鸡眼”。
远视通常发生在两岁左右。
几乎 <strong>所有人</strong> 都会有一定程度的散光，如果散光较为严重，则需要佩戴眼镜。</p><p>与成年人不同的地方在于，小孩子需要佩戴眼镜以预防 <strong>弱视</strong>，弱视的是说双眼情况不同，正常的眼睛受不正常影响，导致最终双眼无法聚焦。
弱视较为严重的时候，则需要佩戴眼镜来 <strong>保护</strong> 正常的眼睛。</p><h2>孩子的眼镜</h2><p>现代医学能够很容易测量孩子的视力问题，即便小孩子不配合也能够进行准确测量。</p><p>现在的大多镜片都是塑料的，比传统的玻璃镜片更硬更轻。建议镜片进行防刮涂层处理，因为小孩子很容易就把眼镜刮花了。
要注意镜片不要过暗，避免无法看清室内环境。</p><p>镜框则选择安全舒适的即可。现在有较多的方式保持眼镜不会掉落，扁鼻梁的孩子眼镜可能更容易脱落。
学步的儿童可选择佩戴耳勾，婴幼儿可选择佩戴眼链。选择合适的眼镜佩戴尽量让眼镜和孩子一起“成长”，避免侧臂折断。</p><p>小孩子大多不会配合佩戴眼镜，这时候需要家长进行分散注意力、诱导或者“投食”来帮助孩子养成佩戴眼镜的习惯。
如果实在不行，可让眼科医生开眼药水，在没有眼镜时将正常眼镜模糊掉，这样通常可以克服孩子的初期抵抗。</p><h2>孩子的阅读问题</h2><p>当孩子有阅读困难时，家长通常认为是眼睛有问题，如果检查排除了所有的视力问题，那么更可能是孩子有学习障碍。</p><p>学习障碍是人在 不同领域的能力和表现差距。与智力智商 <strong>无关</strong>。学习障碍可能会导致孩子在学校表现较差，如果不进行干预则会导致孩子产生自卑情绪，进而厌学。</p><p>学习障碍和阅读问题通常与眼睛无关，更多的是需要尝试不同的教育方式。父母在这个过程极其重要，需要更多鼓励支持孩子，更多的陪同，一起阅读等。
具有学习障碍的孩子需要更多的鼓励，尝试并发现其他的感兴趣的领域，发觉他们独特的能力。</p><h2>孩子的眼睛安全</h2><p>每个人的眼睛都可能受伤，特别是小孩子则更为常见，但在家长的监护下或者佩戴防护眼镜 90% 的问题都是可以避免的。</p><p>在进行运动时佩戴护目镜可保护眼睛，例如 篮球，羽毛球等。
选择树脂镜片，安全的镜框可避免佩戴的眼镜带来的额外伤害，美国有 ANSI Z87.1 标准定义眼镜的安全标准。</p><p>适当的家长监督也极为重要，不要让孩子玩 烟花、BB 抢、快速或锋利的物体，例如 飞镖、剪刀、小刀、笔等。
在草坪上也需要注意石头等避免绊倒被草刺伤。化学物品则需要注意厕所洗剂，衣物洗剂等。</p><h2>高度远视的危害和严重性</h2><p>因为远视发生在两岁或者更早的时候，远视会导致近处物体模糊，致使孩子发育受到影响。常见的影响如下</p><ul><li>无法看清父母</li><li>无法看清食物</li><li>无法看清模仿近处面孔 - 语言发育受到影响</li><li>无法看清脚下 - 运动机能发育迟缓</li><li>无法看清脚下的玩具 - 可观测孩子的行为轨迹确认是否有远视</li><li>较少观察周围物体 - 较少与近处物体交互 - 影响运动机能</li></ul><p>戴眼镜不只是为了孩子看得清，更重要的是确保孩子正常发育。</p><h2>理解散光</h2><p> 散光是由于屈光不正导致，眼球角膜或晶状体弧度异常，不是圆形而是偏椭圆形。导致光进入视网膜后无法正常聚焦，成像模糊。
小孩子的散光大多有遗传因素，其他的也可能是由于受伤或手术导致。</p><p>散光现象：</p><ul><li>视线模糊扭曲</li><li>眼睛易疲劳或有压力</li><li>头疼</li><li>斜视</li><li>夜晚视野不好</li></ul><p>散光类型：</p><ul><li>晶状体散光 - 由晶状体导致而非角膜导致</li><li>近视散光</li><li>远视散光</li><li>混合散光 - 既有近视又有远视的情况</li></ul><p>散光也分为正常和非正常，正常指两个曲面为 90 度，不正常则指非 90 度。
非正常散光通常由于眼部受伤、眼睛神经创伤、手术或眼睛特殊条件（圆锥角膜）导致，眼睛角膜变薄的现象。</p><p>散光治疗：</p><ul><li>眼镜 - 常见常用方式</li><li>隐形眼镜 - 可用于低度散光</li><li>屈光手术 - 激光矫正眼球形状</li></ul><h2>眼睛手术</h2><p>:::warn</p><p>屈光矫正并不是必须的，如果度数过于严重，佩戴眼镜或者隐形眼镜已经严重影响生活的时候可以考虑。</p><p>:::</p><p>眼睛的问题通常都是固定存在的，就好比人的身高。但眼球的形状是可以强制激光手术矫正的。
目前大多使用准分子激光来矫正角膜。成功的屈光矫正手术可以减轻或治愈近视、远视、老化和散光。</p><p>手术类型分为：</p><ul><li>角膜瓣处理 - 使用激光切除部分厚的角膜瓣<ul><li>LASIK / Laser-Assisted in Situ Keratomileusis / 准分子激光原位角膜磨镶术</li></ul></li><li>角膜表面层处理 - 不需要切除，区别仅在于不上皮处理不同<ul><li>PRK / Photorefractive keratectomy / 激光屈光角膜切削术<ul><li>2015 年后完全由 TransPRK 取代</li><li>激光照在角膜表面组织使其蒸散挥发掉，伤口周围不平整，术后疼痛感较高，且恢复期较慢，但不须制作角膜瓣可以保留较多的角膜厚度。</li><li>1980 年，传统的手术方式</li></ul></li><li>LASEK / Laser Assisted Sub-Epithelium Keratomileusis</li><li>TransPRK / Transepithelial Photorefractive Keratectomy / 经上皮激光屈光角膜削切术<ul><li><strong>降低</strong> LASIK 手术后可能的 <em>角膜移位</em> 、 <em>游离角膜瓣</em> 、<em>太薄的角膜瓣</em> 等风险</li><li>减低传统 PRK 疼痛感</li><li>不需接触角膜，避免人为接触风险</li><li>不必制作角膜瓣的屈光矫正手术，能提供最佳角膜稳定性及长期安全性</li><li>2009 年，对比 PRK 不需要用溶剂泡角膜上皮，利用准分子激光以单一步骤削切角膜上皮和进行度术矫正。</li></ul></li></ul></li><li>角膜切口处理</li></ul><p><strong>手术风险</strong></p><p>患有视网膜、角膜眼疾的人不建议手术。患有青光眼、糖尿病、不受控制的血管疾病、免疫疾病也不建议手术。
手术会导致角膜变薄，术后也可能会有角膜破裂的风险，最终只能选择角膜移植，因此角膜的厚度测量是非常重要的步骤。
部分人可能由于眼睛形状的问题也不便于手术。</p><p>目前屈光矫正手术日趋完善，但不可避免的还是可能会导致意外后果，例如 术后产生重影、光晕、斑点、双视、眼睛干燥等问题。
如果使用 LASIK 等方式，新增的角膜瓣可能会导致术后多年疼痛的适应过程。
如果患有斜视，则还需要考虑术后处理斜视问题，屈光矫正应优先于斜视进行，但可能会增加或减少斜视。</p><p><strong>儿童手术风险</strong></p><p>儿童风险远大于成人，因为儿童手术需要进行麻醉，本身会带来额外风险。
儿童处于发育期，眼睛情况尚未完全定型，如果进行矫正手术还要考虑孩子未来的发展情况。</p><p><strong>手术费用</strong></p><p>目前大多手术的方式基本在 10000¥ 到 40000¥ 之间， LASIK 和 LASEK 相对价格低廉，大约 15000¥ 左右。
手术价格区分单眼和双眼，单眼可基本按照半价计算。</p><blockquote><p>手术费用参考自香港和美国</p></blockquote><h2>最后</h2><p>作为父母，都希望自己的子女健康平安，但如果真的眼睛有问题也不要惊慌，应尽快确诊确定处理方案，如果结论是要带眼镜，那就应该趁早给孩子准备好眼镜，培养佩戴眼镜的习惯。</p><h2>参考</h2><ul><li><a href="http://carabineyecare.com/what-parents-should-know-about-infants-and-babies-and-their-vision">What Parents Should Know About Infants and Babies and Their Vision</a><ul><li>大多内容翻译自该文章</li></ul></li><li><a href="https://www.bisselleyecare.com/mothers-story/">A MOTHER’S STORY</a></li><li>Wikipedia</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[为什么需要 GraphQL]]></title>
            <link>https://wener.me/story/why-need-graphql</link>
            <guid>why-need-graphql</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[项目开始时人员配备一般有几种情况]]></description>
            <content:encoded><![CDATA[<p>项目开始时人员配备一般有几种情况</p><ul><li>前后端同一个人</li><li>前后端同一个团队</li><li>前后端不同人同一个团队</li><li>前后端不同人不同团队</li></ul><p>开发的应用一般区分为</p><ul><li>重前端</li><li>重后端</li><li>业务性</li><li>数据性</li><li>内容性</li></ul><p>因此会遇到几个现象</p><ul><li>前后端开发进度不同</li><li>前后端相同模块功能复杂度不同</li><li>不同的后端对象有相同的数据关联</li><li>相同前端不同模块需要不同数据</li><li>不同前端需要使用不同数据</li><li>前端请求一次数据后会再次发起 N 次请求 - N+1</li><li>前端一个模块需要对应多个后端</li></ul><p>那么就会考虑几个场景</p><ul><li>前端自行选择要哪些数据字段</li><li>前端提供关联的数据项进行一次性返回</li><li>后端整合其他服务返回结果进行一次性返回</li></ul><p>那么这时候就可以选择使用 GraphQL。</p><h2>GraphQL 不适合场景</h2><ul><li>快速进入开发 - 如果项目刚开始想要速度快，那最好还是 REST<ul><li>没有时间投入了解 GraphQL 方案</li></ul></li><li>一个前端一个后端，前端逻辑确定，后端不需要变动则没必要使用 GraphQL<ul><li>一次性工作，项目不需要演进</li></ul></li></ul><h2>应用场景举例</h2><h3>选择性的返回较重的请求</h3><pre><code class="language-sql">create table users (
  id bigint,
  name text
);
create table orders (
  id bigint,
  user_id bigint,
  title text
);
</code></pre><p>现在 个人页 需要在请求用户时同时返回用户的订单总数，但其他场景不需要。</p><pre><code class="language-graphql">object User {
  id: Int
  name: String
  orderCount: Int # -&gt; select count(*) from orders where user_id = source.id
}
</code></pre><p>通过 GraphQL 可以将选择留给前端，不需要由后端去决定什么时候要返回一个相对“昂贵”的请求。</p><h3>复杂关联关系</h3><pre><code class="language-sql">create table users (
  id bigint,
  name text
);
create table articles (
  id bigint,
  title text
);
create table lables (
  id bigint,
  color_id bigint,
  name text
  target_id bigint,
  target_type bigint -- User, Label
);
create table lable_colors (
  id bigint,
  color text
)
</code></pre><p>因为 用户 和 文章 都支持打标签，因此在实现时相同的逻辑需要多次实现。
使用 GraphQL 简化关联对象查询。</p><pre><code class="language-graphql">object User {
  id: Int
  name: String
  lables: Label[] # -&gt; select * from lables where target_id = source.id and target_type = &#x27;User&#x27;
}
object Article {
  id: Int
  title: String
  lables: Label[] # -&gt; select * from lables where target_id = source.id and target_type = &#x27;Article&#x27;
}
object Lable {
  name: String
  color: LableColor
}
object LableColor {
  color: String
}
</code></pre><p>在查询时即可一次性查询，而且增加额外的关联也相对简单。</p><pre><code class="language-graphql">user:User{
  name
  lables: {
    name
    color: {
      color
    }
  }
}
article:Article {
  title
  labels: {
    name
  }
}
</code></pre><h3>网关整合服务</h3><ul><li>假设有一个 外部的 邮件服务，现在需要在获取用户时同时返回邮件数量</li><li>此时可以通过网关将该服务整合到现有的 GraphQL 服务中</li></ul><pre><code class="language-graphql">object User {
  id: Int
  name: String # 该字段由实际后端处理
  emailCount: Int # 该字段由网关层进行处理
}
</code></pre><h2>总结</h2><p>需要 GraphQL 的理由其实很简单，就是当后端的查询代码写的 “很烦” 的时候，需要从中解脱出来，那么就可以选择使用 GraphQL，给前端更大的选择和控制权。</p><p>:::tip 使用注意事项</p><ul><li>GraphQL 本身就包含了文档<ul><li>不像 REST 还要维护 Swagger/OpenAPI</li></ul></li><li>前后端尽量选择支持生成 GraphQL 的 方式/框架/工具</li><li>生成区分为 先 Schema 或 先 Entity - 看情况按需</li><li>前端使用 TypeScript 能够利用 GraphQL Schema 类型信息</li><li>最好是额外提供 Entity Schema/Metadata/JSONSchema 给前端<ul><li>重数据场景前端组件可直接生成</li><li>前端可按照 Schema 生成查询</li></ul></li></ul><p>:::</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AlpineLinux 安装 Xfce 桌面]]></title>
            <link>https://wener.me/story/alpinelinux-setup-xfce</link>
            <guid>alpinelinux-setup-xfce</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[假设已经有一个基础可用的 AlpineLinux, 如果没有可前往 wenerme/alpine-image 下载或自行制作]]></description>
            <content:encoded><![CDATA[<blockquote><p>假设已经有一个基础可用的 AlpineLinux, 如果没有可前往 <a href="https://github.com/wenerme/alpine-image">wenerme/alpine-image</a> 下载或自行制作</p></blockquote><h2>setup xorg</h2><p>安装 X server 和基础硬件驱动</p><pre><code class="language-bash"># xfce + xorg
setup-xorg-base xfce4 xfce4-terminal dbus-x11 sudo

# xorg 输入设备
apk add xf86-input-mouse xf86-input-keyboard kbd

# Intel 芯片集成显卡
apk add xf86-video-intel
# AMD 显卡
apk add xf86-video-amdgpu
# QEMU
# apk add xf86-video-qxl
# 如果以上都不支持则考虑使用 framebuffer
# apk add xf86-video-fbdev
</code></pre><p>此时已经可以进入 xfce 桌面, 没有登陆界面, 进入界面后可右上角退出登陆或者 <code>Ctrl+Alt+F1</code> 来切换回命令行会话。</p><pre><code class="language-bash"># 通过 xorg 提供的 startx 启动
startx
# 或者指定启动 xfce4
startxfce4
</code></pre><h2>setup lightdm</h2><p>安装 lightdm 后可以可以通过账号密码登陆, 也可以远程 VNC 进入 xfce 会话。</p><pre><code class="language-bash">apk add lightdm-gtk-greeter

# 如果没启动则需要提前开启
rc-service dbus start
rc-update add dbus

# 添加非 root 用户 admin 密码 admin - 不少应用需要非 root 用户
adduser -d admin
echo admin:admin | chpasswd
echo &#x27;admin ALL=(ALL) NOPASSWD: ALL&#x27; &gt;&gt; /etc/sudoers

# 开机进入登陆界面
rc-update add lightdm
# 立即启动 lightdm 进行登陆
rc-service lightdm start
</code></pre><h2>setup xfce</h2><p>安装常用的包</p><pre><code class="language-bash"># 默认无法显示中文字符
apk add noto-font-cjk

# 允许非 root 通过 fuse 访问设备
apk add gvfs-fuse gvfs-smb
rc-service fuse start
rc-update add fuse

# 自动挂载 外部设备
apk add thunar-volman udisks2
# 部分设备需要额外的包
# gvfs-mtp - MTP - 媒体播放器和移动设备
# gvfs-gphoto2 - PTP - 相机和移动设备
# gvfs-afc - 苹果移动设备

# 文件管理器支持压缩和解压
apk add thunar-archive-plugin
apk add file-roller # thunar-archive-plugin 支持的管理器
</code></pre><p>安装了相关插件后最好退出会话重新登陆确保生效。</p><h2>应用</h2><pre><code class="language-bash"># 屏保, 任务管理器
apk add xfce4-screensaver xfce4-taskmanager

# 谷歌浏览器 - 也可以通过 flatpak 安装
apk add chromium
# 火狐浏览器
# apk add firefox-esr
</code></pre><h3>flatpak</h3><p>Linux 因为发布版太大了，应用分发比较混乱，且不少应用并不直接支持 musl，使用 flatpak 打包的应用可避免这些问题。</p><pre><code class="language-bash">apk add flatpak
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

# 安装
flatpak install flathub com.visualstudio.code
# 启动
flatpak run com.visualstudio.code
</code></pre><p><strong>常用应用</strong></p><table><thead><tr><th>id</th><th>name</th><th>用途</th></tr></thead><tbody><tr><td>com.visualstudio.code</td><td>VSC</td><td>编辑器</td></tr><tr><td>om.vscodium.codium</td><td>Codium</td><td>编辑器</td></tr><tr><td>org.chromium.Chromium</td><td>Chromium</td><td>浏览器</td></tr><tr><td>org.mozilla.firefox</td><td>Firefox</td><td>浏览器</td></tr><tr><td>org.telegram.desktop</td><td>Telegram</td><td>即时聊天</td></tr><tr><td>com.valvesoftware.Steam</td><td>Steam</td><td>游戏</td></tr><tr><td>org.mozilla.Thunderbird</td><td>Thunderbird</td><td>邮件</td></tr><tr><td>org.filezillaproject.Filezilla</td><td>Filezilla</td><td>文件</td></tr></tbody></table><h3>AppImage</h3><p>不通过 flatpak 需要安装，AppImage 是封装好的一体化应用，类似容器，类似 macOS 应用。
但目前由于 glibc 兼容问题 Alpine 无法运行 AppImage 参见 <a href="https://github.com/AppImage/AppImageKit/issues/1015">AppImage/AppImageKit#1015</a>。</p><p><strong>已知提供 AppImage 的应用</strong></p><ul><li>Jetbrain Toolbox</li><li>Lens - Kubernetes IDE</li></ul><h2>其他服务</h2><ul><li>xrdp - RDP 服务端 - 支持 Windows 直接远程登陆</li><li>gvncviewer - VNC 客户端</li></ul><h1>FAQ</h1><h2>xfce 支持高分辨率</h2><pre><code class="language-bash"># 两倍缩放
# Settings Manager &gt; Appearance &gt; Settings &gt; Window Scaling
xfconf-query -c xsettings -p /Gdk/WindowScalingFactor -s 2
# 调整主题为 默认 xhdpi
# Settings Manager &gt; Window Manager &gt; Style
xfconf-query -c xfwm4 -p /general/theme -s Default-xhdpi
</code></pre><h2>查看当前显卡和声卡信息</h2><pre><code class="language-bash">apk add inxi
inxi -AG
</code></pre><h2>kernel: i915 0000:00:02.0: <!-- -->[drm]<!-- --> <em>ERROR</em> CPU pipe A FIFO underrun</h2><p>如果该错误导致闪烁可添加启动参数避免 <code>i915.enable_psr=0</code></p><blockquote><p><a href="https://wiki.archlinux.org/index.php/Intel_graphics#Screen_flickering">Intel graphics#Screen flickering</a></p><p>可能由于 Intel 集成显卡的节能功能导致</p></blockquote><h2>VNC 远程桌面</h2><pre><code class="language-bash">apk add x11vnc

# 启动服务端访问已打开会话
x11vnc -display :0 -auth /var/run/lightdm/root/\:0
# 然后访问 vnc://&lt;IP&gt;:5900 即可

# 不退出
x11vnc -display :0 -auth /var/run/lightdm/root/\:0 --loop

# 访问时创建新的会话
# 确保 init 能启动
echo &quot;exec startxfce4&quot; &gt;&gt; ~/.xinitrc
apk add xvfb
x11vnc -ncache_cr -display :1 -auth /var/run/lightdm/root/\:1 --create

# 不警告没有设置密码
echo nopw &gt;&gt; ~/.x11vncrc

# 可设置为开机启动
# x11vnc -create -xkb -noxrecord -noxfixes -noxdamage -display :0 -auth /var/run/lightdm/root/:0 -rfbauth /etc/x11vnc.pass -rfbport 5900

# 登陆之前开启 VNC
# x11vnc -auth guess -display :0
</code></pre><blockquote><p>如果服务常开，建议设置密码</p></blockquote><h1>参考</h1><ul><li>AlpineLinux <a href="https://wiki.alpinelinux.org/wiki/Xfce_Setup">Xfce Setup</a></li><li><a href="https://wiki.archlinux.org/index.php/HiDPI#Xfce">HiDPI#Xfce</a></li><li>flatpak <a href="https://flathub.org/apps">应用列表</a></li><li>archlinux <a href="https://wiki.archlinux.org/index.php/x11vnc">x11vnc</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[记录一次修复 init 脚本的经历]]></title>
            <link>https://wener.me/story/fix-init-script</link>
            <guid>fix-init-script</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[问题产生过程]]></description>
            <content:encoded><![CDATA[<h2>问题产生过程</h2><p>由于定制化过 <code>/usr/share/mkinitfs/initramfs-init</code> 脚本，在升级大版本后，该文件被覆盖，导致生成的 initramfs 无法启动系统。</p><p>正常情况升级 <code>/etc</code> 下会产生 <code>.apk-new</code> 后缀文件避免升级覆盖，但由于是 <code>/usr/share</code> 下文件，因此导致覆盖。</p><h2>难点</h2><ul><li>系统使用静态 IP<ul><li>需要提供相同 IP 段地址才能进行 SSH</li><li>假设 IP 为 192.168.66.99/22</li></ul></li><li>系统在硬盘上 - M2<ul><li>无法直接在其他系统上进行修复</li><li>通过提供 U 盘 系统在原地恢复</li></ul></li><li>root 盘有 luks 加密<ul><li>依赖硬件环境</li><li>QEMU 启动无法模拟相同环境</li><li>需要手动输入密钥进行挂载</li></ul></li><li>root 密码为 UUID<ul><li>极其难输入</li><li>且需要输入多次，因此选择网络打通通过 SSH 登陆</li></ul></li></ul><h2>操作过程</h2><h3>准备虚拟机和环境</h3><pre><code class="language-bash"># QEMU 虚拟机
apk add qemu-system-x86_64

# 桥接模拟网络环境 - 使用相同 IP 段访问
ip li add vmbr0 type bridge
ip li set vmbr0 up
# 桥接以便于访问 192.168.66.99/22
ip addr add 192.168.66.1/22 dev vmbr0

# 允许 qemu 桥接网卡
echo &#x27;allow vmbr0&#x27; &gt;&gt; /etc/qemu/bridge.conf
</code></pre><h3>启动系统</h3><pre><code class="language-bash"># 提供 vnc 方便查看
# -curses 方便输入 luks 密钥
# 桥接 vmbr0
qemu-system-x86_64 -accel kvm -m 2G \
  -vnc 0.0.0.0:1 /dev/sda \
  -netdev bridge,br=vmbr0,id=n1 -device virtio-net,netdev=n1 \
  -curses
</code></pre><p>启动后无法进入系统，/sysroot 挂载失败，出现修复 shell</p><pre><code>mount: mounting /dev/sda2 on /sysroot failed: Invalid argument
Mounting root failed.
initramfs emergency recovery shell launched. Type &#x27;exit&#x27; to continue boot
sh: can&#x27;t access tty; job control turned off
/ #
</code></pre><p>此时手动挂载 /sysroot</p><pre><code class="language-bash">cryptsetup open /dev/sda2 cryptroot
# 粘贴密钥

# 挂载 sysroot
mount /dev/mapper/cryptroot /sysroot

# 退出 shell 正常进入系统
exit
</code></pre><h3>修复 init 脚本</h3><pre><code class="language-bash"># 将准备好的 init 脚本直接覆盖
rsync --rsync-path=&#x27;sudo rsync&#x27; --no-owner initramfs-init admin@192.168.66.99:/usr/share/mkinitfs/initramfs-init

# 进入虚拟机
ssh admin@192.168.66.99

# 从新生成 initramfs
mkinitfs

# 为安全起见，验证脚本正确
mkdir -p /tmp/init
cd /tmp/init
# 解压到当前目录
zcat &lt; /boot/initramfs-lts | cpio -idmv
# 确保是正确的脚本
cat init
</code></pre><h3>避免再次出现问题</h3><p>/etc 下配置不会被覆盖，lbu 还能备份，因此将 init 脚本放到 etc，修改 mkinitfs 配置指向期望的脚本。</p><p><a href="https://github.com/alpinelinux/mkinitfs/blob/master/mkinitfs.in">mkinitfs</a> 的配置文件位于 <code>/etc/mkinitfs/mkinitfs.conf</code>, 默认配置 features, 该文件会被脚本直接 source (<a href="https://github.com/alpinelinux/mkinitfs/blob/a4d6120aa949cdb6d18eb8241c4706f96685a359/mkinitfs.in#L237">mkinitfs.in#L237</a>), 从脚本可看出配置变量为 init.</p><pre><code class="language-bash">cp /usr/share/mkinitfs/initramfs-init /etc/mkinitfs/initramfs-init
echo &quot;init=/etc/mkinitfs/initramfs-init&quot; &gt;&gt; /etc/mkinitfs/mkinitfs.conf
</code></pre><h2>总结</h2><p>不要修改 <code>/usr/share</code> 下的默认配置，将配置放到 <code>/etc</code> 下，安全可靠，还可以使用 lbu 备份。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OpenVox VoxStack 网关分析]]></title>
            <link>https://wener.me/story/openvox-gw-inside</link>
            <guid>openvox-gw-inside</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[因为淘到一个二手 OpenVox 语音网关，就好奇"里面"长什么样。]]></description>
            <content:encoded><![CDATA[<p>因为淘到一个二手 OpenVox 语音网关，就好奇&quot;里面&quot;长什么样。</p><p>Let&#x27;s find out.</p><h2>VS-AGU-E2M0800</h2><ul><li>VS - VoxStack 系列 - 模块化，热插拔</li><li>AGU - Analog Gateway - 模拟网关</li><li>软件 1.1.10</li><li>硬件 1.0.0</li></ul><p>一张卡两个模块</p><ul><li>E2M8HJ9DJ68P - VS 模块<ul><li>M83241G13 - Freescale Semiconductor - NXP<ul><li>Telecom Interface ICs C1K-LS102M 450MHz</li><li>IC C1K 450MHZ VOIP 448BGA</li></ul></li></ul></li><li>FXS-420 v1.2 - FS42HJ1KK4UY5<ul><li>S13215-FM</li></ul></li><li>FXO-400 v1.4 - FXODHJO2XT6L<ul><li>3019-FT 1718FF L0L4</li><li>Si3050-FT 1708EM F1Q5</li></ul></li></ul><h2>Web 管理界面</h2><p>界面类似于官方演示 http://admin:<a href="mailto:admin@demo.openvox.cn">admin@demo.openvox.cn</a>:65327</p><p>通过开启 ssh, 账号名设置为 super 可获取到 root 权限，默认 SSH 端口 12345。</p><h2>硬件</h2><blockquote><p>未开箱，不一定准确。</p></blockquote><table><thead><tr><th>-</th><th>规格</th></tr></thead><tbody><tr><td>内存</td><td>120MB</td></tr><tr><td>CPU</td><td>ARMv6-compatible processor rev 5 (v6l)</td></tr></tbody></table><p><strong>Comcerto 1000 M83263G</strong></p><ul><li>ARM1136 - 2 Core, 650MHz</li><li>敏迅科技/Mindspeed Technologies 芯片</li><li>Mindspeed 主要提供 VoIP 领域解决方案 - DSP, LTE, Transcede</li><li>VoIP, Security Engine, PCIe 2, RGMII 2</li><li>SDRAM 16/32 bit DDR2-800/667/533</li><li>L1 缓存 2x(64K D$/64K I$)</li><li>VoIP 能力<ul><li>Field hardened voice features</li><li>World class acoustic echo cancellation technology</li><li>Narrow and wideband codecs</li><li>G.711, G.729, G.722, G.723.1, iLBC, T.38, G.729.1, G.722.2, AMR, AMR Wideband</li><li>Enhanced echo canceller, CID-I/II, VAD/CNG, AGC</li><li>3-Way conferencing</li></ul></li><li>TDM/PCM interface for glue-less VoIP support</li><li>2009 年</li></ul><p><strong>/proc/cpuinfo</strong></p><pre><code>Processor   : ARMv6-compatible processor rev 5 (v6l)
BogoMIPS    : 648.80
Features    : swp half thumb fastmult edsp java
CPU implementer : 0x41
CPU architecture: 6TEJ
CPU variant : 0x1
CPU part    : 0xb36
CPU revision    : 5

Hardware    : Comcerto 1000 (EVM)
Revision    : 0000
Serial      : 0000000000000000
</code></pre><h2>系统环境</h2><blockquote><p>底层基于 OpenWrt</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>uname -a</td><td>Linux General 2.6.33.5 #4 Tue Aug 29 20:38:01 CST 2017 armv6l unknown</td></tr><tr><td>Busybox</td><td>1.4.2</td></tr><tr><td>Asterisk</td><td>1.8.20.0 / 1.8.X 发布于 2010-10-21 EOL 2015-10-21</td></tr><tr><td>dahdi</td><td>2.6.0</td></tr><tr><td>dcra</td><td>0.1.0</td></tr></tbody></table><blockquote><p>Busybox applet</p><p>[, [[, arping, ash, awk, awx, basename, bunzip2, bzcat, cat, chgrp, chmod, chown, chroot, clear, cp, crond, crontab, cut, date, df, dirname, dmesg, du, echo, egrep, env, expr, false, fgrep, find, free, getty, grep, gunzip, gzip, halt, head, hostid, hostname, httpd, id, ifconfig, init, insmod, ipkg, kill, killall, killall5, klogd, length, less, ln, lock, logger, login, logread, ls, lsmod, md5sum, mdev, mesg, mkdir, mkfifo, mknod, mktemp, mount, mv, nc, netmsg, netstat, nice, nslookup, passwd, pidof, ping, ping6, pivot_root, poweroff, printf, ps, pwd, rdate, reboot, renice, reset, rm, rmdir, rmmod, route, sed, seq, sh, sleep, sort, strings, stty, switch_root, sync, sysctl, syslogd, tail, tar, tee, telnet, test, time, top, touch, tr, traceroute, true, tty, udhcpc, umount, uname, uniq, uptime, vconfig, vi, watchdog, wc, wget, which, xargs, yes, zcat</p></blockquote><p><strong>cmdline</strong></p><pre><code>init=/etc/preinit ubi.mtd=4,2048 ubi.block=0,0 root=/dev/ubiblk0_0 ro rootfstype=squashfs hwaddress=eth0,a0:98:05:0e:04:8e hwaddress=eth2,00:03:7F:0B:00:01 console=ttyS0,115200 mtdparts=comcertonand:256k(uboot),128k(env),128K(param),4M(kernel),20M(root),4M(ekernel),20M(eroot),16M(config),-(system) partno=M83263G fppmode=1
</code></pre><p><strong>内核模块</strong></p><table><thead><tr><th>Module</th><th>Size</th><th>Used by</th></tr></thead><tbody><tr><td>wctdmc1k</td><td>30096</td><td>16</td></tr><tr><td>dcra</td><td>8524</td><td>1 wctdmc1k</td></tr><tr><td>dahdi</td><td>185948</td><td>17 wctdmc1k</td></tr><tr><td>krtpd</td><td>148520</td><td>0</td></tr><tr><td>csmencaps</td><td>14740</td><td>2</td></tr><tr><td>led_key</td><td>2500</td><td>4</td></tr></tbody></table><ul><li>dahdi<ul><li>wctdmc1k - OpenVox 模拟信号处理模块<ul><li>WCTDMC1K 设备驱动 - Mindspeed 开发的芯片驱动</li></ul></li><li>dcra - opvx_dcra - Access Dahdi Channel Registers through procfs</li></ul></li><li>csmencaps - 应该是 FX 处理相关模块</li><li>led_key - 应该是驱动面板 led 的</li><li>krtpd - Kernel RTP proxy for Asterisk - openvox 开发<ul><li>类似功能开源 <a href="https://github.com/sipwise/rtpengine">sipwise/rtpengine</a></li></ul></li></ul><pre><code>filename:       /lib/modules/2.6.33.5/dcra.ko
license:        GPL v2
alias:          opvx_dcra
description:    Access Dahdi Channel Registers through procfs
parmtype:       maxchan:int
parmtype:       debug:int
depends:
vermagic:       2.6.33.5 mod_unload ARMv6
</code></pre><p><strong>主要用户进程</strong></p><table><thead><tr><th>proc</th><th>desc</th></tr></thead><tbody><tr><td>/bin/php /my_tools/keeper</td><td></td></tr><tr><td>/bin/php /my_tools/logfile_monitor</td><td></td></tr><tr><td>/my_tools/checkasteriskstat</td><td></td></tr><tr><td>/my_tools/ntpclient</td><td>时间同步</td></tr><tr><td>/my_tools/resetkey</td><td></td></tr><tr><td>/my_tools/sys_restore</td><td></td></tr><tr><td>/my_tools/watchdog</td><td></td></tr><tr><td>/usr/sbin/crond</td><td>定时任务</td></tr><tr><td>/webservice/service</td><td></td></tr><tr><td>asterisk -g</td><td>asterisk 主进程</td></tr><tr><td>dropbear -p 12345</td><td>SSH 守护进程</td></tr><tr><td>lighttpd -f /etc/lighttpd.conf -m /usr/lib/lighttpd</td><td>Web 服务</td></tr></tbody></table><h3>系统目录</h3><ul><li>/www -&gt; /tmp/web/www</li><li>/tmp/web/www - cgi-bin css images index.html js lang - 管理应用</li><li>/data/<ul><li>info/</li><li>log/<ul><li>cdr.db - SQLite 通话记录</li><li>sys-log - 系统日志</li><li>update.txt - 更新日志</li></ul></li><li>sms/</li></ul></li><li>/my_tools/ - 系统工具</li><li>/webservice/service - 服务</li><li>/version<ul><li>version - 系统版本</li><li>build_time - 构建时间</li><li>cfg_ver_list - 配置版本 - 内容 <code>1.1.10</code></li><li>def_cfg.tar.gz - asterisk 配置备份</li><li>openvpn.sample_configs.tar.gz</li><li>sip_bendpoints.sample_configs.tar.gz</li></ul></li></ul><p><strong>系统挂载</strong></p><table><thead><tr><th>dev</th><th>size</th><th>path</th><th>fstype</th></tr></thead><tbody><tr><td>/dev/ubiblk0_0</td><td>16.1M</td><td>/</td><td>rootfs, squashfs</td></tr><tr><td>none</td><td>57.5M</td><td>/tmp</td><td>tmpfs</td></tr><tr><td>tmpfs</td><td>512.0k</td><td>/dev</td><td>tmpfs</td></tr><tr><td>/dev/mtdblock7</td><td>16.0M</td><td>/etc/asterisk</td><td>jffs2</td></tr><tr><td>/dev/mtdblock8</td><td>63.5M</td><td>/data</td><td>jffs2</td></tr></tbody></table><p><strong>mtd 分区</strong></p><table><thead><tr><th>mtd</th><th>fs</th><th>range</th><th>name</th><th>size</th><th>mount</th></tr></thead><tbody><tr><td>mtd0</td><td></td><td>0x000000000000-0x000000040000</td><td>uboot</td><td>256k</td><td></td></tr><tr><td>mtd1</td><td></td><td>0x000000040000-0x000000060000</td><td>env</td><td>128k</td><td></td></tr><tr><td>mtd2</td><td></td><td>0x000000060000-0x000000080000</td><td>param</td><td>128K</td><td></td></tr><tr><td>mtd3</td><td></td><td>0x000000080000-0x000000480000</td><td>kernel</td><td>4M</td><td></td></tr><tr><td>mtd4</td><td>ubi0</td><td>0x000000480000-0x000001880000</td><td>root</td><td>20MB</td><td>/</td></tr><tr><td>mtd5</td><td></td><td>0x000001880000-0x000001c80000</td><td>ekernel</td><td>4M</td><td></td></tr><tr><td>mtd6</td><td></td><td>0x000001c80000-0x000003080000</td><td>eroot</td><td>20M</td><td></td></tr><tr><td>mtd7</td><td>jffs2</td><td>0x000003080000-0x000004080000</td><td>config</td><td>16M</td><td>/etc/asterisk</td></tr><tr><td>mtd8</td><td>jffs2</td><td>0x000004080000-0x000008000000</td><td>system</td><td>63.5MB</td><td>/data</td></tr></tbody></table><p><strong>v1.1.23</strong></p><p>版本变化底层系统和软件均无变化，变化的主要是 php 代码和部分配置。</p><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>uname -a</td><td>Linux General 2.6.33.5 #23 Mon Oct 14 17:12:50 CST 2019 armv6l unknown</td></tr></tbody></table><h3>安装包</h3><blockquote><p>ipkg list</p></blockquote><table><thead><tr><th>pkg</th><th>ver</th></tr></thead><tbody><tr><td>base-files-comcerto1000</td><td>14-unknown</td></tr><tr><td>busybox</td><td>1.4.2-1</td></tr><tr><td>cmm</td><td>7.00-5</td></tr><tr><td>cyclesoak</td><td>none-1</td></tr><tr><td>dropbear</td><td>0.49-1</td></tr><tr><td>ethtool</td><td>3-0</td></tr><tr><td>hotplug2</td><td>0.9-1</td></tr><tr><td>ip</td><td>2.6.23-1</td></tr><tr><td>kernel</td><td>2.6.33.5-comcerto1000-1</td></tr><tr><td>kmod-csme</td><td>2.6.33.5+2.14.0-comcerto1000-1</td></tr><tr><td>kmod-fci</td><td>2.6.33.5+7.00-comcerto1000-1</td></tr><tr><td>kmod-fpp-csme</td><td>2.6.33.5+2.14.0-comcerto1000-1</td></tr><tr><td>kmod-fpp-driver</td><td>2.6.33.5-comcerto1000-1</td></tr><tr><td>kmod-ipt-conntrack</td><td>2.6.33.5-comcerto1000-1</td></tr><tr><td>kmod-ipt-core</td><td>2.6.33.5-comcerto1000-1</td></tr><tr><td>kmod-matisse</td><td>1.00-0</td></tr><tr><td>kmod-nf-conntrack-netlink</td><td>2.6.33.5-comcerto1000-1</td></tr><tr><td>kmod-nfnetlink</td><td>2.6.33.5-comcerto1000-1</td></tr><tr><td>ldd</td><td>14</td></tr><tr><td>libc</td><td>2.7-14</td></tr><tr><td>libcli</td><td>1.9.3-1</td></tr><tr><td>libgcc</td><td>4.1.2-14</td></tr><tr><td>libgdbm</td><td>1.8.3-0</td></tr><tr><td>libgmp</td><td>4.2.1-1</td></tr><tr><td>libiptc</td><td>1.4.7-1</td></tr><tr><td>libncurses</td><td>5.2-8</td></tr><tr><td>libnfconntrack</td><td>0.0.100</td></tr><tr><td>libnfnetlink</td><td>1.0.0</td></tr><tr><td>libopenssl</td><td>0.9.8q-1</td></tr><tr><td>libpcap</td><td>1.1.1-2</td></tr><tr><td>libpopt</td><td>1.7-4</td></tr><tr><td>libpthread</td><td>2.7-14</td></tr><tr><td>librt</td><td>2.7-14</td></tr><tr><td>libstdcpp</td><td>4.1.2-14</td></tr><tr><td>libxtables</td><td>1.4.7-1</td></tr><tr><td>msp-firmware</td><td>2.6.33.5+3.00.11-comcerto1000-1</td></tr><tr><td>mtd</td><td>5</td></tr><tr><td>ntpclient</td><td>2003_194-2</td></tr><tr><td>openssl-util</td><td>0.9.8q-1</td></tr><tr><td>ppp</td><td>2.4.3-7</td></tr><tr><td>ppp-mod-pppoe</td><td>2.4.3-7</td></tr><tr><td>rp-pppoe-client</td><td>3.8-1</td></tr><tr><td>udevtrigger</td><td>106-1</td></tr><tr><td>vapi</td><td>2.14.0</td></tr><tr><td>zlib</td><td>1.2.3-3</td></tr></tbody></table><p><strong>/etc/ipkg.conf</strong></p><pre><code>/etc/ipkg.conf
src snapshots http://openwrt.org/downloads/snapshots/$S/packages
dest root /
dest ram /tmp
</code></pre><h3>系统工具/my_tools</h3><table><thead><tr><th>name</th><th>type</th><th>desc</th></tr></thead><tbody><tr><td>add_syslog</td><td>shell</td><td>log 到 syslog</td></tr><tr><td>addkey_client.sh</td><td>shell</td><td></td></tr><tr><td>addkey_server.sh</td><td>shell</td><td></td></tr><tr><td>astmanproxy</td><td></td><td>Asterisk Manager Proxy</td></tr><tr><td>checkAsteriskProc.sh</td><td>shell</td><td>检测并启动 dahdi 和 asterisk</td></tr><tr><td>checkCapture.sh</td><td>shell</td><td>dahdi 停止 dump 给定 chanid</td></tr><tr><td>checkStartFinish.sh</td><td>shell</td><td>sleep 1000s 重启</td></tr><tr><td>checkasteriskstat</td><td></td><td></td></tr><tr><td>cluster_mode</td><td>php</td><td>配置集群模式 - master, slave, standalone</td></tr><tr><td>cluster_slave</td><td></td><td>slave 应用</td></tr><tr><td>cpuusage</td><td></td><td>CPU 使用情况 - 类似 vmstat</td></tr><tr><td>eth_server.conf</td><td></td><td></td></tr><tr><td>fetch</td><td></td><td>解密固件</td></tr><tr><td>get_backport</td><td></td><td></td></tr><tr><td>gwping</td><td></td><td>eth ping 客户端</td></tr><tr><td>gwpingd</td><td></td><td>eth_server - eth_server.conf 为配置文件</td></tr><tr><td>if_monitor</td><td></td><td></td></tr><tr><td>keeper</td><td></td><td>保持进程存在 - 类似 supervisor</td></tr><tr><td>krtpd_cli</td><td></td><td></td></tr><tr><td>led_key.ko</td><td>内核模块</td><td></td></tr><tr><td>logfile_monitor</td><td>php</td><td>日志监控</td></tr><tr><td>lstast</td><td></td><td></td></tr><tr><td>net_tool</td><td></td><td>获取网卡信息</td></tr><tr><td>ntpclient</td><td></td><td>NTP 客户端</td></tr><tr><td>play_all_led</td><td></td><td>所有 LED 亮</td></tr><tr><td>process_cdr</td><td></td><td>CDR 处理</td></tr><tr><td>readDeviceID</td><td></td><td></td></tr><tr><td>resetkey</td><td></td><td></td></tr><tr><td>restore_cfg_file</td><td></td><td>恢复 asterisk 配置文件</td></tr><tr><td>safe_append_to_file</td><td></td><td></td></tr><tr><td>safe_reboot</td><td>shell</td><td>reboot</td></tr><tr><td>set_busytone.sh</td><td>shell</td><td>fxomon.conf busytone 设置</td></tr><tr><td>set_config</td><td></td><td>配置文件操作</td></tr><tr><td>set_default</td><td></td><td></td></tr><tr><td>set_registers.sh</td><td>shell</td><td>注册 dcra</td></tr><tr><td>sys_restore</td><td></td><td></td></tr><tr><td>unpack.sh</td><td>shell</td><td>用于解压固件 - unzip, md5 checmsum, 解密, unzip</td></tr><tr><td>watchdog</td><td></td><td></td></tr><tr><td>web_language_init</td><td>php</td><td>初始化 web 的语言</td></tr></tbody></table><ul><li>astmanproxy<ul><li><a href="https://github.com/davetroy/astmanproxy">davetroy/astmanproxy</a></li></ul></li></ul><pre><code class="language-bash"># 固件解密 - 类似 fetch
openssl enc -aes-256-cbc -d -in firmware.img -pass pass:O7r8yGv0cdlNM4lQ -out firmware.tar.gz

# 获取配置
/my_tools/set_config /etc/asterisk/gw/web_server.conf get option_value general port 2
</code></pre><h2>固件</h2><p>官网提供固件下载 <a href="https://www.openvox.cn/pub/firmwares">https://www.openvox.cn/pub/firmwares</a> , Web 界面支持上传或在线更新。</p><p>固件更新上传逻辑位于 /www/cgi-bin/php/system-tools.php 。
固件准备好后通过 /my_tools/unpack.sh 解压升级。</p><p><strong>固件格式</strong></p><ul><li>AnalogGateway-current.bin -&gt; tar.gz<ul><li>firmware/AnalogGateway-1.1.20.img.md5</li><li>firmware/AnalogGateway-1.1.20.img - openssl enc&#x27;d data with salted password</li></ul></li><li>AnalogGateway-1.1.20.img - 解密 -&gt; tar.gz<ul><li>AnalogGateway.img - 应该为系统镜像</li><li>key - AnalogGateway.img 的 md5 checksum</li><li>u-boot.bin - bootloader</li><li>upgrade.sh - 升级脚本</li></ul></li></ul><pre><code class="language-bash"># 下载
curl -O https://www.openvox.cn/pub/firmwares/Analog%20Gateway/AnalogGateway-current.bin
# 固件为 tar.gz
tar zxvf AnalogGateway-current.bin
cd firmware
# 固件经过 openssl 加密 - 解密后为 tar.tz
openssl enc -aes-256-cbc -d -in AnalogGateway-*.img -pass pass:O7r8yGv0cdlNM4lQ -out AnalogGateway.tar.gz

# 解压获取实际内容
mkdir firmware
tar zxvf AnalogGateway.tar.gz -C firmware
</code></pre><p><strong>固件升级</strong></p><p>固件升级使用 openvox 内置的自定义工具 /usr/bin/auto_update，主要涉及操作 mtd。</p><pre><code class="language-bash"># -i 1 - 使用 ubiblk
auto_update -i 1
# -b 升级 ubook
auto_update -b u-boot.bin
# -f 更新文件， -u 升级系统
auto_update -u -f AnalogGateway.img
</code></pre><h2>集群模式</h2><p>运行模式通过 /my_tools/cluster_mode 配置。</p><p><strong>slave extension</strong></p><pre><code class="language-ini">#include sip_general.conf
#include sip_endpoints.conf
#include sip_slave.conf

#include extensions_macro.conf
#include extensions_slave.conf
#include extensions_dialmatchingrules.conf

# ext = slave_password+index
[fxs-&lt;ext&gt;-&lt;master_ip&gt;]
exten =&gt; #00,1,playback(Ext_number)
exten =&gt; #00,n,agi(getsipbinding.sh)
exten =&gt; #00,n,Wait(1)
exten =&gt; #00,n,Hangup()
exten =&gt; s,1,Dial(SIP/$sip_extension-$slave_masterip)
exten =&gt; s,n,Hangup()

exten =&gt; *1*2*3*4,1,agi(factoryreset.sh)
exten =&gt; *1*2*3*4,n,Hangup()
exten =&gt; **,1,playback(IP_address)
exten =&gt; **,n,agi(geteth0ip.sh)

[sip-$sip_extension]
exten =&gt; _X.,1,GotoIf($[&quot;${SIP_HEADER(X-Best-Codec)}&quot; = &quot;&quot;]?dial)
exten =&gt; _X.,n,Set(SIP_CODEC=${SIP_HEADER(X-Best-Codec)})
exten =&gt; _X.,n(dial),Dial(dahdi/${i}r1/${EXTEN},$DIALTIMEOUT)
exten =&gt; _X.,n,Hangup()
</code></pre><p><strong>master extension</strong></p><pre><code class="language-ini">#include sip_general.conf
#include sip_endpoints.conf
#include sip_master.conf

#include extensions_macro.conf
#include extensions_fxs.conf
#include extensions_master.conf
#include extensions_internal.conf
#include extensions_routing.conf
;#include extensions_sipdef.conf
#include extensions_dialmatchingrules.conf
</code></pre><h2>VS_USB-400</h2><ul><li>无线网关</li></ul><h3>系统环境</h3><ul><li>软件版本 2.1.22</li><li>硬件版本 1.0</li><li>一个主控，多个模块，模块不带 CPU</li><li>无线模块为 高通 Gobi 无线宽带芯片技术 - GobiNet - USB 驱动</li><li>通道 STM32, 底板 MCU STM8</li><li>该版本包含 frpc - 允许 openvox cloud 建立链接 - 映射了 ssh 和 web</li></ul><blockquote><p>该版本最大的区别是模块不在是独立系统。</p></blockquote><table><thead><tr><th>HW</th><th>Desc</th></tr></thead><tbody><tr><td>CPU</td><td>Intel(R) Atom(TM) CPU Z3735G @ 1.33GHz</td></tr><tr><td>Memory</td><td>1 G</td></tr><tr><td>Disk</td><td>16 G Flash</td></tr></tbody></table><table><thead><tr><th>SW</th><th>Desc</th></tr></thead><tbody><tr><td>Debian</td><td>8</td></tr><tr><td>uname -a</td><td>Linux Wireless-Gateway 4.19.81 #7 SMP Thu Feb 13 08:24:02 CST 2020 i686 i386</td></tr><tr><td>Busybox</td><td>v1.22.1</td></tr><tr><td>Asterisk</td><td>1.8.20.0</td></tr><tr><td>/proc/cmdline</td><td>BOOT_IMAGE=/vmlinuz ro root=LABEL=kernel1 intel_pstate=disable quiet console=ttyS0,115200n8</td></tr></tbody></table><p><strong>/proc/mtrr</strong></p><pre><code>reg00: base=0x0ffd00000 ( 4093MB), size=    4MB, count=1: write-protect
reg01: base=0x000000000 (    0MB), size= 1024MB, count=1: write-back
reg02: base=0x03e000000 (  992MB), size=   32MB, count=1: uncachable
reg03: base=0x03d000000 (  976MB), size=   16MB, count=1: uncachable
reg04: base=0x03ce00000 (  974MB), size=    2MB, count=1: uncachable
reg05: base=0x03c800000 (  968MB), size=    4MB, count=1: uncachable
</code></pre><p><strong>/proc/mounts</strong></p><table><thead><tr><th>dev</th><th>size</th><th>path</th><th>fs</th></tr></thead><tbody><tr><td>/dev/mmcblk0p6</td><td>487.9M</td><td>/etc/cfg</td><td>ext4</td></tr><tr><td>/dev/mmcblk0p7</td><td>487.9M</td><td>/data</td><td>ext4</td></tr><tr><td>/dev/mmcblk0p2</td><td>92.8M</td><td>/boot</td><td>ext4</td></tr><tr><td>/dev/mmcblk0p4</td><td>28.9M</td><td>/gateway</td><td>squashfs</td></tr></tbody></table><p><strong>modules</strong></p><ul><li>GobiNet - 驱动无线模块</li><li>usb_wwan</li><li>cdc_acm</li><li>ch341</li><li>usbserial - 依赖 USB 串口</li><li>cdc_ether</li><li>usbnet</li><li>r8152</li><li>snd_pcm</li><li>snd_timer</li><li>i2c_hid</li><li>i2c_algo_bit</li><li>soundcore</li><li>sdhci_acpi</li><li>button</li></ul><h3>系统目录</h3><ul><li>/my_tools -&gt; /gateway/my_tools</li><li>/sound -&gt; /gateway/sound</li><li>/webservice -&gt; /gateway/webservice</li><li>/version -&gt; /gateway/version</li><li>/www -&gt; /gateway/www</li><li>/conf</li><li>/data<ul><li>log/<ul><li>cdr.db</li><li>smsinbox.db</li><li>smsoutbox.db</li></ul></li></ul></li><li>/etc<ul><li>cfg/ - Asteris 配置 - 独立挂载 - 可备份<ul><li>gw/ - 网关配置<ul><li>n2n/ - 2 层 Mesh 组网</li><li>sim840w.conf - SIM 模块配置 - AT 命令之类</li><li>sim6320.conf - SIM 模块配置</li><li>uc15.conf - SIM 模块配置 - UC15</li><li>sms.conf - 短信配置</li></ul></li><li>cloud/ - 应该是 openvox 云平台之类的 - <a href="https://cloud.openvox.com.cn/">https://cloud.openvox.com.cn/</a><ul><li>cloud.conf</li><li>frpc.ini - openvox 访问 ssh 和 web 的后门</li></ul></li></ul></li><li>udev/rules.d/<ul><li>gobinet.rules - GobiNet 映射 - <code>/sys/class/net/gobinet*</code></li><li>internet.rules - 模块内部 usbnet 映射 - 会 symlink 到 <code>/dev/opvx/</code></li></ul></li></ul></li><li>/tmp<ul><li>hw_info.cfg - 硬件配置 - 由于生成 asterisk gw_gsm.conf 和 extra-channels.conf 配置</li></ul></li><li>/usr/sbin/cloudMain</li><li>/usr/sbin/cloudExternal</li><li>/usr/sbin/cloudNat</li><li>/gateway - 完整网关系统 - 独立挂载<ul><li>www/ - PHP 网站</li><li>my_tools/ - 工具集</li></ul></li></ul><h2>Asterisk</h2><blockquote><p>不管什么版本的网关，Asterisk 的版本似乎都没有变过 - 1.8.20.0</p></blockquote><table><thead><tr><th>mod</th><th>desc</th></tr></thead><tbody><tr><td>chan_extra</td><td>GSM/CDMA Telephony Driver FOR Asterisk</td></tr></tbody></table><ul><li>chan_extra<ul><li>OpenVox 开发的无线模块 - GSM, CDMA 和新的 LTE 均使用该模块</li><li>opvxg4xx 驱动提供支持</li><li>配置文件 extra-channels.conf, chan_extra.conf</li><li>GSM, CDMA 基于 DAHDi</li><li>4G LTE 基于 GobiNet 内核驱动</li><li>驱动下载 <a href="https://www.openvox.cn/pub/misc/GSM/">https://www.openvox.cn/pub/misc/GSM/</a></li></ul></li></ul><pre><code class="language-bash">modprobe opvxg4xx
</code></pre><pre><code class="language-bash"># Asterisk 命令
gsm show spans
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何选择 Asterisk 接口]]></title>
            <link>https://wener.me/story/agi-vs-ami-vs-ari</link>
            <guid>agi-vs-ami-vs-ari</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[Asterisk 自 1999 年发展到现在，已经成为业界标准的 PBX 实现底层，但这 20 多年的发展也让 Asterisk 实现非常多的接口。]]></description>
            <content:encoded><![CDATA[<p>Asterisk 自 1999 年发展到现在，已经成为业界标准的 PBX 实现底层，但这 20 多年的发展也让 Asterisk 实现非常多的接口。</p><h2>接口简介</h2><table><thead><tr><th>API</th><th>Protocol</th><th>Async</th><th>Block</th><th>Access Dialplan</th></tr></thead><tbody><tr><td>AGI</td><td>Shell/Socket</td><td>⛔️</td><td>✅</td><td>✅</td></tr><tr><td>AMI</td><td>TCP/5038/Event</td><td>✅</td><td>⛔️</td><td>⛔️</td></tr><tr><td>ARI</td><td>HTTP/REST/WebSocket</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><p>AGI, AMI 功能完全不同，但 ARI 和 AGI，AMI 都有所重叠。</p><ul><li>AGI - Asterisk Gateway Interface<ul><li>简单</li><li>作为 Dialplan 函数</li></ul></li><li>AMI - Asterisk Manager Interface<ul><li>修改或创建 Channel</li></ul></li><li>ARI - Asterisk RESTful Interface<ul><li><strong>Asterisk 12+</strong></li><li>HTTP Websocket - 事件, Stasis 应用</li><li>RESTful 接口 - 控制底层资源</li></ul></li></ul><h2>接口使用场景</h2><pre><code>AMI - ARI - AGI
呼叫控制
      自定义通信应用
            Dialplan 执行
</code></pre><ul><li>AGI - 扩展 Dialplan 处理<ul><li>建议实现 通用 - 独立 - 特性无关 的 Dialplan 函数</li><li>例如 呼叫建立、拆除；外线控制；CDR</li></ul></li><li>AMI - 适用于通话时通道管控</li><li>ARI<ul><li>ARI 包含 AMI 和 AGI 主要功能</li><li>自定义 Dialplan 应用</li><li>高度定制</li></ul></li></ul><p>开发使用一定要缺少边界，因为很多功能是这也可以那也可以。</p><pre><code class="language-mermaid">sequenceDiagram
    PJSIP -&gt;&gt; Dialplan: 处理通道
    Dialplan -&gt;&gt; AGI: 路由
    AGI -&gt;&gt; Handler: 处理 FastAGI/AGI 请求
    Handler -&gt;&gt; Dialplan: 应用确定如何处理，返回下一个 Dialplan
    Dialplan -&gt;&gt; Stasis: 执行 Stasis Dialplan
    Stasis -&gt;&gt; Handler: 处理 ARI 实现自定义应用
</code></pre><h2>其他接口</h2><ul><li>Asterisk CLI<ul><li>开发使用简单方便</li><li>功能有一定限制</li></ul></li><li>Call File<ul><li>0 耦合</li><li>从目录拉取呼叫请求 <code>&lt;astspooldir&gt;/outgoing</code> - <code>/var/spool/asterisk/outgoing/</code><ul><li>类似打印机 pool</li><li>适用于自动发起呼叫</li></ul></li><li>生成文件放到目录由 chan_pickup 去获取然后发起呼叫</li><li>语法与 HTTP Header 相同，支持 <code>#</code> 和 <code>;</code> 作为注释</li><li>注意 ⚠️ - 先创建好文件然后 移动 到目录，避免在目录直接创建</li></ul></li><li>CDR - 呼叫记录<ul><li>每一通呼叫可以记录到 DB</li><li>可通过查询 cdr 实现呼叫记录功能</li><li>开发使用非常方便</li><li>避免自行记录</li></ul></li><li>CEL - 事件日志<ul><li>日志量取决于配置，可能非常多</li><li>通过处理日志能够分析出当前的通道状态</li><li>实时处理日志能实现用户通知和提醒</li><li>避免操作 AMI 或 ARI</li></ul></li><li>SNMP<ul><li>基本服务监控</li></ul></li><li>Statd<ul><li>服务指标监控</li><li>通话数量，坐席数量</li></ul></li><li>Realtime DB<ul><li>管理通道坐席</li><li>模块配置</li></ul></li><li>Function_CURL<ul><li>Dialplan 里使用 CURL 请求外部系统</li><li>实现非常简单的系统集成</li></ul></li><li>后端接口<ul><li>LDAP</li><li>cURL</li><li>ODBC, SQLite, PostgreSQL, MySQL</li></ul></li></ul><pre><code class="language-bash"># 使用 CLI 发起呼叫
asterisk -rx &#x27;channel originate SIP/6003 extension 10086@sip-6003&#x27;
</code></pre><p><strong>/var/spool/asterisk/outgoing/hello.call</strong></p><pre><code class="language-ini">Channel: SIP/trunkname/6001
; Callerid: &lt;callerid&gt;
; WaitTime: &lt;number&gt;
; MaxRetries: &lt;number&gt;
; RetryTime: &lt;number&gt;
; Account: &lt;account&gt;

; 执行的应用和参数
Application: Playback
Data: hello-world

; Context+Extension
; Context: &lt;context&gt;
; Extension: &lt;exten&gt;
; Priority: &lt;priority&gt;
; Setvar: &lt;var=value&gt;

; yes 会归档到 outgoing_done
; 归档后还会记录状态
; Archive: &lt;yes|no&gt;
; Status: &lt;exitstatus&gt;

; 重试状态
; StartRetry: &lt;pid&gt; &lt;retrycount&gt; (&lt;time&gt;)
; EndRetry: &lt;pid&gt; &lt;retrycount&gt; (&lt;time&gt;)
</code></pre><h2>总结</h2><ul><li>使用 Stasis 替代 Dial</li><li>避免 Asterisk 包含复杂路由逻辑</li><li>通过 ARI 接耦</li><li>没有 ARI 的低版本 Asterisk 只能使用 AMI 来进行实时管理</li></ul><h2>参考</h2><ul><li><a href="https://www.slideshare.net/JranVinzens/ari-and-agi-a-powerful-combination">ARI and AGI, a powerful combination</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[macOS 微信备份原理]]></title>
            <link>https://wener.me/story/macos-wechat-backup</link>
            <guid>macos-wechat-backup</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[iPhone7 32G 用了几年后，微信占了 10G，如果能把微信备份后清除，还能再战两年！]]></description>
            <content:encoded><![CDATA[<p>iPhone7 32G 用了几年后，微信占了 10G，如果能把微信备份后清除，还能再战两年！</p><ul><li>微信自身支持备份，但备份后是加密的，无法访问。</li><li>微信占用空间的主要是图片和视频</li><li>微信清理不会清除文本<ul><li>文本消息相对少</li><li>想要清除文本消息可以卸载重装</li></ul></li></ul><ul><li>通过 macOS 备份 iPhone 系统 - 备份时不要加密<ul><li>备份后位于 <code>$HOME/Library/Application Support/MobileSync/Backup/</code></li></ul></li><li>备份后的数据<ul><li>Manifest.{mbdb,db} - mac 备份文件清单<ul><li>Files - 文件清单<ul><li><code>fileID TEXT PRIMARY KEY, domain TEXT, relativePath TEXT, flags INTEGER, file BLOB</code><ul><li>fileID - 为 备份映射后的文件</li><li>domain - 应用</li><li>relativePath - 应用相对路径</li></ul></li><li><code>select relativePath from Files where domain = &#x27;AppDomain-com.tencent.xin&#x27; limit 10</code>;<ul><li>微信相关文件</li></ul></li></ul></li><li>Properties<ul><li><code>key TEXT PRIMARY KEY, value BLOB</code></li></ul></li><li>.mbdb - 二进制文件，需要自定义解码逻辑</li><li>.db - sqlite3 - 新版一般是 sqlite3</li></ul></li></ul></li></ul><pre><code class="language-bash"># 打开 Manifest.db
sqlite3 Manifest.db
</code></pre><pre><code class="language-sql" metastring="title=&quot;常用操作&quot;" title="&quot;常用操作&quot;">-- 查看表
.tables
.tables Chat_%
-- 查看表结构
.schema Chat_ID
</code></pre><pre><code class="language-sql">-- 关心的文件
select fileID,relativePath from Files
where domain = &#x27;AppDomain-com.tencent.xin&#x27; and
(
  relativePath like &#x27;%/MM.sqlite&#x27;
  or relativePath like &#x27;%/WCDB_Contact.sqlite&#x27;
  or relativePath like &#x27;%/message_%.sqlite&#x27;
);

-- 所有 DB 目录下内容
select fileID,relativePath from Files
where domain = &#x27;AppDomain-com.tencent.xin&#x27; and relativePath like &#x27;Documents/%/DB/%&#x27;;

-- 文件数量
select count(*) from Files
where domain = &#x27;AppDomain-com.tencent.xin&#x27;;
</code></pre><ul><li>备份后包含微信数据<ul><li><code>message_%d.sqlite</code> - 聊天对话<ul><li>ChatExt2_ID</li><li>Chat_ID - 对应一个聊天会话<ul><li>ID 为 userName 或 MD5 的 alias</li></ul></li><li>Hello_ID</li></ul></li><li>WCDB_Contact.sqlite - 联系人<ul><li>Friend - 好友</li><li>MassSendContact</li><li>QQContact - QQ 联系人</li></ul></li><li>MM - 消息<ul><li>BottleContactTable4</li><li>BottleTable4</li><li>ChatExt2_ID</li><li>Chat_ID</li><li>Emoticon1</li><li>EmoticonPackage05</li><li>EmoticonUpload_1</li><li>Friend</li><li>Friend_Ext</li><li>MassSendContactTable</li><li>MessageBizExtTable</li><li>QQContact</li><li>RevokeMsgTable</li><li>friend_meta</li></ul></li><li>contactlabel.list - 标签列表</li></ul></li></ul><h2>Friend</h2><table><thead><tr><th>column</th><th>type</th><th>desc</th></tr></thead><tbody><tr><td>userName</td><td>text</td><td>WXID、群 ID、公众号 ID</td></tr><tr><td>type</td><td>integer</td><td>类型</td></tr><tr><td>certificationFlag</td><td>integer</td><td></td></tr><tr><td>imgStatus</td><td>integer</td><td></td></tr><tr><td>encodeUserName</td><td>text</td><td></td></tr><tr><td>dbContactLocal</td><td>blob</td><td></td></tr><tr><td>dbContactOther</td><td>blob</td><td></td></tr><tr><td>dbContactRemark</td><td>blob</td><td>联系人备注</td></tr><tr><td>dbContactHeadImage</td><td>blob</td><td>联系人头像</td></tr><tr><td>dbContactProfile</td><td>blob</td><td></td></tr><tr><td>dbContactSocial</td><td>blob</td><td></td></tr><tr><td>dbContactChatRoom</td><td>blob</td><td>群信息,XML</td></tr><tr><td>dbContactBrand</td><td>blob</td><td></td></tr><tr><td>_<!-- -->packed_DBContactTable</td><td>blob</td><td></td></tr></tbody></table><table><thead><tr><th>userName</th><th>desc</th></tr></thead><tbody><tr><td>100000000@chatroom</td><td>群组会话</td></tr><tr><td><code>wxid_</code></td><td>标准微信 ID</td></tr><tr><td>QQ1000000000</td><td></td></tr><tr><td>gh_123456789abc</td><td>公众号</td></tr></tbody></table><table><thead><tr><th>encodeUserName</th><th>desc</th></tr></thead><tbody><tr><td>v1_xxxx@stranger</td><td>加密后陌生人姓名</td></tr><tr><td>v3_xxxx@stranger</td><td>加密后陌生人姓名</td></tr></tbody></table><table><thead><tr><th>type</th><th align="right">bin</th><th>desc</th></tr></thead><tbody><tr><td>0</td><td align="right">0</td><td>微信运动</td></tr><tr><td>1</td><td align="right">1</td><td>微信应用</td></tr><tr><td>2</td><td align="right">10</td><td>app + 群</td></tr><tr><td>3</td><td align="right">11</td><td>好友</td></tr><tr><td>4</td><td align="right">100</td><td>群里面的人</td></tr><tr><td>6</td><td align="right">110</td><td>群好友，对方加你，你未通过</td></tr><tr><td>7</td><td align="right">111</td><td>群里面的人，而且互为好友</td></tr><tr><td>11</td><td align="right">1011</td><td>拉黑别人</td></tr><tr><td>67</td><td align="right">1000011</td><td>标星</td></tr><tr><td>256</td><td align="right">100000000</td><td>删除好友</td></tr><tr><td>259</td><td align="right">100000011</td><td>不让他看我的朋友圈</td></tr><tr><td>65539</td><td align="right">10000000000000011</td><td>不看他的朋友圈</td></tr></tbody></table><table><thead><tr><th>bit</th><th>desc</th></tr></thead><tbody><tr><td>1</td><td>你是否加对方为好友</td></tr><tr><td>2</td><td>对方是否加你为好友</td></tr><tr><td>3</td><td>是否群里面的</td></tr><tr><td>4</td><td>你主动拉黑对方</td></tr><tr><td>7</td><td>标星</td></tr></tbody></table><h2>Chat</h2><ul><li>Chat<!-- -->_<!-- --> 聊天信息</li><li>ChatExt<!-- -->_<!-- --> 消息扩展信息</li></ul><table><thead><tr><th>column</th><th>type</th><th>desc</th></tr></thead><tbody><tr><td>CreateTime</td><td>INTEGER</td><td></td></tr><tr><td>Des</td><td>INTEGER</td><td></td></tr><tr><td>ImgStatus</td><td>INTEGER</td><td></td></tr><tr><td>MesLocalID</td><td>INTEGER</td><td></td></tr><tr><td>Message</td><td>TEXT</td><td>消息内容</td></tr><tr><td>MesSvrID</td><td>INTEGER</td><td></td></tr><tr><td>Status</td><td>INTEGER</td><td></td></tr><tr><td>TableVer</td><td>INTEGER</td><td></td></tr><tr><td>Type</td><td>INTEGER</td><td>消息类型</td></tr></tbody></table><table><thead><tr><th>type</th><th>desc</th></tr></thead><tbody><tr><td>1</td><td>文本</td></tr><tr><td>3</td><td>图片</td></tr><tr><td>34</td><td>语音</td></tr><tr><td>42</td><td>名片</td></tr><tr><td>43</td><td>视频</td></tr><tr><td>47</td><td>表情</td></tr><tr><td>48</td><td>位置</td></tr><tr><td>49</td><td>链接</td></tr><tr><td>50</td><td>视频/语音通话</td></tr><tr><td>62</td><td>小视频</td></tr><tr><td>10000</td><td>系统消息</td></tr></tbody></table><h1>附录</h1><h2>WCDB_Contact.sqlite</h2><pre><code class="language-sql">-- WCDB_Contact
CREATE TABLE Friend
(
    userName               text primary key on conflict replace,
    type                   integer default 0,
    certificationFlag      integer default 0,
    imgStatus              integer default 0,
    encodeUserName         text,
    dbContactLocal         blob,
    dbContactOther         blob,
    dbContactRemark        blob,
    dbContactHeadImage     blob,
    dbContactProfile       blob,
    dbContactSocial        blob,
    dbContactChatRoom      blob,
    dbContactBrand         blob,
    _packed_DBContactTable blob
);
CREATE TABLE MassSendContact
(
    UsrName    text not null primary key on conflict replace,
    Detail     text,
    ConIntRes1 integer default 0,
    ConIntRes2 integer default 0,
    ConStrRes1 text,
    ConStrRes2 text
);
CREATE TABLE QQContact
(
    UsrName           text not null primary key on conflict replace,
    Uin               integer default 0,
    Type              integer default 0,
    Sex               integer default 0,
    Age               integer default 0,
    ImgKey            integer default 0,
    ExtKey            integer default 0,
    ImgKeyLast        integer default 0,
    ExtKeyLast        integer default 0,
    CreateTime        integer default 0,
    ConIntRes1        integer default 0,
    ConIntRes2        integer default 0,
    ConIntRes3        integer default 0,
    NickName          text,
    Email             text,
    Mobile            text,
    Address           text,
    Sign              text,
    birthday          text,
    FullPY            text,
    ShortPY           text,
    Img               text,
    ConRemark         text,
    ConRemark_PYShort text,
    ConRemark_PYFull  text,
    ConStrRes1        text,
    ConStrRes2        text,
    ConStrRes3        text
);
</code></pre><h2>MM.sqlite</h2><pre><code class="language-sql">CREATE TABLE Friend
(
    TableVer     integer default 1,
    UsrName      text not null primary key on conflict replace,
    NickName     text,
    Uin          integer default 0,
    Email        text,
    Mobile       text,
    Sex          integer default 0,
    FullPY       text,
    ShortPY      blob,
    Img          text,
    Type         integer default 0,
    LastChatTime integer default 0,
    Draft        text
);
CREATE TABLE Friend_Ext
(
    UsrName           text not null primary key on conflict replace,
    ConType           integer default 0,
    ConRemark         text,
    ConRemark_PYShort text,
    ConRemark_PYFull  text,
    ConQQMBlog        text,
    ConSMBlog         text,
    ConChatRoomMem    text,
    ConIntRes1        integer default 0,
    ConIntRes2        integer default 0,
    ConIntRes3        integer default 0,
    ConStrRes1        text,
    ConStrRes2        text,
    ConStrRes3        text
);
CREATE TABLE friend_meta
(
    username   text primary key on conflict replace,
    lastUpdate integer,
    intCon1    integer,
    intCon2    integer,
    intCon3    integer,
    strCon1    text,
    strCon2    text,
    strCon3    text
);
CREATE TABLE QQContact
(
    UsrName           text not null primary key on conflict replace,
    Uin               integer default 0,
    Type              integer default 0,
    Sex               integer default 0,
    Age               integer default 0,
    ImgKey            integer default 0,
    ExtKey            integer default 0,
    ImgKeyLast        integer default 0,
    ExtKeyLast        integer default 0,
    CreateTime        integer default 0,
    ConIntRes1        integer default 0,
    ConIntRes2        integer default 0,
    ConIntRes3        integer default 0,
    NickName          text,
    Email             text,
    Mobile            text,
    Address           text,
    Sign              text,
    birthday          text,
    FullPY            text,
    ShortPY           text,
    Img               text,
    ConRemark         text,
    ConRemark_PYShort text,
    ConRemark_PYFull  text,
    ConStrRes1        text,
    ConStrRes2        text,
    ConStrRes3        text
);
CREATE TABLE RevokeMsgTable
(
    MSG_REVOKE_COL_SVRID   bigint  default 0 primary key,
    MSG_REVOKE_COL_CONTENT text,
    MSG_REVOKE_COL_INTRES1 integer default 0,
    MSG_REVOKE_COL_INTRES2 bigint  default 0,
    MSG_REVOKE_COL_INTRES3 bigint  default 0,
    MSG_REVOKE_COL_STRRES1 text,
    MSG_REVOKE_COL_STRRES2 text,
    MSG_REVOKE_COL_STRRES3 text,
    _packed_RevokeMessage  blob
);
CREATE TABLE Emoticon1
(
    MD5        text,
    Message    text,
    Type       integer default 0,
    CreateTime integer default 0,
    Len        integer default 0,
    Status     integer default 0,
    Catalog    text,
    CatelogID  integer default 0,
    Draft      text,
    ConIntRes1 integer default 0,
    ConIntRes2 integer default 0,
    ConIntRes3 integer default 0,
    ConStrRes1 text,
    ConStrRes2 text,
    ConStrRes3 text
);
CREATE TABLE EmoticonUpload_1
(
    UsrName    text,
    MesLocalID text,
    MD5        text,
    Type       integer default 0,
    Message    text,
    CreateTime integer default 0,
    SendTime   integer default 0,
    Offset     integer default 0,
    Len        integer default 0,
    Status     integer default 0,
    Catalog    text,
    CatelogID  integer default 0,
    Draft      text,
    ConIntRes1 integer default 0,
    ConIntRes2 integer default 0,
    ConIntRes3 integer default 0,
    ConStrRes1 text,
    ConStrRes2 text,
    ConStrRes3 text
);
CREATE TABLE BottleTable4
(
    BottleLocalID        integer primary key autoincrement,
    BottleSvrID          integer default 0,
    BottleEncryptUsrName text,
    BottleID             text,
    BottleExt            text
);
CREATE TABLE BottleContactTable4
(
    BottleContactUsrName     text not null primary key on conflict replace,
    BottleContactNickName    text,
    BottleContactSex         integer default 0,
    BottleContactImgStatus   text,
    BottleContactHDImgStatus text,
    BottleContactProvince    text,
    BottleContactCity        text,
    BottleContactSign        text,
    BottleContactImgKey      integer default 0,
    BottleContactImgKeyLast  integer default 0,
    BottleContactExtKey      integer default 0,
    BottleContactExtKeyLast  integer default 0,
    BottleContactINTRES1     integer default 0,
    BottleContactINTRES2     integer default 0,
    BottleContactINTRES3     integer default 0,
    BottleContactTEXTRES1    text,
    BottleContactTEXTRES2    text,
    BottleContactTEXTRES3    text
);
CREATE TABLE MassSendContactTable
(
    UsrName    text not null primary key on conflict replace,
    Detail     text,
    ConIntRes1 integer default 0,
    ConIntRes2 integer default 0,
    ConStrRes1 text,
    ConStrRes2 text
);
CREATE TABLE MessageBizExtTable
(
    chatUsername            text,
    msgLocalId              integer,
    msgType                 integer,
    msgInnerType            integer,
    bizId                   text,
    msgExtColInt1           integer,
    msgExtColInt2           integer,
    msgExtColString1        text,
    msgExtColString2        text,
    _packed_DBMessageBizExt blob
);
CREATE TABLE EmoticonPackage05
(
    EmoticonPackageId          text not null primary key on conflict replace,
    EmoticonPackageName        text,
    EmoticonPackageIconUrl     text,
    EmoticonPackagePannelUrl   text,
    EmoticonPackagePStatus     integer default 0,
    EmoticonPackageDLStatus    integer default 0,
    EmoticonPackageInstallTime integer default 0,
    EmoticonPackageRemoveTime  integer default 0,
    ConIntRes1                 integer default 0,
    ConIntRes2                 integer default 0,
    ConIntRes3                 integer default 0,
    ConStrRes1                 text,
    ConStrRes2                 text,
    ConStrRes3                 text
);
CREATE TABLE Chat
(
    TableVer   integer default 1,
    MesLocalID integer primary key autoincrement,
    MesSvrID   bigint  default 0,
    CreateTime integer default 0,
    Message    text,
    Status     integer default 0,
    ImgStatus  integer default 0,
    Type       integer,
    Des        integer
);
CREATE TABLE ChatExt2
(
    MesLocalID  integer primary key,
    msgFlag     integer default 0,
    ConIntRes2  integer default 0,
    ConIntRes3  integer default 0,
    MsgSource   text,
    MsgIdentify text,
    ConStrRes1  text,
    ConStrRes2  text,
    ConStrRes3  text,
    ConIntRes1  integer default 0
);
</code></pre><h2><code>message_%d.sqlite</code></h2><pre><code class="language-sql">CREATE TABLE Chat_ID
(
    CreateTime INTEGER DEFAULT 0,
    Des        INTEGER,
    ImgStatus  INTEGER DEFAULT 0,
    MesLocalID INTEGER PRIMARY KEY AUTOINCREMENT,
    Message    TEXT,
    MesSvrID   INTEGER DEFAULT 0,
    Status     INTEGER DEFAULT 0,
    TableVer   INTEGER DEFAULT 1,
    Type       INTEGER
);
CREATE TABLE ChatExt2_ID
(
    ConIntRes1  INTEGER DEFAULT 0,
    ConIntRes2  INTEGER DEFAULT 0,
    ConIntRes3  INTEGER DEFAULT 0,
    ConStrRes1  TEXT,
    ConStrRes2  TEXT,
    ConStrRes3  TEXT,
    MesLocalID  INTEGER PRIMARY KEY,
    msgFlag     INTEGER DEFAULT 0,
    MsgIdentify TEXT,
    MsgSource   TEXT
);
CREATE TABLE Hello_ID
(
    ConIntRes1 INTEGER DEFAULT 0,
    ConIntRes2 INTEGER DEFAULT 0,
    ConIntRes3 INTEGER DEFAULT 0,
    ConStrRes1 TEXT,
    ConStrRes2 TEXT,
    ConStrRes3 TEXT,
    CreateTime INTEGER DEFAULT 0,
    Des        INTEGER,
    ImgStatus  INTEGER DEFAULT 0,
    MesLocalID INTEGER PRIMARY KEY AUTOINCREMENT,
    Message    TEXT,
    MesSvrID   INTEGER DEFAULT 0,
    OpCode     INTEGER DEFAULT 0,
    Status     INTEGER DEFAULT 0,
    TableVer   INTEGER DEFAULT 1,
    Type       INTEGER,
    UsrName    TEXT
);
</code></pre><h1>参考</h1><ul><li><a href="https://www.jianshu.com/p/07a8d87e698b">https://www.jianshu.com/p/07a8d87e698b</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[我的站点是如何构建的？！]]></title>
            <link>https://wener.me/story/how-i-build-my-site</link>
            <guid>how-i-build-my-site</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[我的站点 wener.me 和国内备案镜像 wener.tech 构建过程和逻辑。]]></description>
            <content:encoded><![CDATA[<p>我的站点 <a href="https://wener.me">wener.me</a> 和国内备案镜像 <a href="https://wener.tech">wener.tech</a> 构建过程和逻辑。</p><h2>Docusaurus</h2><p>站点基于 <a href="https://docusaurus.io/">docusaurus</a> 2.0-alpha 构建，docusaurus 处于 2.0-alpha 已经很长一段时间了，最近进入了 beta 阶段。早期对中文支持有缺陷，提交几个修复后都能正常使用了。</p><p>docusaurus 有 blog 和 doc 的概念。
docusaurus 本身是 facebook 为了支持技术文档存在的，因此对 doc 的支持非常好，doc 主要特性</p><ul><li>多版本</li><li>多语言</li><li>集成 algolia 搜索</li><li>自定义插件</li><li>mdx</li><li>支持替换内置 组件</li></ul><p>doc 默认目录为 /docs，可自定义。</p><p>blog 为单篇文章，默认目录为 /blog，支持自定义 slug，默认 slug 为泛化后的文件名。</p><pre><code class="language-bash"># 新项目初始化
npx @docusaurus/init@latest init my-website classic
</code></pre><h2>构建</h2><p>归根结底，docusaurus 是一个 npm 库，因此实现自定义需要基于一个 node 项目。
站点的构建项目位于 <a href="https://github.com/wenerme/wener/tree/master/site">site</a> 目录下，构建过程为</p><ul><li>同步 /story 到 /site/story</li><li>同步 /notes 到 /site/notes</li></ul><p>:::tip</p><p>同步过程会过滤部分 md 文件，docusaurus 默认会处理所有 md 文件，但是 wenerme/wener 中的部分 md 文件是不希望被构建的。
因此我的过滤逻辑是只包含文件开头有 frontmatter 的，也就是文件开头为 <code>---</code>。</p><p>:::</p><ul><li>预处理 markdown<ul><li>例如 引用外部 markdown <a href="https://raw.githubusercontent.com/wenerme/wener/master/story/project/bbvm.md">story/project/bbvm.md</a></li></ul></li><li>自定义脚本生成 sidebar<ul><li>docusaurus 的 sidebar 需要手动书写，但文档过多且每次新增后都需要添加，因此实现了脚本自动扫描</li><li><a href="https://github.com/wenerme/wener/blob/f34b8624b8cc55e539af282d275d4805650aee41/site/sidebars.js#L48-L65">site/sidebars.js#L48-L65</a></li></ul></li><li>站点构建<ul><li>构建后会生成到 /build 目录</li></ul></li></ul><h2>自动化部署</h2><p>站点基于 github <a href="https://github.com/wenerme/wener/blob/master/.github/workflows/build.yaml">action</a> 进行构建，每次推送后会进行构建，会将构建的内容推送到 <a href="https://github.com/wenerme/wener/deployments">gh-pages</a> 分支。
推送的内容同时包含了 CNAME，实现了 wener.me 域名的映射。</p><p>完成 wener.me 推送后修改 CNAME 为 wener.tech 推送到 <a href="https://github.com/wenerme/wener.tech">wenerme/wener.tech</a>，实现 wener.tech 域名的映射。</p><h2>域名配置</h2><p>.me 域名在国内无法备案，因此直接托管在了 <a href="https://cloudflare.com">cloudflare.com</a>，添加两个记录</p><pre><code>A wener.me 185.199.109.153
A wener.me 185.199.108.153
</code></pre><p>至此 wener.me 可以被访问。</p><p>因为 cloudflare 在国内访问速度较慢，且 .me 无法备案的原因，因此镜像了 wener.tech。</p><p>:::caution</p><p>微信会拦截所有没有备案的域名，提示用户是否前往，非常影响体验。</p><p>:::</p><p>wener.tech 使用阿里云 dcdn/全站加速 实现，添加域名 <a href="http://www.wener.tech">www.wener.tech</a> ，指向 185.199.108.153 和 185.199.109.153。
添加完成后前往域名解析，将 <a href="http://www.wener.tech">www.wener.tech</a> CNAME 到 <a href="http://www.wener.tech.w.kunluncan.com">www.wener.tech.w.kunluncan.com</a> 。完成后建议开启 https。</p><p>至此 <a href="http://www.wener.tech">www.wener.tech</a> 可以被访问。</p><p>:::caution dcdn 的 坑</p><ul><li>阿里的 dcdn 实现和 cloudflare 类似的功能，但体验差很多</li><li>dcdn 通过 CNAME 实现，主域名 wener.tech 无法进行 CNAME，因此只能使用 <a href="http://www.wener.tech">www.wener.tech</a></li><li>访问 wener.tech 会发现左侧侧边栏卡顿，应该是 dcdn 的“优化”导致的<ul><li>wener.me 没有这个问题</li></ul></li></ul><p>:::</p><h2>总结</h2><p>基于 github action + cloudflare 可以很容易实现“免费”的静态站点托管。
如果需要动态能力，可以配合 <a href="https://github.com/vercel/next.js">next.js</a>+<a href="https://vercel.com/">vercel</a> 实现。例如 <a href="https://apis.wener.me">apis.wener.me</a>。</p><p>cloudflare 看似没起什么作用，但是却是必须的，因为默认 github pages 和 vercel 在国内都无法访问，或访问都是间歇性能通，使用 cloudflare 虽然速度偏慢，但至少都能访问。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[日常工作之外]]></title>
            <link>https://wener.me/story/out-of-daily-work</link>
            <guid>out-of-daily-work</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[工作是永远也做不完的，但在这条走不完的路上也要多看看沿途的风景。]]></description>
            <content:encoded><![CDATA[<blockquote><p>工作是永远也做不完的，但在这条走不完的路上也要多看看沿途的风景。</p></blockquote><p><strong>发现和观察</strong></p><ul><li>检查邮件<ul><li>News</li><li>Mail list</li></ul></li><li>浏览 HN</li><li>浏览 Reddit</li><li>浏览 Twitter</li><li>浏览 IRC - 看有什么值得注意的</li><li>浏览 Telegram 看看有趣的事情</li><li>过掉微信未读消息</li><li>检查 Github<ul><li>关注问题是否有所变化和进展</li><li>关注项目是否有新版本<ul><li>更新 AlpineLinux 包</li></ul></li></ul></li></ul><p>Back to work.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[K3S vs K0S]]></title>
            <link>https://wener.me/story/k3s-vs-k0s</link>
            <guid>k3s-vs-k0s</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[| vs.               | k0s                               | k3s                                   |]]></description>
            <content:encoded><![CDATA[<table><thead><tr><th>vs.</th><th>k0s</th><th>k3s</th></tr></thead><tbody><tr><td>since</td><td>2020-06</td><td>2019-03</td></tr><tr><td>by</td><td>Mirants</td><td>Rancher/SUSE</td></tr><tr><td>Governance</td><td>Mirants</td><td>CNCF</td></tr><tr><td>Github</td><td><a href="https://github.com/k0sproject/k0s">k0sproject/k0s</a></td><td><a href="https://github.com/k3s-io/k3s">k3s-io/k3s</a></td></tr><tr><td>Stars</td><td><a href="https://github.com/k0sproject/k0s"><img src="https://img.shields.io/github/stars/k0sproject/k0s"/></a></td><td><a href="https://github.com/k3s-io/k3s"><img src="https://img.shields.io/github/stars/k3s-io/k3s"/></a></td></tr><tr><td>Issues</td><td><a href="https://github.com/k0sproject/k0s"><img src="https://img.shields.io/github/issues/k0sproject/k0s"/></a></td><td><a href="https://github.com/k3s-io/k3s"><img src="https://img.shields.io/github/issues/k3s-io/k3s"/></a></td></tr><tr><td>CNI</td><td>kube-router,calico</td><td>flannel</td></tr><tr><td>CRI</td><td>containerd</td><td>containerd</td></tr><tr><td>CSI</td><td>OpenEBS</td><td>local-path-provisioner</td></tr><tr><td>Windows</td><td>✅ - calico</td><td>❌</td></tr><tr><td>Arch</td><td>amd64,arm,arm64</td><td>amd64,arm,arm64</td></tr><tr><td>LoadBalancer</td><td>n/a</td><td>klipper-lb</td></tr><tr><td>Ingress</td><td>n/a</td><td>traefik</td></tr><tr><td>Controller-Worker</td><td><a href="https://kubernetes.io/docs/tasks/extend-kubernetes/setup-konnectivity/">konnectivity</a></td><td><a href="https://github.com/rancher/remotedialer">remotedialer</a> - WebSocket 反向代理</td></tr><tr><td>文档</td><td>⭐️⭐️</td><td>⭐️⭐️</td></tr><tr><td>成熟</td><td>⭐️⭐️</td><td>⭐️⭐️⭐️</td></tr><tr><td>Pod CIDR</td><td>10.244.0.0/16</td><td>10.42.0.0/16</td></tr><tr><td>Service CIDR</td><td>10.96.0.0/12</td><td>10.43.0.0/16</td></tr><tr><td>CoreDNS</td><td>10.96.0.10</td><td>10.43.0.10</td></tr><tr><td>configuration</td><td>/etc/k0s/k0s.yaml</td><td>/etc/rancher/k3s/config.yaml</td></tr><tr><td>registry</td><td>/etc/k0s/k0s.yaml</td><td>/etc/rancher/k3s/registry.yaml</td></tr><tr><td>data-dir</td><td>/var/lib/k0s</td><td>/var/lib/rancher/k3s</td></tr><tr><td>kubeconfig</td><td>/var/lib/k0s/pki/admin.conf</td><td>/etc/rancher/k3s/k3s.yaml</td></tr><tr><td>manifest</td><td>/var/lib/k0s/manifests</td><td>/var/lib/rancher/k3s/server/manifests</td></tr><tr><td>local storage</td><td>/var/openebs/local</td><td>/var/lib/rancher/k3s/storage/</td></tr></tbody></table><ul><li><a href="https://wener.me/notes/devops/kubernetes/distro/k0s">k0s</a><ul><li>CIS security benchmark</li><li>符合 FIPS 140-2 要求</li><li>bundled<ul><li>openebs<ul><li>openebs-hostpath -&gt; /var/openebs/local</li></ul></li><li>kube-router</li></ul></li></ul></li><li><a href="https://wener.me/notes/devops/kubernetes/distro/k3s">k3s</a><ul><li>CNCF 项目 - 脱离了 rancher</li><li>bundled<ul><li>helm-controller - 支持部署 helm chart, CDR 控制</li><li>traefik - 提供 ingress 能力 - 通过 helm 部署</li><li>local-path-provisioner - 提供基于本地目录的存储类<ul><li>默认 /var/lib/rancher/k3s/storage</li></ul></li><li>klipper-lb - 基于 iptable 转发的负载均衡</li></ul></li></ul></li></ul><p>:::caution</p><ul><li>k3s 默认包含较多组件，部署后 可使用性 更高，但部分组件（ traefik,klipper-lb,local-path-provisioner ）不建议生产使用，提供这些组件更多是为了保证功能完整，开箱即用。</li><li>使用 k3s 不推荐使用内置 traefik 和 klipper-lb<ul><li>ingress 建议自行安装 - 比较重要的核心组件</li><li>建议使用 metallb 替代 klipper-lb</li></ul></li><li>因为 Controller-Worker 网络不同，k3s 和 k0s 无法混合使用</li></ul><p>:::</p><p><strong>命令对比</strong></p><table><thead><tr><th>k0s</th><th>k3s</th></tr></thead><tbody><tr><td>k0s systinfo</td><td>./contrib/util/check-config.sh</td></tr><tr><td>k0s backup</td><td>k3s etcd-snapshot</td></tr><tr><td>k0s restore</td><td>k3s server --cluster-reset-restore-path</td></tr><tr><td>k0s controller</td><td>k3s server</td></tr><tr><td>k0s worker</td><td>k3s agent</td></tr><tr><td>n/a</td><td>k3s crictl</td></tr><tr><td>k0s install</td><td><a href="https://get.k3s.io">https://get.k3s.io</a> 会安装 systemd, openrc 服务</td></tr><tr><td>k0s reset</td><td>n/a</td></tr><tr><td>k0s kubeconfig create</td><td>n/a</td></tr><tr><td>k0sctl</td><td>n/a</td></tr><tr><td>k0sctl apply</td><td>~autok3s</td></tr><tr><td>k0sctl backup</td><td>n/a</td></tr><tr><td>---</td><td>---</td></tr><tr><td>k0s kubectl</td><td>k3s kubectl</td></tr><tr><td>k0s ctr</td><td>k3s ctr</td></tr></tbody></table><h2>如何选择</h2><p><strong>相同点</strong></p><ul><li>面向相同用户群体和使用场景，非常类似</li><li>核心都使用 kine - 区别不大</li><li>都有大的企业支撑开发</li></ul><p><strong>选择考量</strong></p><ul><li>k3s<ul><li>更成熟 - 存在时间更长，使用的更独立</li><li>社区更大 - 社区还与 rancher、rke 有交集</li><li>中文化社区友好</li></ul></li><li>k0s<ul><li>更新 - 2020 年 - 目前已经成熟，可以用于生产</li><li>用户体验更好</li><li><strong>k0sctl</strong><ul><li>能更好的辅助维护更多的集群，减少对 脚本/ansible 的依赖。</li><li>更好升级</li><li>更好备份</li></ul></li></ul></li></ul><h2>组件简介</h2><ul><li><a href="https://wener.me/notes/devops/kubernetes/distro/kine">kine</a>
k3s 和 k0s 最核心组件<ul><li>提供 etcd 能力</li><li>后端支持 etcd,sqlite,mysql,postgresql,dqlite</li></ul></li><li><a href="https://wener.me/notes/devops/kubernetes/network/traefik-ingress">traefik</a><ul><li>提供 Ingress 能力</li></ul></li><li><a href="https://github.com/k3s-io/helm-controller">k3s-io/helm-controller</a><ul><li>支持部署 helm chart</li><li>通过 CDR 控制</li></ul></li><li>CNI - 容器网络<ul><li><a href="https://wener.me/notes/devops/kubernetes/network/flannel/">flannel</a></li><li><a href="https://wener.me/notes/devops/kubernetes/network/calico/">calico</a></li><li><a href="https://wener.me/notes/devops/kubernetes/network/kube-router/">kube-router</a></li></ul></li><li>CSI - 容器存储<ul><li><a href="https://wener.me/notes/devops/kubernetes/storage/local-path-provisioner/">local-path-provisioner</a><ul><li>基于本地路径提供 volume</li></ul></li><li><a href="https://wener.me/notes/devops/kubernetes/storage/openebs/">openebs</a></li></ul></li><li>LoadBalancer<ul><li><a href="https://github.com/k3s-io/klipper-lb">k3s-io/klipper-lb</a><ul><li>基于 iptable 提供 ClusterIP 能力</li></ul></li><li><a href="https://wener.me/notes/devops/kubernetes/network/metallb/">metallb</a></li></ul></li></ul><h2>参考</h2><ul><li><a href="https://landscape.cncf.io/card-mode?category=certified-kubernetes-installer&amp;grouping=category">certified-kubernetes-installer</a></li></ul><h1>为什么会存在不同发行版</h1><p>K8S 作为最原始的项目，派生出来很多 分支/发布版。</p><p>Kubernetes 的核心能力为资源调度，主要资源为 Pod/容器组/计算资源。
因为是分布式多节点，所以对网络有要求。Pod 调度主要提供计算能力，实际使用还会需要存储能力。
也就是说 Kubernetes 涉及到核心的三元素</p><ul><li>计算</li><li>网络</li><li>存储</li></ul><p>Kubernetes 核心调度计算资源，但对于网络和存储是 无意见/Unopinioned ，但实际部署使用时这时候又不可避免的要面对这些问题。
因此不同的 发布版/Distribution 就是对这些问题不同的看法。</p><h2>K8S 要求</h2><p>Kubernetes 由 Google 开发，但不是所有人都有那么大规模的问题，而大多数时候都是小规模，先让 K8S “跑起来”。</p><p>Kubernetes 自身因为对基础设施层 无意见/Unopinioned，因此默认是没有部署工具，只有要求：</p><ul><li>要求节点运行在平坦网络</li><li>要求 etcd 能力的状态存储</li><li>要求 cloud-controller 提供节点信息</li><li>要求 容器运行时</li></ul><p>在这些基础之上，Kubernetes 提供基于状态的 接口 进行资源调度。</p><h2>K8S 部署</h2><p>除了满足 K8S 的要求，在实际使用时还希望能方便快捷的管理部署。
K8S 提供了 kubeadm 进行安装，不同的发布版也需要提供类似的工具，但工具区分为两部分</p><ol><li>远程开通部署<ul><li>SSH</li><li>控制节点通过工具部署到多个节点</li></ul></li><li>开通部署的提前准备<ul><li>CA 证书</li><li>ETCD/存储初始化</li><li>网络设置</li><li>Bootstrap</li></ul></li></ol><p>kubeadm 和 k0s, k3s 都属于第二种场景，第一种场景的工具例如</p><ul><li>autok3s</li><li>rke</li><li>ansible</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[PostgreSQL ORDER BY+LIMIT 时的索引选择]]></title>
            <link>https://wener.me/story/postgresql-use-wrong-index-with-order-and-limit</link>
            <guid>postgresql-use-wrong-index-with-order-and-limit</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[当使用 ORDER BY+LIMIT 时 PostgreSQL 可能会选择更差的执行方式，数据量大时，执行效率相差成百上千倍。]]></description>
            <content:encoded><![CDATA[<p>当使用 ORDER BY+LIMIT 时 PostgreSQL 可能会选择更差的执行方式，数据量大时，执行效率相差成百上千倍。</p><h2>索引选择问题</h2><p>假设结构如下</p><pre><code class="language-sql">create table organizations(
  id bigserial primary key,
  jgmc text,
  clrq date
);

create index if not exists idx_organizations_clrq on ic.organizations (clrq);
create index if not exists idx_organizations_jgmc_fts on ic.organizations using pgroonga (jgmc);
</code></pre><p>查询通常基于 clrq 排序，但会 搜索 jgmc。</p><pre><code class="language-sql">explain analyse verbose
select jgmc, clrq, id
from ic.organizations
where jgmc &amp;@~ &#x27;百度&#x27;
  and clrq is not null
order by clrq desc
limit 30 offset 0
;
</code></pre><p>:::tip 使用了 clrq is not null 而非 nulls last</p><p>因为索引默认隐含 nulls last，也就是说 <code>order by clrq asc</code> 隐含 <code>order by clrq asc nulls last</code>。
当使用 <code>order by clrq desc nulls last</code> 时不会选择 <code>idx_organizations_clrq</code> 索引，因为 nulls 顺序不匹配。
因此使用 <code>is not null</code> 排除。</p><p>:::</p><p>给出的执行计划和结果如下</p><pre><code>Limit  (cost=0.43..33132.51 rows=30 width=1284) (actual time=4678.918..13104.109 rows=6 loops=1)
&quot;  Output: jgmc, clrq, id&quot;
  -&gt;  Index Scan Backward using idx_organizations_clrq on ic.organizations  (cost=0.43..4069724.46 rows=3685 width=1284) (actual time=4678.916..13104.101 rows=6 loops=1)
&quot;        Output: jgmc, clrq, id&quot;
        Index Cond: (organizations.clrq IS NOT NULL)
        Filter: (organizations.jgmc &amp;@~ &#x27;百度&#x27;::text)
        Rows Removed by Filter: 3685166
Planning Time: 0.826 ms
Execution Time: 13104.226 ms
</code></pre><p>实际执行了 13s，选择了 idx_organizations_clrq 索引。</p><p>但如果去掉 LIMIT：</p><pre><code class="language-sql">explain analyse verbose
select jgmc, clrq, id
from ic.organizations
where jgmc &amp;@~ &#x27;百度&#x27;
  and clrq is not null
order by clrq desc
-- limit 30 offset 0
;
</code></pre><p>给出的计划如下</p><pre><code>Sort  (cost=40479.53..40488.74 rows=3685 width=1284) (actual time=19.771..19.774 rows=6 loops=1)
&quot;  Output: jgmc, clrq, id&quot;
  Sort Key: organizations.clrq DESC
  Sort Method: quicksort  Memory: 36kB
  -&gt;  Index Scan using idx_organizations_jgmc_fts on ic.organizations  (cost=0.00..40261.24 rows=3685 width=1284) (actual time=19.716..19.737 rows=6 loops=1)
&quot;        Output: jgmc, clrq, id&quot;
        Index Cond: (organizations.jgmc &amp;@~ &#x27;百度&#x27;::text)
        Filter: (organizations.clrq IS NOT NULL)
Planning Time: 0.706 ms
Execution Time: 21.824 ms
</code></pre><p>实际执行只需要 21ms，选择了 idx_organizations_jgmc_fts 索引。</p><p>PostgreSQL 在这样的场景下选择了错误的索引，导致查询时间相差 600 倍。</p><h2>索引选择原因</h2><p>ORDER BY+LIMIT 让查询有 <strong>提前结束的可能</strong>。</p><p>例如 实际数据 10k,但 limit 10, 只需使用索引扫描 10 条数据便可以停止执行，而不需要先判断 其他 条件。</p><p>因此 PostgreSQL 的 optimizer 有让这种选择优先的逻辑 <a href="https://github.com/postgres/postgres/blob/REL_13_STABLE/src/backend/optimizer/util/pathnode.c#L3633-L3753">pathnode.c#L3633-L3753</a>。</p><ul><li>create_limit_path 针对 LIMIT/OFFSET 创建执行计划<ul><li>adjust_limit_rows_costs 调整此时的 rows costs</li></ul></li></ul><pre><code class="language-c" metastring="title=&quot;adjust_limit_rows_costs&quot;" title="&quot;adjust_limit_rows_costs&quot;">*total_cost = *startup_cost +
  (input_total_cost - input_startup_cost)
  * count_rows / input_rows;
</code></pre><table><thead><tr><th align="right">var</th><th>meaning</th></tr></thead><tbody><tr><td align="right">total_cost</td><td>总 cost</td></tr><tr><td align="right">startup_cost</td><td>初始 cost</td></tr><tr><td align="right">input_total_cost</td><td>输入总 cost</td></tr><tr><td align="right">input_startup_cost</td><td>输入初始总 cost</td></tr><tr><td align="right">count_rows</td><td>limit</td></tr><tr><td align="right">input_rows</td><td>输入 行</td></tr></tbody></table><p>在这个调整逻辑里会将现在的过程 cost <code>input_total_cost - input_startup_cost</code> 乘以 系数 <code>count_rows / input_rows</code>。
这个系数便会使得 ORDER BY+LIMIT 时优先选择索引。</p><p>因为两个计划的 rows 相同，优先了 排序索引则会选择排序索引方案。</p><h2>解决问题</h2><p>:::tip 目标</p><p>避免选择排序索引</p><p>:::</p><ol><li>使用 noop function 避免索引</li></ol><pre><code class="language-sql">explain verbose
select clrq, jgmc, id
from ic.organizations
where jgmc &amp;@~ &#x27;百度&#x27;
  and clrq is not null
order by coalesce(clrq) desc
limit 30 offset 0
;
</code></pre><ol start="2"><li>使用 expression 避免索引</li></ol><pre><code class="language-sql">explain verbose
select clrq, jgmc, id
from ic.organizations
where jgmc &amp;@~ &#x27;百度&#x27;
  and clrq is not null
order by clrq+0 desc
limit 30 offset 0
;
</code></pre><ol start="3"><li>添加 nulls 顺序避免索引</li></ol><ul><li>因为 index 默认 asc nulls last 因此 asc 和 desc 选择不同 nulls 顺序</li><li>where is not null</li><li>desc nulls last</li><li>asc nulls first</li></ul><pre><code class="language-sql">explain verbose
select clrq, jgmc, id
from ic.organizations
where jgmc &amp;@~ &#x27;百度&#x27;
  and clrq is not null
order by clrq desc nulls last
limit 30 offset 0
;
</code></pre><ol start="4"><li>调整 STATISTICS</li></ol><ul><li>在两者统计 rows 不同的情况下 - 这里不适用</li><li>SET STATISTICS</li><li>CREATE STATISTICS</li></ul><h2>STATISTICS 场景</h2><p>STATISTICS 影响 n_distinct，n_distinct 影响 inputs_rows，多个计划相同，可增加 STATISTICS 避免错误选择索引。</p><pre><code class="language-sql">SELECT attname,
       n_distinct,
       null_frac
FROM pg_stats
WHERE tablename = &#x27;organizations&#x27;
  and attname in (&#x27;clrq&#x27;, &#x27;jgmc&#x27;);
</code></pre><table><thead><tr><th align="left">attname</th><th align="left">n_distinct</th><th align="left">null_frac</th></tr></thead><tbody><tr><td align="left">clrq</td><td align="left">7914</td><td align="left">0.00030666665</td></tr><tr><td align="left">jgmc</td><td align="left">-0.99441195</td><td align="left">0.0030133333</td></tr></tbody></table><pre><code class="language-sql">SELECT relname, reltuples, relpages
FROM pg_class
WHERE relname LIKE &#x27;organizations&#x27;;
</code></pre><table><thead><tr><th align="left">relname</th><th align="left">reltuples</th><th align="left">relpages</th></tr></thead><tbody><tr><td align="left">organizations</td><td align="left">3686376</td><td align="left">1116103</td></tr></tbody></table><h2>参考</h2><ul><li><a href="https://gocardless.com/blog/debugging-the-postgres-query-planner/">https://gocardless.com/blog/debugging-the-postgres-query-planner/</a></li><li><a href="https://dba.stackexchange.com/a/258986/234272">https://dba.stackexchange.com/a/258986/234272</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[系统盘恢复]]></title>
            <link>https://wener.me/story/rescue-root-disk</link>
            <guid>rescue-root-disk</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[喜欢使用 闪存盘/U 盘 作为 Linux 系统盘，但 U 盘 使用寿命有限，当异常后需要对系统盘进行更换。]]></description>
            <content:encoded><![CDATA[<p>喜欢使用 闪存盘/U 盘 作为 Linux 系统盘，但 U 盘 使用寿命有限，当异常后需要对系统盘进行更换。</p><h2>现状</h2><p>使用 SanDisk CZ430 作为 系统盘/Root 分区</p><p><strong>lsblk</strong></p><pre><code>NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    1 114.6G  0 disk
├─sda1   8:1    1   128M  0 part /boot
└─sda2   8:2    1 114.4G  0 part /
</code></pre><p><strong>df -h /</strong></p><pre><code>Filesystem      Size  Used Avail Use% Mounted on
/dev/sda2       113G  2.2G  106G   2% /
</code></pre><p>在使用一段时间后， U 盘 异常，系统被重新挂载为只读。</p><pre><code class="language-bash">touch ~/test
</code></pre><pre><code>touch: cannot touch &#x27;/home/admin/test&#x27;: Read-only file system
</code></pre><p>dmesg 可看到异常信息，几个月前已经出问题了，因为系统还能正常使用暂且没管。</p><pre><code class="language-dmesg" metastring="title=&quot;dmesg -T&quot;" title="&quot;dmesg">[Tue Sep  7 16:48:16 2021] sd 2:0:0:0: [sda] tag#0 UNKNOWN(0x2003) Result: hostbyte=0x00 driverbyte=0x08 cmd_age=0s
[Tue Sep  7 16:48:16 2021] sd 2:0:0:0: [sda] tag#0 Sense Key : 0x7 [current]
[Tue Sep  7 16:48:16 2021] sd 2:0:0:0: [sda] tag#0 ASC=0x27 ASCQ=0x0
[Tue Sep  7 16:48:16 2021] sd 2:0:0:0: [sda] tag#0 CDB: opcode=0x2a 2a 00 00 04 16 90 00 00 08 00
[Tue Sep  7 16:48:16 2021] blk_update_request: critical target error, dev sda, sector 267920 op 0x1:(WRITE) flags 0x103000 phys_seg 1 prio class 0
[Tue Sep  7 16:48:16 2021] Buffer I/O error on dev sda2, logical block 466, lost async page write
</code></pre><h2>备份恢复方案</h2><p>将现在数据完整备份到新的 U 盘，重启即可，但恢复备份有好几种方式。</p><ol><li>全盘 dd</li></ol><ul><li>速度慢</li><li>简单暴力</li><li>需要提供至少现在磁盘大小的存储</li></ul><ol start="2"><li>重装 - 仅拷贝数据</li></ol><ul><li>麻烦</li></ul><ol start="3"><li>恢复分区、恢复数据</li></ol><ul><li>高效</li><li>需要多一点操作</li><li>新磁盘只需要已用空间大小即可</li></ul><h2>恢复</h2><p>因为这是已经第三四次恢复了，之前都是 dd，但这次打算用更高效的方式，且这次的系统盘为 128G，但目前只有 64G 的空闲 U 盘，故选择方案 3。</p><p><strong>恢复过程</strong></p><ol start="0"><li>准备备份盘</li><li>分区表备份 &amp; 启动分区备份</li><li>root 分区 备份 &amp; 修复</li><li>验证</li><li>关机</li><li>取掉坏的 U 盘</li><li>开机</li></ol><p>:::tip 恢复备份注意事项</p><ul><li>选择一个可写目录 - tmpfs,shm - 例如: /run, /var/run, /tmp, /dev/shm</li></ul><p>:::</p><h3>准备备份盘</h3><ul><li>备份盘 /dev/sdb 64G，同 SanDisk CZ430</li></ul><pre><code class="language-pre" metastring="title=&quot;lsblk&quot;" title="&quot;lsblk&quot;">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    1 114.6G  0 disk
├─sda1   8:1    1   128M  0 part /boot
└─sda2   8:2    1 114.4G  0 part /
sdb      8:16   1  57.3G  0 disk
</code></pre><h3>分区表&amp;启动分区备份</h3><pre><code class="language-bash"># 确保使用 root 用户操作
sudo su
# 进入可写目录
cd /run

# 正常情况分区表的备份恢复
# sfdisk -d /dev/sda | sfdisk -f /dev/sdb

# 选择简单方式备份后再修改最后分区
# 这里 dd 130MB - 同时把 boot 分区备份了
dd if=/dev/sda of=/dev/sdb bs=1M count=130 status=progress

# 转储分区表
sfdisk -d /dev/sda &gt; sda.partition.table.txt
# 删除第二个分区的大小
sed -r &#x27;$ s/size=\s*\d+,//&#x27; -i sda.partition.table.txt
# 重建分区
sfdisk -f /dev/sdb &lt; sda.partition.table.txt
# 现在分区大小正常
fdisk -l /dev/sdb

# 分区变化重新扫描
mdev -s
partprobe
# 出现分区
ls /dev/sdb*
</code></pre><h3>root 分区备份</h3><ul><li>root 分区一般较大，直接 dd 慢且伤 U 盘</li><li>直接 dd 需要目标相同大小，否则丢数据</li><li>这里使用 clone 数据方式</li></ul><p>:::caution 由于目标分区更小，不能直接复制</p><pre><code class="language-bash"># ext4 数据拷贝 - 基于 ext4 block，只拷贝使用部分
# 也可以用于生成 img 备份镜像之后用
e2image -ra -p /dev/sda2 /dev/sdb2
</code></pre><ul><li>如果分区大小足够，直接复制即可</li></ul><p>:::</p><p>因为 root 分区为 120G，但实际只用了 2.2G， 先镜像分区，缩小分区，然后恢复到新的分区。</p><p>索性内存有 4G，因此直接在 /dev/shm 操作，否则需要外置存储。</p><pre><code class="language-bash"># 从新挂载为 3G - 默认 2G
mount -o remount,size=3G /dev/shm
# 制作镜像
e2image -rap /dev/sda2 sda2.raw

# 修复分区 - 一般 U盘 损坏都会导致 fs 异常
e2fsck -y sda2.raw
# 缩小分区
resize2fs sda2.raw 4G
# 恢复
e2image -rap sda2.raw /dev/sdb2
# 扩展分区
resize2fs /dev/sdb2
</code></pre><h3>验证</h3><pre><code class="language-bash">fsck /dev/sdb1
fsck /dev/sdb2

mount /dev/sdb2 /mnt
mount /dev/sdb1 /mnt/boot
# 不应该有变化
rsync -vna /boot/ /mnt/boot/

# 由于 fsck 修复，可能 root 分区大小不同
df / /mnt /boot /mnt/boot
</code></pre><p>如果装有 qemu，还可以直接启用 qemu 验证，目前就简单确认文件没问题即可。</p><pre><code class="language-bash"># 准备关机重启
umount -R /mnt
eject /dev/sdb

poweroff
</code></pre><p>取掉 坏的 U 盘，启动。</p><p>一切恢复正常。🎉</p><h2>总结</h2><p>系统盘恢复还是相当容易，但 CZ430 确实有点老了，在 2017 年左右上市，相同规格已经卖 4、5 年了，性能各方面有所欠缺，之后会尽量选择 Lexar S47。</p><ul><li><a href="https://wener.me/notes/ops/admin/fio-out/">https://wener.me/notes/ops/admin/fio-out/</a><ul><li>SanDisk CZ430, Lexar S47 性能对比</li></ul></li></ul><p>此外使用 U 盘 做系统盘的时候，一定注意修改 docker 之类的数据目录为其他存储，因为跑实际应用的时候 U 盘 性能是不足的，且数据库类型应用的小 BlockSize IO 不适合 U 盘。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[从新学习]]></title>
            <link>https://wener.me/story/relearning</link>
            <guid>relearning</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[最近开始学习 PMP，管理，对我来说是一个“全新”的领域。]]></description>
            <content:encoded><![CDATA[<p>最近开始学习 PMP，管理，对我来说是一个“全新”的领域。</p><p>学习去学习，是这次学习开始老师讲的主题，因此也产生了自己的一些思考。
学习去学习，我认为是 meta-learning。学习，应该从未停止过，当我们从猴子开始，我们就在学习去熟悉、了解、掌握新的工具、环境、事物。</p><p>不需要学习的思考，是潜意识的提升。对学习过程进行思考归纳总结是，得到的是过程改进方式，因此两个人学习一天的结果会有所不同。</p><p>让给我联想到英语的两个单词，study &amp; learn。study 强调的只是过程，learn 强调的是结果内容，应该思考平时学习是 study 还是 learn。</p><blockquote><p>带思考的学习更容易获取一项技能知识。</p></blockquote><h2>管理</h2><p>管理，对我来说是一个 “全新” 的领域，作为技术研发，从未从管理学的概念去思考过问题。
但之所以是“全新”，是因为，生活无处不是管理，家庭纠纷、生活规划、日常工作。</p><p>我理解的管理，是控制。</p><p><img src="./feedback-loop.svg"/></p><p>控制理论的 反馈循环（feedbak loop） 图。</p><p><img src="./PDCA-Multi-Loop.png"/></p><p>精益生产的 PDCA 循坏图。</p><p><img src="https://kroki.io/plantuml/svg/eNpljrFKBDEQhvt5iqkF5fZQ7AQtfAGvOyxCdm43bDIJySyH1hYqIip2VlZrp5Wlb7PnPYZ7rhwBq498f_iS1BgOKiqHzrPXdfSOUGJLkLZLVNwkCjidZLIMBouD3KgY_XJWG90wpYSTvcNsDEo3qqKZEUvH1lTsiAUtLSS71CbSKtGJjyXFvLSfP0wL1Vo59Sxn5pKwmOZfJS2KK_uvUQDUpiQkF-RiaCQdTRDjGWC-c467R9g_vPe3bwh_HMy6u-qvn2DERqxuuvXrHYz4Fc-f_ccXjNiIoQXbfTh_vzyu7jsYkTV_AJjNmHw="/></p><p>项目管理 5 大过程组。</p><p>虽然是不同领域里的主题，但表达的却是相同的内容。</p><p>控制，减少变量，提升可预测性。</p><p>控制，是为了 提升/改进 现有过程。</p><p>What happened is happened,but what we can learn from the past ?</p><h2>学习</h2><p>为了更好理解和管理自己的学习，我梳理了我的学习过程，希望能从无意识变成有意识的学习。</p><p><strong>我的学习过程</strong></p><ul><li>Repeat - 重复 - 抄写重复最为浅显的内容</li><li>Refactor - 重构 - 按照自己的理解从新组织内容语言</li><li>Realize - 从新意识 - 对照生活、工作、现实、跳出固化场景</li><li>Regain - 从新获取 - 掌握</li></ul><p>:::caution</p><p>并不是所有主题都会经历所有的过程。学以致用，无以致用的主题只会停留在早期阶段。</p><p>:::</p><blockquote><p><del>We learn from teacher.</del></p><p>Teacher teached us.</p><p>Whatever teaches us is our teacher.</p></blockquote><p>老师、书本、文章、源码、事件都可能触发我们的“提升”。</p><p><strong>Repeat</strong></p><p>这时候我会进行简单的记录，好记性不如烂笔头。</p><p>在 <a href="https://github.com/wenerme/wener">https://github.com/wenerme/wener</a> 这里我记录了感兴趣的很多内容，有的可能是工作相关的，例如：技术；可能是工作无关的，例如：<a href="https://github.com/wenerme/wener/blob/958471ae9d9e2399e3c901f68380cea3c3154e82/notes/healthcare/disease/rheumatoid-arthritis.md">医学</a>。</p><p>:::tip Repeat阶段 内容的特点</p><ul><li>浅显</li><li>离散</li><li>精简</li></ul><p>:::</p><ul><li>浅显 - You get what you see</li><li>离散</li><li>精简 - 知识索引</li></ul><p><strong>Refactor</strong></p><p>有时候，我们会重复遇到相同的问题，抱有相同的疑问，需要参考相同的话题。</p><p>此时参考简单记录的内容已经不足以回答或解决问题，因此，会对内容进行重新重构。</p><p>重构意味着重新梳理内容知识，从新调整“索引”内容，按照自己的“脑回路”对问题域进行理解分析。</p><p>使用 git 进行笔记的好处是它能记录你的“<a href="https://github.com/wenerme/wener/commits/master/notes/devops/kubernetes">过程</a>”。</p><p>:::tip Refactor阶段 内容的特点</p><ul><li>发散的单个主题牵引出新的主题</li><li>按照自己的“脑回路”组织的内容结构</li><li>部分内容会进行细化</li></ul><p>:::</p><p><strong>Realize</strong></p><p>意识阶段有两个方式：</p><ol><li>自身</li><li>跨域</li></ol><p>自身，我们通常讲从失败学习，更多的是意识到了问题点，问题点在不经历的时候是不会发现的，而当遇到问题，解决问题这个循环进行多次后，会基于基本的理论知识抽取出属于自己的经验结论。</p><p>跨域，学习和成长不可能是一条路走到头的，有所成就的人绝不可能只会精通一门学科，理解不同领域事物的相关性是意识提升的关键。</p><p><strong>Regain</strong></p><p>之所以叫 regain，是因为已经经历过早期的 gain 过程，regain 时，才是我们真正的有所掌握，学以致用。</p><p>:::tip Ragain 阶段的体现</p><ul><li>独立决策</li><li>预测行为</li></ul><p>:::</p><p>这时候我愿称之为： 专家/Master。</p><h2>思维模式</h2><p>通常学习分为两种场景：</p><ol><li>工具技术学习 - 实</li><li>思想方法论学习 - 虚</li></ol><p>因为我的主要职责是软件开发，管理对我来说是个“虚”技能，因为并不能直接指导工作。但对于项目经理来说，管理是个“实”技能，而计算机理论则是“虚”技能。</p><p>学习项目管理，是更多是为了去了解项目管理的思维模式。</p><p>:::tip 模式=锤子=工具</p><p>当我们手里拿着锤子时，看到所有东西都是钉子。</p><p>-- 工具定律</p><p>:::</p><p>项目管理思维模式 和 软件设计模式 非常相似，是当我们解决问题时的参照。</p><p>但当你没有这个参照，没有这把锤子时，就会陷入困境，不断重复错误。</p><h2>学习主题</h2><p>学习是一个动作，必然会有目标，学习的主题可以是大而广的，也可以是小而精的。不如说，我们都需要把自己的知识储备磨练成 T 型结构。</p><p><img src="https://kroki.io/excalidraw/svg/eNrdls1u20YQgN-Fvars_v_opjiOrdR1XNiFHRhCsRbX0tYUSZArWbLha1-gt158aq-9Bn2eBO1jdEjqD6LSCE7ToNVJuzucmZ35dmbuAz_LbNAO7LRvYhfl5varfuyyq9TkUdAKbGxHNvFF0L68D1wEgpHz12PHJ53vh_34ZO-wc6WPLEjO9Zg8T29hOQ3anLOQaa6YFkhTyVvBLGgTqUItNWEKMaHKzVsX-WHQpoiGCsEJoYIShQkcDa0bDH3QRq3AJIPYVv8Kn6c3di-N0xzsfYGqH1i8Mv2bQZ6Ok2hx5nOTFJnJ4QJwfu3i-NTPSi3B0PSH47x0u9Z2XvuAF-uFXJFCTEAK1A6GiS0gDqQVpJnpOw-XwQj8KW1m3agMUW_5_dDkWS0fVC6VlqyF-GGhicYaSdkKJjYvXJrApkLL1XGa9ME01lxIwjQCn1zxHPLgy8-vTVxYuGupc3-Zm2Qcx61gnEXG1zao1gzCzwUGM1nq6gxeohbqtS63RBr1wPXYFH4vHY2cBy0n5UcLzYU3uX_mksglg8WeTaKNnUqqU-Z_aE20Jre2N-fjoTWniT4zL7_pdvvadrPvzu72z05u7iZbaRKahUhLjISmlGuq5jjhUDHKGFOEEbwOFFrxg7UOBUMIM8FAuhT63_BEFZacKoHXeUKswRMwQSBOVD6dJ64gCU2eUKsR38-A0wYxy1gQQTdjobAC8un2p1Vh-e3gIp3-wPeywy_ZgZrI8-TV-etPmPMVjSXpgoZCIiwEwlyQRd1EALrEVDKOscT66eA234cUIYFSQTRFYAee06pacQK1iiu9O5cbLJXCDZKkqI3sBMIHQNoNkW3YNq7d6_0dSZThxqvCAiGOSJmO96BEOjOD2aE9OPdndpQM85sL--LfQkkSHjJCOBNQISRWi6JJQoyZBJoo01J8PErQ5zEUIQRcKokEdJ4VXJqEEjiWUBkg9YirBVyEUwzWMf5n2YJGoOjnZmtLQBpxqGmrIJnuvT5Jzgf7t9PJeEzNy4wd6_6qDXo79XUXlEKHME5xiYnSaFkcOA5hsFJI8XrQmuelbAqLNBD1X256Rfl_1fQY3JYiCO1602OqOURRSaki8ulNT2ClNSiuUtAO_nj85c_ffnz3-FjGIk38qbsDOwTVqxdm5OJZFYJSvhO7ATgWxPba14XEO5iyF9s-zaqIFzZ2SakFPuuDFgOrvLtELs3dwCUmPtv0YK1WzQFZlSrRLFUUmrMQMD29t1SZztHR9CLqjM5y__zg9PTV19fj409fqhi8C0KV0gpRxYSumyCDIVXCoCewxgxIr0CnWoUw6Smp64L28V1w84nMAQPLBPoww7ujuUNtEgQjincgB9S-ffPT2zc_v_v91wYjO6P1YZhWRh56VZ4teH7_8PAXflh1kw=="/></p><p>:::tip 俗话说</p><p>东方不亮西方亮。</p><p>:::</p><p>不同的角度、观点都会让学习更加容易。</p><h2>学习过程</h2><p>学习是持续的不是一次性的，没有时间限制，没有领域限制，没有思维限制。</p><p>学习的驱动却肯定是有根因的，每个人都有所不同。</p><blockquote><p>We are who we are.</p></blockquote><p>学习的参考不应该是别人，而是自己。今天的自己期望明天的自己对比昨天的自己能有所提升，而达成这样提升的就是学习。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[组建你自己的 NAS 服务器]]></title>
            <link>https://wener.me/story/build-your-own-nas</link>
            <guid>build-your-own-nas</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[- 价格便宜]]></description>
            <content:encoded><![CDATA[<p>:::tip 目标</p><ul><li>价格便宜</li><li>容量高</li></ul><p>:::</p><ul><li>HP MicroServer 全新微塔 - 参考价格: ¥4000 , 功耗 60W<ul><li>HP MicroServer Gen 10<ul><li>全新 AMD x3216 8G ¥2300</li><li>最多 4 个硬盘</li></ul></li><li>SAS 6T×4 - ¥1600</li><li>SAS 卡 - ¥100</li></ul></li><li>二手塔式 - 参考价格: ¥4700 , 功耗 120W<ul><li>DDR4 服务器 - ~¥2000<ul><li>1U 4×3.5 寸盘位</li><li>2U 8×3.5 寸盘位</li></ul></li><li>CPU XeonE5v4×2 ~¥1000 - 32 核 64 线程</li><li>内存 DDR4 ECC REG 16G×4 - 64G ~¥1000</li><li>SAS 6T×4 - ¥1600</li><li>SAS 卡 - ¥100</li></ul></li><li>星际蜗牛 J1900 - 参考价格: ¥2500 , 功耗 30W<ul><li>星际蜗牛 DDR3 J1900 8G ~ ¥800</li><li>SAS 6T×4 - ¥1600</li><li>SAS 卡 - ¥100</li><li>非常入门款，没什么上升空间，没什么折腾的意义</li></ul></li></ul><p>:::tip 容量考虑</p><p>现在 2022 年，手机平台存储上 T 的已经越来越多，笔记本 SSD 都有几 T 的了，台式机更不用说，几 T 的存储很正常。</p><ul><li>单盘 &lt; 4T 会比较浪费盘位</li><li>单盘 &gt; 10T 恢复非常慢</li><li>建议至少 6T×4 - RAID5 可用大约 15T</li></ul><p>:::</p><h2>部件参考价格</h2><table><thead><tr><th>部件</th><th>规格</th><th>¥</th><th>taobao</th></tr></thead><tbody><tr><td>SAS</td><td>6T 3.5 寸 7.2K</td><td>¥400</td><td><a href="https://item.taobao.com/item.htm?id=560836442610">https://item.taobao.com/item.htm?id=560836442610</a></td></tr><tr><td>SAS</td><td>1.2T 2.5 寸 10K</td><td>¥160</td><td><a href="https://item.taobao.com/item.htm?id=547264783830">https://item.taobao.com/item.htm?id=547264783830</a></td></tr><tr><td>SAS 直通卡</td><td></td><td>¥100</td><td><a href="https://item.taobao.com/item.htm?id=521090584542">https://item.taobao.com/item.htm?id=521090584542</a></td></tr><tr><td>SATA</td><td>14TB 3.5 寸 7.2K</td><td>¥1200</td><td><a href="https://item.taobao.com/item.htm?id=599544680031">https://item.taobao.com/item.htm?id=599544680031</a></td></tr><tr><td>内存 DDR3 ECC REG</td><td>16G</td><td>~¥120</td><td><a href="https://item.taobao.com/item.htm?id=13978621463">https://item.taobao.com/item.htm?id=13978621463</a></td></tr><tr><td>内存 DDR4 ECC REG</td><td>16G</td><td>~¥250</td><td><a href="https://item.taobao.com/item.htm?id=567468034444">https://item.taobao.com/item.htm?id=567468034444</a></td></tr><tr><td>内存 DDR4 ECC REG</td><td>32G</td><td>~¥600</td><td><a href="https://item.taobao.com/item.htm?id=567468034444">https://item.taobao.com/item.htm?id=567468034444</a></td></tr><tr><td>内存 DDR4 ECC NOREG</td><td>16G</td><td>~¥500</td><td></td></tr><tr><td>内存 DDR4 ECC NOREG</td><td>32G</td><td>~¥1000</td><td></td></tr><tr><td>CPU <a href="https://ark.intel.com/content/www/us/en/ark/products/91766/intel-xeon-processor-e52683-v4-40m-cache-2-10-ghz.html">E5-2683V4</a></td><td>2.1G 16C32T 120W</td><td>~¥500</td><td><a href="https://item.taobao.com/item.htm?id=597514302182">https://item.taobao.com/item.htm?id=597514302182</a></td></tr><tr><td>CPU <a href="https://www.intel.cn/content/www/cn/zh/products/sku/88170/intel-xeon-processor-e31235l-v5-8m-cache-2-00-ghz/specifications.html">E3-1235Lv5</a></td><td></td><td></td><td></td></tr></tbody></table><p>:::caution PC 和 企业级服务器 过渡产品</p><ul><li>服务器市场有比 PC 强，但比服务器弱的一个产品线，通常用于个人工作室之类的场景。</li><li>特点<ul><li>服务器体积小</li><li>CPU 功耗低 - 25W</li><li>内存使用 ECC NOREG<ul><li>二手市场少，价格偏高</li><li>需要 CPU 支持</li><li>需要主板支持</li></ul></li></ul></li></ul><p>:::</p><h2>主机选择</h2><ul><li>机型选择<ul><li>微塔 - 噪音小，功耗一般 ~60w<ul><li>二手少 - 大多买新的，价格高</li><li>体积小</li><li>一般主板不支持 ECC REG 内存</li></ul></li><li>服务器 - 噪音大，功耗一般 ~120w<ul><li>二手多 - 便宜</li><li>体积大 - 一般 1U</li><li>扩展能力强 - 通常支持 一个半高+一个全高 PCI - 因此可以配 GPU</li><li>如果没有书房、库房或隐瞒角落不推荐</li><li>部分服务器噪音也不是特别大</li></ul></li></ul></li><li>平台选择<ul><li>通常二手都是落后好几个世代，但建议至少选择 DDR4</li><li>DDR3 价格是 DDR4 的一半 - 如果预算有限，那也是可以的<ul><li>选择 DDR3 CPU 也会便宜一半以上 - 是再上一个世代的平台</li></ul></li></ul></li><li>配置选择<ul><li>全新整套主机 - 包含 CPU+内存<ul><li>性价比不高，但省事</li></ul></li><li>二手服务器<ul><li>性价比最高，省事</li><li>可选性不多</li></ul></li><li>自己配主机 - 主板+机箱+电源+CPU+内存<ul><li>事情最多，如果不是喜欢搞这个，建议不要</li></ul></li></ul></li><li>服务器选择<ul><li>架式<ul><li>二手市场最多，占地面积大</li><li>1U<ul><li>8 个 2.5 寸盘位</li><li>4 个 3.5 寸盘位</li></ul></li></ul></li><li>塔式<ul><li>二手市场不多，占地面积大</li><li>和普通台式电脑差不多</li><li>服务器主板</li></ul></li><li>刀片<ul><li>二手市场很少</li></ul></li><li>模块<ul><li>二手市场不太多，占地面积很小</li><li>魔改后的非常安静</li></ul></li></ul></li><li>成品 NAS 服务器<ul><li>群晖 - 不再这里的讨论范围内</li></ul></li></ul><h3>配置目标</h3><table><thead><tr><th>-</th><th>机型</th><th>CPU</th><th>内存</th><th>硬盘</th></tr></thead><tbody><tr><td>最低</td><td>微塔,ITX</td><td>4 核</td><td>8G</td><td>6T×4 raidz1</td></tr><tr><td>推荐</td><td>-</td><td>4 核+</td><td>16G+</td><td></td></tr><tr><td>更高</td><td>服务器</td><td>32 核心+</td><td>128G+</td><td></td></tr></tbody></table><blockquote><p>通常配置个最低，后期能够调整组件即可</p></blockquote><h3>全新整套主机</h3><ul><li><a href="https://www.hpe.com/psnow/doc/a00008701enw">hp microserver gen 10</a><ul><li>AMD x3216 8G ¥2300</li><li><a href="https://item.taobao.com/item.htm?id=564308249868#detail">https://item.taobao.com/item.htm?id=564308249868#detail</a></li></ul></li><li>hp microserver gen 10 plus<ul><li><strong>非常小巧</strong></li><li>需要海淘</li><li>¥5000</li></ul></li><li>mineNAS 至强 微塔<ul><li>Core 系列 CPU <a href="https://item.taobao.com/item.htm?id=546747046542">https://item.taobao.com/item.htm?id=546747046542</a><ul><li>¥3600</li></ul></li><li>Xeon 系列 CPU <a href="https://item.taobao.com/item.htm?id=523041473305">https://item.taobao.com/item.htm?id=523041473305</a><ul><li>¥7500+</li></ul></li></ul></li></ul><h3>二手服务器</h3><ul><li>架式<ul><li>HP DL160G9 <a href="https://item.taobao.com/item.htm?id=564082577179">https://item.taobao.com/item.htm?id=564082577179</a><ul><li>准系统 ¥750</li><li>E5-4650V3<!-- -->*<!-- -->2 24 核 48 线 + 64G + Intel 800G SSD ¥3290</li><li>8×2.5 寸盘位</li></ul></li><li>DELL R430 X99 <a href="https://item.taobao.com/item.htm?id=567440742661">https://item.taobao.com/item.htm?id=567440742661</a><ul><li>准系统 ¥2200</li><li>4×3.5 寸盘位</li></ul></li><li>DELL R630 <a href="https://item.taobao.com/item.htm?id=557304169457">https://item.taobao.com/item.htm?id=557304169457</a><ul><li>准系统 ¥1449</li><li>8×2.5 寸盘位</li></ul></li><li>DELL R730 - <a href="https://item.taobao.com/item.htm?id=604846119404">https://item.taobao.com/item.htm?id=604846119404</a><ul><li>2U</li><li>8-12 3.5 寸盘位, 8-24 2.5 寸盘位,</li></ul></li></ul></li><li>模块服务器<ul><li>广达 单模块即可</li><li>改装后的非常安静</li><li>价格 ~¥500</li><li><strong>注意</strong> 硬盘可能不太好放</li></ul></li></ul><h3>装机</h3><p>:::tip</p><ul><li>装机通常主板都是买新的</li><li>机箱看情况买新的或二手的或定制的</li><li>明确装机要达成的目标 - 不要为了装机而装机<ul><li>容量？</li><li>尺寸大小？</li><li>硬盘、内存、CPU？</li></ul></li></ul><p>:::</p><ul><li>主板<ul><li><a href="https://www.asrockrack.com/">https://www.asrockrack.com/</a><ul><li>选择好后可淘二手</li></ul></li></ul></li><li>机箱<ul><li>确定好主板类型后决定</li><li>小的情况可定制 亚克力 机箱</li></ul></li><li>电源<ul><li>功耗 &lt; 120W 时可考虑外置</li><li>服务器功耗最好买 二手 服务器电源模块</li></ul></li></ul><h2>系统</h2><ol><li>黑群晖</li></ol><ul><li>安装使用容易</li><li>现成的应用</li><li>适用于新手或不愿意折腾的玩家</li><li>相对封闭 - 不建议用服务器运行，可以考虑开虚拟机</li></ul><ol start="2"><li>Linux</li></ol><h3>Linux</h3><ul><li>AlpineLinux</li><li>zfs<ul><li>看情况使用 raidz1,raidz2,draid<ul><li>raidz1=raid5 - 4 盘时</li><li>raidz2=raid6 - 6 盘时</li><li>draid - &gt;= 12 盘时</li></ul></li><li>SSD 缓存 - 如果有预算</li></ul></li><li>应用场景<ul><li>多媒体 - Jeylyfin, Plex, 照片, 音乐</li><li>下载器 - aria2, qtorrent, transimision</li><li>家庭 - Nextcloud</li><li>共享 - samba, afp</li><li>备份 - afp/TimeMachine</li><li>常用应用 - vaultwarden</li><li>服务器<ul><li>Kubernetes/k3s - 推荐</li><li>Docker</li><li>虚拟机</li></ul></li></ul></li></ul><h1>常见问题</h1><h2>如何选择硬盘缓存</h2><ul><li>如果使用 ZFS+SSD 作为缓存，那硬盘的缓存影响不大</li><li>如果使用 硬件 RAID，那硬盘的缓存能提效</li></ul><h2>为什么选择 SAS 硬盘</h2><ul><li>SAS 为企业级硬盘 - 二手质量高</li><li>二手市场多</li><li>支持热插拔 - 更换容易</li><li><strong>但</strong> 通常需要额外的 SAS 卡 - 一般选择半高 PCI</li><li>SAS 还需要注意区分 2.5 和 3.5<ul><li>3.5 - 容量 300G-5T, 转速 7200+</li><li>2.5 - 容量 120G-1T, 转速 10000-15000</li></ul></li></ul><h2>如何选择 CPU</h2><ul><li>志强 Xeon<ul><li>优点<ul><li>二手市场多</li><li>价格便宜</li><li>性能非常好 - 核心多</li></ul></li><li>缺点<ul><li>功耗高 - 120W</li><li>需要主板支持</li><li>一般媒体能力普通</li><li>全新非常贵</li></ul></li></ul></li><li>志强 Xeon L<ul><li>优点<ul><li>功耗低 - 25W</li></ul></li><li>缺点<ul><li>ECC NOREG</li><li>通常内存只支持 2 通道 - 一般家用 NAS 足矣</li></ul></li></ul></li><li>酷睿 Core<ul><li>优点<ul><li>单核频率高</li><li>媒体处理能力强</li><li>功耗一般 - 60W</li></ul></li><li>缺点<ul><li>贵</li><li>核心数少 - 作为服务器核心数比单核频率更重要</li></ul></li></ul></li><li>凌动 Celeron<ul><li>优点<ul><li>功耗非常低 - 10W</li></ul></li><li>缺点<ul><li>能力有限</li></ul></li></ul></li></ul><h2>服务器 和 PC/HTPC 的区别</h2><ul><li>服务器通常支持管理模块<ul><li>启动慢</li><li>支持远程远离 - 开机，停机，健康检查，KVM</li><li>固件升级</li></ul></li><li>PC/HTPC 一般直接启动即可</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[数据同步模式]]></title>
            <link>https://wener.me/story/etl-pattens</link>
            <guid>etl-pattens</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[A 同步到 B]]></description>
            <content:encoded><![CDATA[<blockquote><p>A 同步到 B</p><p>DBA -&gt; A -&gt; B -&gt; DBB</p><p>Extract -&gt; Load</p><p>Extract -Transform-&gt; Load</p></blockquote><h2>场景</h2><p><strong>A,B,DBA,DBB 互通性</strong></p><table><thead><tr><th>from\to</th><th>DBA</th><th>A</th><th>B</th><th>DBB</th></tr></thead><tbody><tr><td>DBA</td><td></td><td></td><td></td><td>🟡</td></tr><tr><td>A</td><td></td><td></td><td>🟢</td><td>🟡</td></tr><tr><td>B</td><td>🟠</td><td>🟢</td><td></td><td></td></tr><tr><td>DBB</td><td>🟠</td><td></td><td></td><td></td></tr></tbody></table><ul><li>🟢 - 有可能 - A &lt;-&gt; B</li><li>🟡 - 也许可能 - 提供公有云数据库作为同步目标</li><li>🟠 - 不太可能<ul><li>如果是内部服务是可能的</li></ul></li></ul><h2>模式</h2><ul><li>Push - 推 - A -&gt; B</li><li>Pull - 拉 - A &lt;- B</li><li>Reactive - A &lt;-&gt; B</li><li>第三方 - A -&gt; X -&gt; B</li></ul><h2>方式</h2><ul><li>全量</li><li>增量<ul><li>基于增量游标</li><li>基于 CDC 事件</li></ul></li><li>Schema+Data</li></ul><h2>实现方案</h2><ul><li>DBA -&gt; A -&gt; B -&gt; DBB<ul><li>B 暴露 API，A 请求 B - Push/Hook</li><li>例如: WebHook</li></ul></li><li>DBA -&gt; A &lt;- B -&gt; DBB<ul><li>A 暴露 API，B 请求 A - Pull/Query</li><li>例如: WebHook</li></ul></li><li>DBA -&gt; A -&gt; DBB<ul><li>例如: 配置同步目标给 A, A 直接写入</li></ul></li><li>DBA -&gt; B -&gt; DBB<ul><li>例如: RLS 暴露给 B 访问</li></ul></li><li>DBA &lt;-&gt; DBB<ul><li>例如: DB Link, Replication</li></ul></li><li>DBA -&gt; A -&gt; Queue -&gt; B -&gt; DBB<ul><li>A,B 通过 Queue 交互 - A,B 都没有暴露接口</li><li>被动</li><li>Queue 定位<ul><li>数据存储 - Kafka</li><li>信息传输 - Redis, Nats - 例如 RPC over Redis Stream</li></ul></li></ul></li><li>DBA -&gt; X -&gt; DBB</li><li>DBA -&gt; A -&gt; X -&gt; B -&gt; DBB<ul><li>借助第三方服务 - 例如: AirByte, PgLoader</li><li>X 服务作为 中间服务 与 A,B 交互<ul><li>替代 Queue 角色</li><li>主动</li></ul></li><li>X 具有适配能力</li></ul></li></ul><h2>Transform 考虑</h2><ul><li>数据 Schema 适配</li><li>数据类型适配</li><li>过滤、转换、计算</li><li>通常包含逻辑<ul><li>逻辑 ~= Script<ul><li>Lua, Python, JS</li></ul></li><li>gRPC - 外部调用</li></ul></li><li>Transform 的复杂度决定了是 ETL 还是流处理<ul><li>ETL - 简单适配、调整、元数据</li><li>流处理 - 包含状态、依赖前后消息/Window、包含聚合</li></ul></li><li>例如: Flink, SparkSQL, Storm、KafkaSQL</li></ul><h2>数据编码 考虑</h2><ul><li>文本编码 - CSV,JSON,JSONL - 基础，丢失类型信息</li><li>二进制编码 - Avro, Parqute, Protobuf</li><li>CBOR - Concise Binary Object Representation<ul><li>对比 JSON 能更好的保留类型信息</li></ul></li><li>Schema+Data - 数据更紧凑</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[一种简单的压缩算法]]></title>
            <link>https://wener.me/story/simple-compress-algorithem</link>
            <guid>simple-compress-algorithem</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[使用环境：简单加密，使用字符串的读取方式，压缩杂项数据]]></description>
            <content:encoded><![CDATA[<p>使用环境：简单加密，使用字符串的读取方式，压缩杂项数据</p><p>基本原理：也就是把混乱的数据中的00字节去掉。</p><p>我想到使用这个压缩方法的时候是为了在文件io很慢的环境下一次性读取较多的文件内容，从而进行的压缩。在很多情况下字符串都是以00结尾的，所以这个压缩的算法只是把数据中的00字节去掉了。当被处理的文件中很多00的时候压缩率较大。但是不适宜对文本，图片之类的压缩。注意，只是简单的压缩，压缩后能够简单的解压缩。在压缩普通数据的时候，大概平均压缩率能够达到 3 ：4</p><p>E.g.              90 80 29 00 78 98 00 00</p><p>这段数据被压缩后的结果是</p><p>{ 00 010011 } 90 80 29 78 98  注意只能表示 90 80 29 00 78 98 这6位数据</p><p>{}为1byte大小</p><p>一看这个列子就很简单了吧</p><p>第一byte为标志位。</p><p>具体说明</p><p>1     全为0位 若数据全为00 则此位为1</p><p>E.g.  00 00 00 00 00 00 =<!-- -->&gt;<!-- --> 标志位{ 10 000000 }</p><p>2     全为1位 若数据全不为00 则此位为1</p><p>E.g.  01 02 03 04 05 06  =<!-- -->&gt;<!-- --> 标志位{ 01 000000 } 01 02 03 04 05 06</p><p>此时数据变大</p><p>3-8 位表示该位是否为00 若是则为 1 当 1th 或2ed 不全为0时，可以忽略后面的 3-8位</p><p>所以 一个标志位最多能够表示后面的6字节数据，此时消除了数据中的00位，就可以用字符串的读取方式来一次性读取，或者做简单的加密。</p><p>一个示例的程序：</p><p>是用的步步高学习机的一种叫做BBasic的环境下写的，这个算法其实就是为了应付它io极其的慢的毛病。</p><p>这个代码我也只能说表达的是那个意思，如果稍加改造下，大概能够提速10倍 - 100 +倍。</p><p>declare function dechex$( decVal)</p><p>declare function bindec( binVal$)</p><p>&#x27;//把所给的一段数据压缩</p><p>&#x27;//步骤   我先考虑是内存的情况，也就是给出一个位置偏移，然后挨个去读</p><p>dim XDB_GetOffset, XDB_GetLen, XDB_GetStr$, XDB_PutFp, XDB_I</p><p>dim XDB_GetCur, XDB_AllZ, XDB_AllO</p><p>dim Xbd_Offset_Cur</p><p>dim XDB_HStr$, XDB_CStr$</p><p>dim XDB_HCode</p><p>dim XDB_GetStr_len</p><p>asm</p><p>ld int <!-- -->[ vint_XDB_GetOffset]<!-- -->, 0</p><p>endasm</p><p>XDB_GetLen = 7685 - 16</p><p>&#x27;ab cd 00 39 09 28</p><p>&#x27;19 08 02 18 00 00</p><p>&#x27;82 10 00 28 19 00</p><p>open &quot;x.txt&quot; for binary as #1</p><p>XDB_GetStr_len = 0</p><p>XDB_HCode = 0</p><p>XDB_GetStr$ = &quot;&quot;</p><p>XDB_CStr$ = &quot;&quot;</p><p>XDB_HStr$ = &quot;&quot;</p><p>t = gettick()</p><p>while XDB_I <!-- -->&lt;<!-- -->= XDB_GetLen</p><p>locate( 1, 1)</p><p>XDB_I = XDB_I + 1</p><p>Xbd_Offset_Cur = XDB_I mod 6</p><p>if Xbd_Offset_Cur = 0 then</p><p>if XDB_AllZ then</p><p>XDB_CStr$ = &quot;&quot;</p><p>end if</p><p>XDB_GetStr$ = XDB_GetStr$ + chr$( bindec( XDB_AllO$ + XDB_AllZ$ +XDB_HStr$ )) + XDB_CStr$</p><p>XDB_HStr$ = &quot;&quot;</p><p>XDB_HCode = 0</p><p>XDB_CStr$ = &quot;&quot;</p><p>XDB_AllZ$ = &quot;1&quot;</p><p>XDB_AllO$ = &quot;1&quot;</p><p>XDB_GetStr_len = XDB_GetStr_len + 1</p><p>if XDB_GetStr_len <!-- -->&gt;<!-- --> 4088 * 4 then</p><p>print XDB_I</p><p>put #1, XDB_GetStr$</p><p>XDB_GetStr$ = &quot;&quot;</p><p>end if</p><p>end if</p><p>&#x27;print &quot;第二步&quot;</p><p>asm</p><p>ld int <!-- -->[ vint_XDB_GetCur]<!-- -->, 0</p><p>ld int r0, <!-- -->[ vint_XDB_GetOffset]</p><p>ld byte <!-- -->[ vint_XDB_GetCur]<!-- -->, <!-- -->[ r0 ]</p><p>endasm</p><p>&#x27;=/当前位为非0</p><p>if XDB_GetCur then</p><p>XDB_CStr$ = XDB_CStr$ + chr$( XDB_GetCur)&#x27;&quot;.&quot; + dechex$( XDB_GetCur)</p><p>XDB_HStr$ = XDB_HStr$ + &quot;0&quot;</p><p>&#x27;==//全为0的标志位</p><p>XDB_AllZ$ = &quot;0&quot;</p><p>&#x27;=/当前位为0</p><p>else</p><p>XDB_HStr$ = XDB_HStr$ + &quot;1&quot;</p><p>&#x27;==//全为1的标志位</p><p>XDB_AllO$ = &quot;0&quot;</p><p>end if</p><p>XDB_GetStr_len = XDB_GetStr_len + 1</p><p>&#x27;==//一次处理12位</p><p>XDB_GetOffset = XDB_GetOffset + 1</p><p>wend</p><p>print &quot;用时&quot;; gettick() - t</p><p>put #1, XDB_GetStr$</p><p>put #1, &quot;END&quot;</p><p>close #1</p><p>asm</p><p>jmp QingWuShi_XDB:</p><p>XDB_Compression_HCode:</p><p>.block 1 0</p><p>XDB_Compression_CCode:</p><p>.block 6 0</p><p>XDB_Compression_Catch:</p><p>.block 15 0</p><p>XDB_Compression_Base:</p><p>endasm</p><p>asm</p><p>ret</p><p>data x bin %abcd00390928190802180000821000281900%</p><p>QingWuShi_XDB:</p><p>endasm</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2011年的第一天，今天开通博客了]]></title>
            <link>https://wener.me/story/start-blogging</link>
            <guid>start-blogging</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[算来算去终于到了今天了。]]></description>
            <content:encoded><![CDATA[<p>算来算去终于到了今天了。</p><p>有意等到了今天就开通我的博客，这样一个的平台上，说自己想说的，做自己想做的，挺好的。</p><p>为了避免博客空荡荡的，所以我就事先写好了<!-- -->[Php 操作二进制流，读取文件结构]<!-- -->(./2011-01-01-PHP 操作二进制流，读取文件结构.md)这篇文章，恩恩，个人感觉良好啊。</p><p>不知道这个博客会陪伴我走多久，至少我会记得11年的01日是她的诞辰，每年的第一天都是他的生辰，希望她能一直陪我走下去吧，我看着她成长，他也看着我成长。</p><p>读着书，我都打算每月更新一篇文章了，很多东西，其实整理一下就又是一篇不错的文章了，自己也享受那整理的过程。挺快乐的，而且也巩固了自己的知识。何乐而不为呢？</p><p>我的博客上或许不会出现什么广告吧，我也不会用广告来赚钱，感觉没有广告清爽多了，也干净些。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[PHP 操作二进制流，读取文件结构]]></title>
            <link>https://wener.me/story/php-read-binary</link>
            <guid>php-read-binary</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[本文包含的内容：详细的pack和unpack调用详解，16进制数字字符串保存到文件，读取文件返回值，等]]></description>
            <content:encoded><![CDATA[<p>本文包含的内容：详细的pack和unpack调用详解，16进制数字字符串保存到文件，读取文件返回值，等</p><p>本文包含的内容：详细的pack和unpack调用详解，16进制数字字符串保存到文件，读取文件返回值，等包含实例：读取</p><p>BMP图片信息函数：</p><p>//将16进制字符串转换为此值的字符串。</p><p>function hexstr_str( $hetstr)</p><p>//两个版本，一个是pack实现，一个是chr方法实现</p><p>曾经为了处理源文件就百度了下php 2
进制文件，结果出来的貌似都是一个人写的，别人复制和转载的，而且我也偏偏没有看懂。挺郁闷的。因此就有了下文，我就自己搞打，研究研究。Php处理</p><p>2进制无非就是使用pack和unpack，在后文讲讲其他的办法。</p><p>函数原型：</p><p>string pack ( string $format [, <a href="http://cn2.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a> $args [, <a href="http://cn2.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a> $... ]] )</p><p>array unpack ( string $format , string $data )</p><p>Pack是讲所给的参数更具所给的格式打包成2进制字符串。手册上说这个函数和Perl的基本相同，只是在格式上去掉了s,u等。这里有一点要注意的是，有符号和无符号的数由pack转换出来的结果相同，但是会影响unpack的结果。</p><p>先看一个小小的实例：</p><p>$data = pack(&quot;N&quot;, 0x12345);</p><p>var_dump($data);</p><p>$fn = &#x27;out.text&#x27;;</p><p>$fp = fopen($fn,&#x27;w&#x27;);</p><p>fwrite($fp,$data);</p><p><a href="http://www.wener.me/wp-content/uploads/2011/01/php%E5%A4%84%E7%90%862%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-899.png"><img src="http://www.wener.me/wp-content/uploads/2011/01/php%E5%A4%84%E7%90%862%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-899.png" title="php处理2进制文件-899"/></a></p><p>结果很明了，用法很简单。</p><p>关于N模式：</p><p>unsigned long (always 32 bit, big endian byte order)</p><p>无符号长整型，总是返回32位</p><p>格式：</p><table><thead><tr><th>mode</th><th>说嘛</th></tr></thead><tbody><tr><td>a</td><td>将字符串空白以 NULL 字符填满</td></tr><tr><td>A</td><td>将字符串空白以 SPACE 字符 (空格) 填满</td></tr><tr><td>h</td><td>十六进位字符串，低位在前</td></tr><tr><td>H</td><td>十六进位字符串，高位在前</td></tr><tr><td>c</td><td>有号字符</td></tr><tr><td>C</td><td>无号字符</td></tr><tr><td>s</td><td>有号短整数 (十六位，依计算机的位顺序)</td></tr><tr><td>S</td><td>无号短整数 (十六位，依计算机的位顺序)</td></tr><tr><td>n</td><td>无号短整数 (十六位, 高位在后的顺序)</td></tr><tr><td>v</td><td>无号短整数 (十六位, 低位在后的顺序)</td></tr><tr><td>i</td><td>有号整数 (依计算机的顺序及范围)</td></tr><tr><td>I</td><td>无号整数 (依计算机的顺序及范围)</td></tr><tr><td>l</td><td>有号长整数 (32位，依计算机的位顺序)</td></tr><tr><td>L</td><td>无号长整数 (32位，依计算机的位顺序)</td></tr><tr><td>N</td><td>无号短整数 (32位, 高位在后的顺序)</td></tr><tr><td>V</td><td>无号短整数 (32位, 低位在后的顺序)</td></tr><tr><td>f</td><td>单精确浮点数 (依计算机的范围)</td></tr><tr><td>d</td><td>倍精确浮点数 (依计算机的范围)</td></tr><tr><td>x</td><td>空位</td></tr><tr><td>X</td><td>倒回一位</td></tr><tr><td>@</td><td>填入 NULL 字符到绝对位置</td></tr></tbody></table><p>关于pack的调用方法。</p><p>因为pack是支持多个不定个数参数的，所以每个参数都要指定一个转换的模式。</p><p>$data = pack(&quot;Nn&quot;, 0x12345, 0x12345);</p><p>当你参数的个数多于格式的个数时，出现：</p><p>Warning: pack() [<a href="http://localhost/lab/function.pack">function.pack</a>]: 1 arguments unused in E:\host\htdocs\Lab\Binary.php on line 4</p><p>Warning级错误。</p><p>这个还有个注意的是*模式。</p><p>$data = pack(&quot;Nn*&quot;, 0x12345, 0x12345, 0x12345);<!-- -->\<!-- -->最后两个是16位，所以输出里面是2字节</p><p>var_dump($data);</p><p>$fn = &#x27;out.text&#x27;;</p><p>$fp = fopen($fn,&#x27;w&#x27;);</p><p>fwrite($fp,$data);</p><p>输出：</p><p><a href="http://www.wener.me/wp-content/uploads/2011/01/php%E5%A4%84%E7%90%862%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-1934.png"><img src="http://www.wener.me/wp-content/uploads/2011/01/php%E5%A4%84%E7%90%862%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-1934.png" title="php处理2进制文件-1934"/></a></p><p>看出来了最后两个是一样的。因为手册上没说，但是我猜测*模式就是“同上”的意思吧。</p><p>基础知识：</p><p>1字节 =  8位 = 2^8 =  256</p><p>一个gb2312字符2字节，一个ascii字符1字节。</p><p>关于模式的选择都由个人使用的情况决定，这里我给出我自己写的一个函数。</p><p>//将16进制字符串转换为此值的字符串。</p><p>function hexstr_str( $hetstr)</p><p> {</p><p> $re = &#x27;&#x27;;</p><p> for( $i = 0; isset( $hetstr<!-- -->[ $i + 4]<!-- -->); $i += 4)</p><p> //echo substr( $hetstr, $i, 2);</p><p> $re .= pack(&#x27;n&#x27;, ( &#x27;0x&#x27;.substr( $hetstr, $i, 4)) * 1);</p><p> $len = strlen( $hetstr) - $i;</p><p> $hetstr = &#x27;0x&#x27;.substr( $hetstr, $i, strlen( $hetstr) - $i);</p><p> $hetstr .= ( $len % 2) ? &#x27;0&#x27;:&#x27;&#x27;;</p><p> $format = $len <!-- -->&lt;<!-- --> 3 ? &#x27;v&#x27;: &#x27;n&#x27;;</p><p> $re .= pack( $format, $hetstr * 1);</p><p> return $re;</p><p> }</p><p>测试：</p><p>$data = hexstr_str( &#x27;ABCDc&#x27;);</p><p>输出：</p><p><a href="http://www.wener.me/wp-content/uploads/2011/01/php%E5%A4%84%E7%90%862%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-2766.png"><img src="http://www.wener.me/wp-content/uploads/2011/01/php%E5%A4%84%E7%90%862%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-2766.png" title="php处理2进制文件-2766"/></a></p><p>有点遗憾的是它都要用0来补满16位。不过总的来说还是很不错的啦。</p><p>Unpack的使用，我觉得用着这个感觉挺揪心的。</p><p>unpack() works slightly different from Perl as the unpacked data is stored in an associative array. To accomplish this you have to name the different format codes and separate them by a slash /.</p><p>Unpack的运行和Perl的有些微不同，在php中unpack的结果是由一个数组返回的。因此你需要接受这些数据就要给格式命名，以/分隔。</p><p>手册上的实例；</p><p>&lt;<!-- -->?php</p><p>$array = unpack(&quot;c2chars/nint&quot;, $binarydata);</p><p>?<!-- -->&gt;</p><p>看一个我个人的调用实例：</p><p>$data = pack(&quot;n&quot;, (&#x27;0x&#x27;.&#x27;abc&#x27; ) * 1);</p><p>$data = hexstr_str( &#x27;ABCDc&#x27;);</p><p>$s = $data;</p><p>$array = unpack(&quot;Nwen/n2stort&quot;, $s.$s);</p><p>输出结果：</p><p>array(3) {</p><p> <!-- -->[&quot;wen&quot;]<!-- -->=<!-- -->&gt;</p><p> int(-1412579328)</p><p> <!-- -->[&quot;stort1&quot;]<!-- -->=<!-- -->&gt;</p><p> int(43981)</p><p> <!-- -->[&quot;stort2&quot;]<!-- -->=<!-- -->&gt;</p><p> int(49152)</p><p>}</p><p>上式结果也就是</p><p>wen:abcdc000</p><p>stort1:abcd</p><p>stort2:c000</p><p>看着这样的结果和输入的格式我觉得很揪心的。不过这里还是有点好处的，这个我们可以格式化输出一个文件的头信息什么的。</p><p>详细讲讲uppack的格式和输入的关系。</p><p>&quot;Nwen/n2stort&quot;</p><p>即第一个解析以N为格式，以wen为名字。</p><p> 第二个解析以n为格式解析两次，以short为名字。</p><p>生成的short的名字是以short1，short2，……shortn这样的形式增长的。</p><p>解析的方法：</p><p>N，先在输入（$s.$s）中读入32位长，即4字节。然后再用N转换，此时指向$s.$s指针的位置已经到了4了，第一个$s已经读完了，因此要是输入是$s的话会报错：</p><p>Warning: unpack() [<a href="http://localhost/lab/function.unpack">function.unpack</a>]: Type n: not enough input, need 2, have 0 in E:\host\htdocs\Lab\Binary.php on line 7</p><p>bool(false)</p><p>此时的返回值为false。</p><p>在解析完第一个N后遇到了“/”进入下一组的解析，解析的格式为n，有2组，名字为short</p><p>所以short1为输入的第4-6解析的结果，而short2为6-8的结果。都是一一对应的。</p><p>这样看来也不是很难嘛是吧。</p><p>个人方法：</p><p>Perl思想中有一条是：</p><p>There&#x27;s More Than One Way To Do It.</p><p>我也觉得如此。</p><p>Php中有个函数叫做</p><p>String chr( int $ascii )</p><p>返回一个字节，以ascii值为参数。</p><p>原本的ascii只有127的，但是后来扩展到了255加上0那就是256  很好 这样就都能表示了。</p><p>把上面那个函数稍微改造一下就是：</p><p>//将16进制字符串转换为此值的字符串。</p><p>function hexstr_str( $hexstr)</p><p>{</p><p> $re = &#x27;&#x27;;</p><p> for( $i = 0; isset( $hexstr<!-- -->[ $i +1]<!-- -->); $i += 2)</p><p> $re .= chr( (&#x27;0x&#x27;.$hexstr<!-- -->[ $i]<!-- -->.$hexstr<!-- -->[ $i + 1]<!-- -->) * 1);</p><p> if( strlen( $hexstr) <!-- -->&gt;<!-- --> $i)</p><p> $re .= chr( (&#x27;0x&#x27;.$hexstr<!-- -->[ $i]<!-- -->.&#x27;0&#x27;) * 1);</p><p> return $re;</p><p>}</p><p>代码简洁了很多啊。看起来顺眼多了。</p><p>置于我为啥研究这个玩意儿，我最开始也就是为了用啦读取BMP源文件的。</p><p>这里我们来简单写个读取BMP头信息的函数。</p><p>注意，这里是以24/32位图举例，16/8/2位位图在这里可能行不通的，因为数据结构不同。</p><p>BMP文件结构：</p><p>Begin</p><p>//文件头</p><p> section &quot;BMP File Header&quot;</p><p>  read-only char<!-- -->[2]<!-- --> &quot;BMP_ID&quot;  // 00</p><p>  uint32 &quot;File size&quot;    // 02</p><p>  uint32 &quot;Reserved&quot;    // 06</p><p>  uint32  &quot;ImageDataOffset&quot;   // 0A</p><p> endsection</p><p>//信息头</p><p> section &quot;BMP Info Header&quot;</p><p>  uint32 &quot;HeaderSize&quot;    // 0E</p><p>  uint32 &quot;Width&quot;     // 12</p><p>  uint32 &quot;Height&quot;    // 16</p><p>  uint16 &quot;Planes&quot;    // 1A</p><p>  uint16 &quot;BPP&quot;     // 1C</p><p>  uint32 &quot;CompessionMethod&quot;   // 1E</p><p>  uint32 &quot;ImageSize&quot;    // 22</p><p>  uint32 &quot;XPixelsPerMeter&quot;   // 26</p><p>  uint32 &quot;YPixelsPerMeter&quot;   // 2A</p><p>  uint32 &quot;PaletteSize&quot;    // 2E</p><p>  uint32 &quot;ColorsImportant&quot;   // 32</p><p> endsection</p><p>//调色板信息</p><p> section &quot;Palette(If PaletteSize=0 then no palette)&quot;</p><p>  numbering 0</p><p>  {</p><p>   byte &quot;B<!-- -->[~]<!-- -->&quot;</p><p>   byte &quot;G<!-- -->[~]<!-- -->&quot;</p><p>   byte &quot;R<!-- -->[~]<!-- -->&quot;</p><p>   byte &quot;A<!-- -->[~]<!-- -->&quot;</p><p>  } <!-- -->[PaletteSize]</p><p> endsection</p><p>end</p><p>实现的代码如下：</p><p>$data = file_get_contents( &#x27;Wener.bmp&#x27;);</p><p>$array = unpack(&quot;nBMP_ID/V文件大小/V保留字/V图片信息偏移/V头大小/V宽/V高/vPlanes/vBPP/V压缩方法/V图片大小/V横轴上每像素宽/V竖轴上每像素宽/V调色板大小/V重要的颜色&quot;, $data);</p><p>echo &#x27;<!-- -->&lt;<!-- -->pre<!-- -->&gt;<!-- -->&#x27;;</p><p>var_dump( $array);</p><p>foreach( $array as $k =<!-- -->&gt;<!-- --> $v)</p><p> echo $k,&#x27;:&#x27;,( $v),&#x27;<!-- -->&lt;<!-- -->br<!-- -->&gt;<!-- -->&#x27;;</p><p>请更改为你自己的图片地址后测试。我的输入如下：</p><p>BMP_ID:16973</p><p>文件大小:307254</p><p>保留字:0</p><p>图片信息偏移:54</p><p>头大小:40</p><p>宽:240</p><p>高:320</p><p>Planes:1</p><p>BPP:32</p><p>压缩方法:0</p><p>图片大小:307200</p><p>横轴上每像素宽:0</p><p>竖轴上每像素宽:0</p><p>调色板大小:0</p><p>重要的颜色:0</p><p>我的测试文件：</p><p><a href="http://www.wener.me/wp-content/uploads/2011/01/php%E5%A4%84%E7%90%862%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-6007.png"><img src="http://www.wener.me/wp-content/uploads/2011/01/php%E5%A4%84%E7%90%862%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-6007-225x300.png" title="php处理2进制文件-6007"/></a></p><p>总结：</p><p>总的，来说，php的这两个函数无疑是很强大的。用来分析文件也很好用。</p><p>或许不足的就是缺少这方面的案例吧，没见到很多人用过这个。</p><p>以后自己学习文件的结构也会常常用到这个函数，有时候觉得unpack比pack更有魅力。关于更详细的BMP文件结构和信息的获取我会另外写一篇文章的。这篇只是略微的涉及，作为一个例子而已。我还是觉得</p><p>Php处理2进制流的魅力是非常强大的。</p><p>置于建立在这个之上写更多的运用（加密，协议，破解，获取文件信息）什么的就看个人发挥了。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[“Wener”的来历 - 一段故事]]></title>
            <link>https://wener.me/story/wener-is-my-name</link>
            <guid>wener-is-my-name</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[记得那还是在初中的时候吧，初二左右吧，那时候班上就开始叫“简称”了，记得最先出现的是“志儿”，然后叫了叫的大家都开始叫简称了，我觉得这样也挺好的，叫人没那么费力了，也节省了不少口水和时间。]]></description>
            <content:encoded><![CDATA[<p>记得那还是在初中的时候吧，初二左右吧，那时候班上就开始叫“简称”了，记得最先出现的是“志儿”，然后叫了叫的大家都开始叫简称了，我觉得这样也挺好的，叫人没那么费力了，也节省了不少口水和时间。</p><p>所以我呢“文儿”就这样出来了，我觉得这样叫起来其实挺亲切的，听着的感觉也很好的。</p><p>而 文儿 即Wen er了，中文式的拼音转化过来的（虽然从小拼音就不好，那这也算是弥补下吧.......）。</p><p>而还有一个英语的单词 Win  ν.胜利  Winner  n.胜者</p><p>如果 Wener中的 e 发<code>[i:]</code>的音那就和 Winner的音相同了。谁不希望成为一个胜者呢。</p><p>这也算我怀揣着自己的梦想吧。</p><p>综上呢 我就特别喜欢 <em>Wener</em> 和 <em>文儿</em> 这个名字了</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[文件存储结构的基本形式及考虑因素]]></title>
            <link>https://wener.me/story/file-data-structures</link>
            <guid>file-data-structures</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[每天我们都在接触各种各样的文件，使用和记录各种各样的数据信息，那这些文件都是以什么结构存储的呢？此文对此进行了一些小小的涉及和讲解。]]></description>
            <content:encoded><![CDATA[<p>每天我们都在接触各种各样的文件，使用和记录各种各样的数据信息，那这些文件都是以什么结构存储的呢？此文对此进行了一些小小的涉及和讲解。</p><h1>文件存储结构</h1><p>基本组织方式： 顺序组织  索引组织  散列组织  链组织</p><p>常用结构        ：  顺序结构  索引结构  散列结构  链结构</p><h2>顺序结构（顺序表）</h2><p>分类：</p><p>存储位置相邻（连续文件）</p><p>记录间以指针链接（串联文件）</p><p>描述：顺序结构可用于顺序存取,但更改后需要全部复制，对增删操作不方便。优点是存取较快用于批量修改，不能动态增长。</p><p>比如：<a href="http://club.eebbk.com/bbkbbs/dispbbs.asp?boardid=38&amp;Id=250082">http://club.eebbk.com/bbkbbs/dispbbs.asp?boardid=38<!-- -->&amp;<!-- -->Id=250082</a></p><p>这个是步步高学习机中的文件，lcc（名片文件）和用户词典数据。都能算做是顺序结构吧，只是lcc还包含有一点头信息</p><h2>索引结构</h2><p>索引文件包含：索引表，数据表</p><p>描述：</p><p>索引表中索引项包含了与具体数据有关的相关信息，例如一些关键字等，但最主要的是指向数据表的一个地址。索引表是有序的，物理次序体现文件逻辑次序，实现文件线性结构。</p><p>索引表只能是磁盘文件，索引结构的文件既能顺序存取又能随机存取</p><p>比如：</p><p><a href="http://club.eebbk.com/bbkbbs/dispbbs.asp?boardid=38&amp;Id=250018">http://club.eebbk.com/bbkbbs/dispbbs.asp?boardid=38<!-- -->&amp;<!-- -->Id=250018</a></p><p><a href="http://club.eebbk.com/bbkbbs/dispbbs.asp?boardid=38&amp;Id=250092">http://club.eebbk.com/bbkbbs/dispbbs.asp?boardid=38<!-- -->&amp;<!-- -->Id=250092</a></p><p>cue-Wv 文件，一种媒体格式</p><p>Dvd的一些Vob文件也是索引的</p><p>这种文件中有的是以一整段数据存储在一起，然后以索引表来分段。有的是为了把多段数据存储在一起，然后以索引表来辨别分别的每个文件。</p><h2>散列结构（计算机寻址结构，其文件被称为散列文件）</h2><p>描述：</p><p>记录的是又关键字经过散列函数确定的地址，存取快，不需要索引节省了空间，但不能顺序存取 只能随机。RAM 随机存取的。</p><p>具体哪些文件是我也不清楚，因为一般哪些文件结构都比较难弄的清楚，必须要知道散列函数才能确定其数据结构。</p><h2>链结构</h2><p>描述：</p><p>即以指针链接的每个物理块。</p><p>优点是：能够存储碎片，利于动态增删，提高磁盘利用率</p><p>缺点是：存取较慢，不适用于随机存取，效率低，可靠性低（一个指针出错就全部都错了），指针需要空间来存储</p><p>链结构在计算机中运用还是很广泛的，编程时的数组对象等数据结构基本都是以链结构储存的。</p><p>一般链结构的key都需要一些指针信息，例如上一个位置下一个位置，感觉就像是数组结构。</p><h1>考虑因素</h1><p>一般选择具体文件结构的时候都需要更具具体情况来考虑，我这里只能罗列出一些考虑的因素</p><p>考虑因素：存储介质类型，记录类型，大小，关键字数目，对文件进行何种操作等</p><p>转载请注明出处。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《何必再》]]></title>
            <link>https://wener.me/story/no-more</link>
            <guid>no-more</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <content:encoded><![CDATA[<pre><code>何必 何必的再
为你想得太多
做的 说的
太多
重复的
你说过的
那已不再有意义
言语 词句
还是那么的诗情画意
爱你 未曾有秘密
你说今生注定
不能在一起
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《歌声》]]></title>
            <link>https://wener.me/story/the-song</link>
            <guid>the-song</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <content:encoded><![CDATA[<pre><code>徘徊在耳间
有你的呼吸 喘息

不停地 努力地
诉说着歌里的故事

留着你的泪 伤着你的心 回着你的忆

你和他怎没继续
那么多和他的小秘密

为什么不曾告诉他
却来向我说？
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《沉醉的犯罪》]]></title>
            <link>https://wener.me/story/addicted-sin</link>
            <guid>addicted-sin</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <content:encoded><![CDATA[<pre><code>月光使人沉醉
路灯光使人犯罪

那些沉醉在拥怀中犯罪的人啊
您可否挪挪

我不是有意要打扰你
只是你站在那里我太对不起
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《续爱》]]></title>
            <link>https://wener.me/story/love-more</link>
            <guid>love-more</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <content:encoded><![CDATA[<pre><code>延续上世的记忆
今生想着如何还能和你继续

我思念的人啊
我们相隔一世的距离

你是否还记得
有这个一个期待

你可以依赖
继续我们今生爱
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[学习之谈]]></title>
            <link>https://wener.me/story/learning-skill</link>
            <guid>learning-skill</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[一下内容之作为个人学习的一些经验]]></description>
            <content:encoded><![CDATA[<blockquote><p>一下内容之作为个人学习的一些经验
带有强烈的主观色彩, 不能认为完全正确. :smile:</p></blockquote><h2>学习 Java 的方法</h2><ul><li>有兴趣</li><li>会谷歌</li><li>有问题就谷歌</li><li>会点计算机英语</li><li>有问题就谷歌,尽量用英语</li><li>会翻墙</li><li>有问题就谷歌,尽量用英语,会翻墙才能看到谷歌</li></ul><h2>Java 的学习顺序应该如何呢</h2><ul><li>做一个东西</li><li>小游戏什么的 这个过程会学到很多</li><li>尽量偷懒</li></ul><h2>除了这个接下来看哪部分呢 I/O 流之类的？</h2><ul><li>没有个顺序 用到再学</li><li>不然为了学而学没意义</li></ul><h2>想学会了知识 再用 然后找工作</h2><ul><li>知识学不完</li><li>做点作品应该才是重要的 我觉得</li></ul><h2>学到够工作就够了 然后更多的都是在工作中学</h2><ul><li>永远够不了</li><li>没有银弹</li></ul><p>Q: 学到够一些基本工作的 然后在工作中会不断用到知识什么的 也可以再继续学 又锻炼又学,
自己学的话终归很多是不全面的 工作了知道需要什么了 方向跟更明确吧</p><ul><li>所以等到用的时候再学</li><li>能做出来东西说明你有底子了</li><li>也有了一定解决问题的能力</li></ul><p>Q: 但是现在我还是感觉学的太少了 还是什么都不会一样 所以想问问基本掌握哪些知识可以投入工作 或者就是说学习的基本顺序</p><ul><li>知道每个关键字的作用</li><li>什么时候用 怎么用</li><li>知道基本的语法</li><li>然后就可以尝试创造自己的世界了</li><li>过程中不断查找文档</li></ul><h2>我怎么偷懒的</h2><ul><li>一般想要做一个东西的时候, 都会大概的规划下, 需要些什么样的工具</li><li>然后会花费大量的时间谷歌</li><li>找自己能利用的,可用的,高效的一些工具</li><li>哪怕是为了自己少写几十行代码也会引入一个 jar 包</li><li>一定要会 maven 或 ivy, gradle 等</li><li>有了依赖管理工具, 导入 jar 包等, 就易如反掌了</li><li>在这样的一个过程中, 你一定会结识一些很好用的工具, 这些都有助于以后的开发</li><li>常用的好工具: guava, guice, jodd 系列, commons 系列, joda-time ...</li><li>除非必要, 尽量不要重复造轮子.</li><li>把自己写过的小东西留下来, 下次写东西的时候, 应该里面很多的东西都还会用到.</li><li>如果可以, 尽量使用高版本的 java</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[我的编程之道]]></title>
            <link>https://wener.me/story/the-why-i-write-code</link>
            <guid>the-why-i-write-code</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[- 能不能做]]></description>
            <content:encoded><![CDATA[<ul><li>能不能做</li><li>该怎么做</li><li>这样做会遇到什么问题</li><li>我有没有办法能够协调这些问题</li><li>将来会有什么样的改变</li><li>我需要运行在什么环境下</li><li>用什么语言写</li><li>运行时需要依赖什么条件</li><li>测试是否通过</li></ul><h1>我的观念</h1><h2>缩短变量作用域</h2><ul><li>可以减少代码错误</li><li>可以重用变量名</li><li>可以方便代码的重构</li><li>模块化更强</li><li>避免全局变量,有些全局变量可以用 singleton 模式来替代</li></ul><h2>写完整的单词,准确的名字</h2><ul><li>可以减少对注释的需求</li><li>代码更清晰,明白</li></ul><h2>适当的注释,可文档化的注释</h2><ul><li>便于生成代码文档,方便查阅</li><li>便于协作者使用你的代码和接口</li><li>一般 ide 支持的注释可以直接显示出来,各种方便</li><li>动态类型语言的文档可以提供更多的类型信息,比如 js</li><li>jsdoc,javadoc,doxgen,luadoc .....</li></ul><h2>尽量的偷懒</h2><ul><li>在准备写之前多查查已经有的库 (github, google code, sf.net, ....)</li><li>代码模块化越强,就越能偷懒</li><li>写代码时,考虑下怎么做尽量小的修改就可以做其他的东西</li><li>为重用而编码</li><li>使用代码生成, lombok, less, dart .....</li></ul><h1>我的代码风格</h1><h2>缩进风格</h2><p>我的代码风格主要和 <a href="http://en.wikipedia.org/wiki/Indent_style#Horstmann_style">Horstmann</a> 相近,但是也有些不同的地方.</p><p>Horstmann 风格:</p><pre><code class="language-c">while (x == y)
{   something();
    somethingelse();
    //...
    if (x &lt; 0)
    {   printf(&quot;Negative&quot;);
        negative(x);
    }
    else
    {   printf(&quot;Non-negative&quot;);
        nonnegative(x);
    }
}
finalthing();
</code></pre><p>我的风格:</p><pre><code class="language-c">while (x == y)
{
    something();
    somethingelse();
    //...
    if (x &lt; 0)
    {
        printf(&quot;Negative&quot;);
        negative(x);
    }else
    {
        printf(&quot;Non-negative&quot;);
        nonnegative(x);
    }
}
finalthing();
</code></pre><p>个人观点:</p><ul><li>因为常用 <code>{}</code> 来缩减作用域,开括号换行这样让代码更清晰,也便于自动缩进</li><li>因为 <code>{</code> 单独占了一行,这样让代码更长,但是也更多空白,看起来更轻松</li></ul><h2>英文单词的选择</h2><h3>title vs name</h3><p>See <a href="http://stackoverflow.com/questions/5527632/c-sharp-naming-convention-title-vs-name">http://stackoverflow.com/questions/5527632/c-sharp-naming-convention-title-vs-name</a></p><blockquote><p>Name is used more frequently for an object with an internal name or for business objects that naturally has a Name property (such as a person)</p><p>Title is used more often to refer to a User Interface Control object or a business object that naturally has a title, like an article.</p></blockquote><h3>ID vs Id</h3><p>See <a href="http://stackoverflow.com/questions/1151338/id-or-id-on-user-interface">http://stackoverflow.com/questions/1151338/id-or-id-on-user-interface</a></p><h3>Filename, FileName, filename</h3><p>See <a href="http://english.stackexchange.com/questions/5366/which-is-correct-filename-file-name-or-filename">http://english.stackexchange.com/questions/5366/which-is-correct-filename-file-name-or-filename</a></p><p>一般我选择 Filename.</p><h3>OK vs Ok : OK</h3><p>OK 是正确的写法</p><h3>DB vs Db</h3><p>See <a href="http://stackoverflow.com/questions/1345103/why-is-db-an-acronym-and-not-abbreviation">http://stackoverflow.com/questions/1345103/why-is-db-an-acronym-and-not-abbreviation</a></p><p>感觉 DB 比 Db 更好</p><h2>标识符</h2><ul><li>在 c 类函数式语言常用 <code>_</code> 来分割单词, 因为 c 的函数大多是这个风格
e.g. <code>void enter_stage();</code></li><li>在 java 类 oo 语言常用驼峰命名
e.g. <code>function enterStage()</code></li><li>静态方法第一个字母大写</li><li>用 set/get 前缀,并且 setter 是可链的.
e.g <code>Action setTime(int t){time = t; return this;} </code></li><li>如果不用 set/get 则用 流式的 API.</li></ul><pre><code>class Action
{
    int time;
    Action time(int t){time = t; return this;}
    int time(){ return time;}
}
</code></pre><ul><li>如果返回类型为 <code>boolean</code> 则用 is 作为 getter 前缀
e.g. <code>boolean isTimeOut();</code></li><li>在不原生支持 事件 的语言里,用 <code>On</code> 作为事件的前缀.
e.g. <code>void OnKeyInput(KeyEvent e);</code></li></ul><h1>我的实践</h1><p>在一些特定语言里,我的习惯</p><h2>JS</h2><h3>小技巧和习惯</h3><pre><code class="language-js">// 从string转换为number
+numberString;

// 强制转换为 boolean
!!object;

// 比较时使用 ===
if(!!objA === !!objB)
{}

// 用前缀 $ 来标识node或jq查询
var $main = $(&#x27;#main&#x27;);
var $wener = document.querySelector(&#x27;#wener&#x27;);

// 用 []/{} 来初始化数组和类
var list = [];// 而不是 new Array()
var obj = {};// 而不是 new Object()

</code></pre><h3>文件模式</h3><pre><code class="language-js">// 文件 action.js
(function()
{
    // code for action.js
})();
</code></pre><h3>类模式</h3><pre><code class="language-js">// 类 Action
(function(window)
{
    function Action(){}
    Action.prototype[&#x27;doSomthing&#x27;] = function(){};
    // export
    // window[&#x27;Action&#x27;] 比 window.Action 在压缩的时候更好
    // google closure compiler 的导出方法
    window[&#x27;Action&#x27;] = Action;
})(window);
</code></pre><h3>包/命名空间/类 模式</h3><pre><code class="language-js">// 包/命名空间 ui
// label.js
(function(ui)
{
    function Label(){}
    // export
    ui[&#x27;Label&#x27;] = Label;
})(window.ui || (window.ui = {}));
// button.js
(function(ui)
{
    function Button(){}
    // export
    ui[&#x27;Button&#x27;] = Button;
})(window.ui || (window.ui = {}));
</code></pre><h3>static 方法</h3><pre><code class="language-js">// 类 Action
(function(window)
{
    function Action(){}
    Action[&#x27;doSomthing&#x27;] = function(){};
    // export
    window[&#x27;Action&#x27;] = Action;
})(window);
</code></pre><h3>singleton 模式</h3><pre><code class="language-js">// 类 Action
(function(window)
{
    var instance = null;
    function Action()
    {
        if(instance != null)
            throw new Error(&quot;already init Action&quot;);
    }
    Action[&#x27;getInstance&#x27;] = function()
    {
        if(instance == null)
            instance = new Action();
        return instance;
    };
    // export
    window[&#x27;Action&#x27;] = Action;
})(window);
</code></pre><h3>避免使用一次性的匿名函数</h3><ul><li>便于重构</li><li>便于更改</li><li>代码清晰</li><li>可重用</li></ul><pre><code class="language-js">function OnLoad(){}
window.onload = OnLoad; // 而不是 window.onload = function(){};
</code></pre><h1>资源</h1><ul><li><a href="https://projectlombok.org">lombok</a>,java 代码生成</li><li><a href="https://github.com/rzwitserloot/lombok">github-lombok</a></li><li><a href="http://usejsdoc.org/">jsdoc</a>, js 注释规范,文档生成</li><li><a href="https://developers.google.com/closure/compiler/docs/js-for-compiler">js-for-compiler</a>
,Closure Compiler 的注释规范</li><li><a href="https://developers.google.com/closure/">closure</a>, js 优化,压缩 工具</li><li><a href="https://jshint.com">jshint</a>, js lint 工具,可配置的 jslint 版本.</li><li><a href="https://github.com/shichuan/javascript-patterns">javascript-patterns</a>, js 编程模式</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CentOS 新手]]></title>
            <link>https://wener.me/story/centos-newbie</link>
            <guid>centos-newbie</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[记录我玩 centos 的经历]]></description>
            <content:encoded><![CDATA[<blockquote><p>记录我玩 centos 的经历
很多时候需要 sudo 等 root 权限的时候需要自行判断.尽量不直接用 root 帐户.</p></blockquote><blockquote><p>我自己使用时的主要安装过程</p><p>初始配置 -&gt; 设置好 openssh-server -&gt; 添加额外的 repo -&gt; 安装 git
下载我的<a href="https://github.com/wenerme/dotfiles">dotfiles</a>
其他步骤则按需进行</p></blockquote><h2>初始 minimal 配置</h2><pre><code class="language-bash"># 首先是打开网络咯
ifconfig eth0 up
dhclient
# 添加个帐号, 设置好密码
useradd wener
passwd wener
# 把 创建的帐号添加到 sudoers file 中
echo &quot;wener ALL=(ALL) ALL&quot; &gt;&gt; /etc/sudoers
# 更新一下先
yum update -y
# 因为是 minimal 版本, 先安装一些必要的东西
yum install man wget curl -y
# 登出,下面的操作不在root下操作了,安全点
logout
# 用之前创建的帐号登录
</code></pre><h2>非 minimal 的准备</h2><pre><code class="language-bash"># Download ISOs
# UNETBootin
# Install
# ===============
# Configuration
# ===============
# basic upgrade
su root
yum upgrade
</code></pre><h2>添加其他的 repo</h2><pre><code class="language-bash"># add rpmforge
# fllow this http://wiki.centos.org/AdditionalResources/Repositories/RPMForge
rpm --import http://apt.sw.be/RPM-GPG-KEY.dag.txt
# 版本号可能有所不同,参见上面的链接
# 根据个人的系统构架`uname -i`选择 i686 或 x86_64
wget http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm
rpm -K rpmforge-release-*.rpm
rpm -i rpmforge-release-*.rpm
yum upgrade
</code></pre><h2>杂项</h2><pre><code class="language-bash"># lscpi
yum install pciutils -y
# iwconfig 等无线工具
yum install wireless-tools -y

# 列出已安装的包
yum list installed

# 切换 TTY 的快捷键 &lt;C-A-F1-6&gt;

# sudo 附加到文件
echo BOOTPROTO=dhcp | sudo tee -a /etc/sysconfig/network-scripts/ifcfg-wlan0

# 挂载 vbox 的共享目录
mkdir ~/shared
sudo mount -t vboxsf shared ~/shared

# 使用sudo找不到命令的时候
# 可以考虑将 /usr/local/bin/:/usr/local/sbin/
# 添加到 /etc/sudoers 的 secure_path 中

# 判断远程某端口是否开启
timeout 1 bash -c &#x27;cat &lt; /dev/null &gt; /dev/tcp/192.168.56.101/8087&#x27;
echo $?
</code></pre><p>CentOS 下 安装的 wpa_supplicant 没有 wpa_gui,可以参见 <a href="http://www.linuxfromscratch.org/blfs/view/svn/basicnet/wpa_supplicant.html">这里</a>,主要是因为 centos 的 wpa_supplicant 版本太老了,0.7 的,现在最新的是 2.1 的,查看<a href="http://w1.fi/wpa_supplicant/">官方主页</a>可下载.但是这个软件的依赖项对 centos 来说 版本太高了,安装起来非常复杂.</p><h2>启动不带窗口的 vbox</h2><p>很多时候只需要让系统运行, 然后远程 ssh 访问, 同时也节约点内存.</p><pre><code class="language-bash"># 方法一. 使用命令行
# 知道启动系统的名字或UUID
VBoxManager list vms
# 启动指定的系统
VBoxManager -s UUID
# 或
VBoxManager -s 系统名字
# 方法二. 在点启动按钮的时候,按住 Shift 即可
</code></pre><h2>安装前提</h2><pre><code># 在进行下列安装的时候 假设已经设置好了 rpmforg 已经安装了开发tao#套件 groupinstall &quot;Development tools&quot; -y
</code></pre><h2>Install 7z</h2><pre><code class="language-bash"># Install 7zip, centos can not uncompress some zip file.
yum install p7zip -y
</code></pre><h2>安装 GUI, 只针对于 minimal 安装的</h2><pre><code class="language-bash">yum -y groupinstall &quot;X Window System&quot; &quot;Desktop&quot; &quot;Fonts&quot; &quot;General Purpose Desktop&quot;
# 默认是没有火狐的,自己手动安装
yum -y firefox
</code></pre><h2>安装 virtual-box 的附加扩展</h2><p>一般直接安装扩展的时候安装主模块有可能失败.</p><pre><code class="language-bash"># 参考 http://wiki.centos.org/HowTos/Virtualization/VirtualBox/CentOSguest
# 需要先配置好 rpmforge
yum -y install dkms
yum -y groupinstall &quot;Development Tools&quot;
yum -y install kernel-devel
</code></pre><h2>安装 git</h2><pre><code class="language-bash"># 因为 git 版本太低了,所以打算自己安装git
yum --enablerepo=updates clean metadata
yum install perl-devel -y
yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel -y
# 可以考虑使用其他版本, 例如 https://github.com/git/git/archive/v1.9.4.zip
# 使用发布版稳定些
curl -L -o git.zip https://github.com/git/git/archive/master.zip
# 或
# wget -O git.zip https://github.com/git/git/archive/master.zip
unzip git*.zip
cd git*
make prefix=/usr/local all
make prefix=/usr/local install
# 这里可能和 在 Development tools 里的git冲突
# 可以移除安装的git 从新打开终端就好了
yum remove git
exit
# reopen an terminal
# 如果不想移除 git
# 清除下 git 的hash就好了
hash -d git
</code></pre><h2>Intsall ntfs-3g</h2><pre><code class="language-bash"># Add ntfs filesystem support, because I install centos with win7
# fllow this http://wiki.centos.org/TipsAndTricks/NTFS
yum install ntfs-3g -y
</code></pre><h2>Install iBus</h2><pre><code class="language-bash"># fllow this http://code.google.com/p/ibus/wiki/CentOS
# 1.Install necessary packages
yum install ibus ibus-gtk ibus-qt
yum install ibus-pinyin # or other engine(s) you want
yum install im-chooser
# 2. Enable input method at System-&gt;Perferences-&gt;Input Method
# 3. Add input methods
# 4.Re-login
</code></pre><h2>Install python2.7 for goagent</h2><pre><code class="language-bash"># Setup Development tools
yum groupinstall &quot;Development tools&quot; -y
# basic lib
yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel -y

# Manualy install puthon2.7, not change the system&#x27;s 2.6 version
# When I install python 2.7.x, the newest is 2.7.5
# go check at http://python.org/ftp/python/
# BTW, you can install 3.x python by this way
PYTHON_VERSION=2.7.5
mkdir ~/src &amp;&amp; cd $_
wget http://python.org/ftp/python/${PYTHON_VERSION}/Python-${PYTHON_VERSION}.tar.bz2
tar xf Python-${PYTHON_VERSION}.tar.bz2
cd Python-${PYTHON_VERSION}
./configure --prefix=/usr/local

# -j 8 for more quickly
# Notice, make install change to make altinstall
make -j 8 &amp;&amp; make altinstall
</code></pre><h2>Install python-openssl for python2.7</h2><pre><code class="language-bash"># Install python-openssl for goagent
mkdir -p ~/src &amp;&amp; cd $_
yum install openssl openssl-devel -y
wget --no-check-certificate https://pypi.python.org/packages/source/p/pyOpenSSL/pyOpenSSL-0.13.tar.gz
tar -xzfv pyOpenSSL-0.13.tar.gz
cd pyOpenSSL-0.13
# Notice, compile for python2.7
python2.7 setup.py build_ext -I /usr/local/include/python2.7/ -L /usr/local/lib/python2.7/
python2.7 setup.py build
python2.7 setup.py install
</code></pre><h2>Install goagent</h2><pre><code class="language-bash"># Download goagent and run it, because I have to install chrome
mkdir -p ~/app &amp;&amp; cd $_
wget https://goagent.googlecode.com/archive/3.0.zip
7za x 3.0.zip
mv goagent-* goagent

# setup your gea
vim goagent/local/proxy.ini

# and run
python2.7  goagent/local/goagent-gtk.py &amp;
</code></pre><h2>Install chrome</h2><pre><code class="language-bash"># Setup wget proxy for download chrome
# append the proxy setting to &#x27;/etc/wgetrc&#x27;
# Reamove it, when you do not need this
https_proxy = http://127.0.0.1:8087/
http_proxy = http://127.0.0.1:8087/
ftp_proxy = http://127.0.0.1:8087/
use_proxy = on

# Install google-chrome
# fllow this http://chrome.richardlloyd.org.uk/
mkdir -p ~/app &amp;&amp; cd $_
wget http://chrome.richardlloyd.org.uk/install_chrome.sh
chmod u+x install_chrome.sh
./install_chrome.sh
</code></pre><h2>Install gvim7.4</h2><pre><code class="language-bash">mkdir -p ~/src &amp;&amp; cd $_
wget ftp://ftp.vim.org/pub/vim/unix/vim-7.4.tar.bz2
tar -jxvf vim-7.4.tar.bz2
#
yum install lua lua-devel -y
yum install libX11 libX11-devel libXt-devel libgtk2 libgtk2-devel -y
#
VIM_FLAG=&#x27;--enable-luainterp=yes --enable-cscope --enable-multibyte --enable-fontset --enable-gui&#x27;
#
./configure $VIM_FLAG
make -j 8 &amp;&amp; make test -j 8 &amp;&amp; make install
</code></pre><h2>Install vim</h2><pre><code class="language-bash"># 直接使用yum搜索到的 为了使用简单
yum install vim-enhanced -y
</code></pre><h2>Install Nvidia-driver</h2><pre><code class="language-bash"># find out you card info
lspic | grep VGA
# download form nvidia http://www.nvidia.in/Download/index.aspx

# prepare
yum update
yum clean all
yum groupinstall &quot;Development Tools&quot;
yum install kernel-devel kernel-headers gcc make

added the following line to /etc/modprobe.d/blacklist.conf file
</code></pre><h2>Bully + Aircrack-ng + Reaver</h2><blockquote><p><a href="https://reaver-wps.googlecode.com/files/reaver-1.4.tar.gz">reaver</a> &gt; <a href="http://download.aircrack-ng.org/aircrack-ng-1.2-beta1.tar.gz">aircrack-ng-1.2-beta1</a>
reaver 的替代 <a href="https://github.com/bdpurcell/bully">bully</a></p></blockquote><pre><code class="language-bash"># 准备工作
yum install -y libpcap libpcap-devel openssl-devel sqlite sqlite-devel
# 这个libnl 是用来支持 netlink (nl80211) 的
yum install -y libnl libnl-devel

# 先搞好 bully
curl -L -o bully.zip https://github.com/bdpurcell/bully/archive/master.zip
7za x bully.zip
cd bully-master/src
make
make install
cd -

# 再搞 Aircrack-ng
# 我安装时 最高版本为 1.2-beta3
# 这里需要注意的是, aircrack-ng 被墙了,至少我下载的时候是的
# 我是放在共享目录里拷贝过来的
# 也可以从 github 下载
# https://github.com/aircrack-ng/aircrack-ng
wget -O aircrack-ng.tar.gz http://download.aircrack-ng.org/aircrack-ng-1.2-beta3.tar.gz
tar -xvf aircrack-ng.tar.gz
cd aircrack-ng-*
# 安装过程可以参考这里
# http://www.aircrack-ng.org/doku.php?id=install_aircrack#installing_aircrack-ng_from_source
make sqlite=true
sudo make install
# 更新 OUI
sudo airodump-ng-oui-update

# 安装 reaver, 虽然有bully,但是reaver还是蛮不错的
wget https://reaver-wps.googlecode.com/files/reaver-1.4.tar.gz
tar -xzvf reaver-*.tar.gz
cd reaver-*/src
./configure
make
make install
</code></pre><h2>pin creack</h2><pre><code class="language-bash">ifconfig wlan0 down
# 这里会提示一些有可能被影响的进程 dhclient 和 wpa_supplicant
# 可以考虑将这些进程关闭
airmon-ng start wlan0
bully -e 热点名字 -v3 mon0

# 使用 reaver 的方法
wash -i mon0
reaver -a -S -vv -i mon0 -b `MAC`
</code></pre><h2>通过命令行连接无线网, 简单版</h2><p>来自 <a href="http://www.ghacks.net/2009/04/14/connect-to-a-wireless-network-via-command-line/">connect-to-a-wireless-network-via-command-line</a></p><pre><code class="language-bash">#! /bin/bash
ifconfig wlan0
iwconfig wlan0 essid NETWORK_ID key WIRELESS_KEY
dhclient wlan0
</code></pre><p><code>NETWORK_ID</code> 为无线名
<code>WIRELESS_KEY</code> 搞不清楚,应该是密码吧. 默认为 16 进制的值,可以用 <code>s:WIRELESS_KEY</code> 来使用 ascii</p><h2>通过命令行连接无线网</h2><p>来自 <a href="http://linuxcommando.blogspot.com/2013/10/how-to-connect-to-wpawpa2-wifi-network.html">how-to-connect-to-wpawpa2-wifi-network</a></p><p>需要使用的工具
<code>yum install wpa_supplicant wireless-tools -y</code></p><pre><code class="language-bash"># 1. 查看你的无线设备名
$iw dev
phy#0
    Interface wlan0
        ifindex 3
        type managed
# 2. 检查无线设备是否启用 里面需要有个UP
$ ip link show wlan0
3: wlan0: (BROADCAST,MULTICAST) mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000
    link/ether 74:e5:43:a1:ce:65 brd ff:ff:ff:ff:ff:ff
# 启用无线设备
$ ip link set wlan0 up

# 检查无线设备是否启用 里面有个UP
$ ip link show wlan0
3: wlan0: (NO-CARRIER,BROADCAST,MULTICAST,UP) mtu 1500 qdisc mq state DOWN mode DEFAULT qlen 1000
    link/ether 74:e5:43:a1:ce:65 brd ff:ff:ff:ff:ff:ff

# 3. 检查连接状态
$ /sbin/iw wlan0 link
Not connected.

# 4. 扫描网络
$ sudo /sbin/iw wlan0 scan
BSS 00:14:d1:9c:1f:c8 (on wlan0)
        ... 略过 ...
    freq: 2412
    SSID: Touch-me
    RSN:     * Version: 1
         * Group cipher: CCMP
         * Pairwise ciphers: CCMP
         * Authentication suites: PSK
         * Capabilities: (0x0000)
        ... 略过 ...

# 这里的 SSID 和 安全协议类型很重要
# 这里是 RSN, 即 wpa2

# 5. 连接到 WPA/WPA2 wifi

$ wpa_passphrase 无线名称 &gt;&gt; /etc/wpa_supplicant.conf
无线密码

# 正确的应该是这样的
$ cat /etc/wpa_supplicant.conf
# reading passphrase from stdin
network={
    ssid=&quot;gorilla&quot;
    #psk=&quot;testtest&quot;
    psk=4dfe1c985520d26a13e932bf0acb1d4580461dd854ed79ad1a88ec221a802061
}

# 连接
$ sudo wpa_supplicant -B -D wext -i wlan0 -c /etc/wpa_supplicant.conf
# -B 在后台运行
# -D 指定无线设为, wext为普通无线设备
# -c 配置文件路径

# 检查是否连接
$ /sbin/iw wlan0 link
Connected to 00:14:d1:9c:1f:c8 (on wlan0)
    SSID: gorilla
    freq: 2412
    RX: 63825 bytes (471 packets)
    TX: 1344 bytes (12 packets)
    signal: -27 dBm
    tx bitrate: 6.5 MBit/s MCS 0

    bss flags:  short-slot-time
    dtim period:    0
    beacon int: 100
# 6. 通过 DHCP 获取 IP地址
$ sudo dhclient wlan0
# 有时候无法获取 可以考虑 dhclient -x 关闭后从新获取

# 查看 IP 地址
$ ip addr show wlan0
3: wlan0:  mtu 1500 qdisc mq state UP qlen 1000
    link/ether 74:e5:43:a1:ce:65 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.113/24 brd 192.168.1.255 scope global wlan0
    inet6 fe80::76e5:43ff:fea1:ce65/64 scope link
       valid_lft forever preferred_lft forever

# 7. 添加默认路由规则(可略过)
$ ip route show
192.168.1.0/24 dev wlan0  proto kernel  scope link  src 192.168.1.113

#  这条规则是转发 (192.168.1.*) 到 wlan0,如果你想添加其他的 可以用以下方法
$ sudo ip route add default via 192.168.1.254 dev wlan0
$ ip route show
default via 192.168.1.254 dev wlan0
192.168.1.0/24 dev wlan0  proto kernel  scope link  src 192.168.1.113

# 8. 测试是否正确连接
$ ping 8.8.8.8
</code></pre><h2>自动连接无线的配置</h2><p>参考官方的 <a href="http://wiki.centos.org/HowTos/Laptops/WpaSupplicant">wpa_supplicant 配置</a>
这里没有提到给 wlan0 配置自动的 dhcp</p><p>感觉上
<code>echo BOOTPROTO=dhcp | sudo tee -a /etc/sysconfig/network-scripts/ifcfg-wlan0</code>
这样就可以了~但是还是不行,还是要 <code>dhclient wlan0</code></p><p>需要参考 <a href="http://www.centos.org/docs/5/html/Deployment_Guide-en-US/s1-networkscripts-interfaces.html">这个</a> 来配置.也可以参考<a href="http://www.linuxhomenetworking.com/wiki/index.php/Quick_HOWTO_:_Ch13_:_Linux_Wireless_Networking#.U0YCk_mSyR0">这个</a>来配置.</p><pre><code># 调试
wp _supplicantwpaa_supplicant -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf -d
</code></pre><h2>忘记密码</h2><p>在 <code>grub</code> 启动的时候, 中断自动启动, 看到选择列表的时候, 按 <code>a</code>, 删除 <code>rhgb quiet</code> 然后输入 <code>1</code> 回车, 即可进入单用户模式. 随后使用 passwd 修改完成密码后重启就可以回到多用户模式了.</p><p>参考 <a href="http://wiki.centos.org/TipsAndTricks/ResetRootPassword">ResetRootPassword</a></p><h1>安装开发环境</h1><h2>Install JDK</h2><p>考虑需要安装的 jdk 发布商, 选择 openJDK 还是 oracle 的 jdk
可参考这里<a href="https://launchpad.net/~webupd8team/+archive/java">webupd8</a> 来安装 oracle 的 jdk.
或者参考<a href="http://d.stavrovski.net/blog/post/how-to-install-and-setup-oracle-java-jdk-in-centos-6">这个</a>安装步骤,还可以参考<a href="https://wiki.powerfolder.com/display/PFS/Installing+Oracle+Java+on+Linux">这里</a></p><pre><code># 查看 repo 中支持的 jdk 版本, 一般 centos 的repo中只有 openjdk
yum search java-1
# 确保系统中没有 已经安装
rpm -qa | grep java-
# 如果有的话 则删除syum remove java-1.6.0-openjdkayn`
</code></pre><p>我选择的手<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">动下</a>载 oracle 的 jdk,毕竟 oracle 的 jdk 更稳定些.</p><p>我安装 JDK8 的下载地址
<a href="http://download.oracle.com/otn-pub/java/jdk/8u5-b13/jdk-8u5-linux-x64.rpm">http://download.oracle.com/otn-pub/java/jdk/8u5-b13/jdk-8u5-linux-x64.rpm</a></p><pre><code class="language-bash">wget --no-check-certificate --no-cookies \
    --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot;\
    &quot;http://download.oracle.com/otn-pub/java/jdk/8u5-b13/jdk-8u5-linux-x64.rpm&quot;
rpm -Uvh jdk-*.rpm
</code></pre><h2>Install nodejs</h2><pre><code class="language-bash">mkdir -p ~/src &amp;&amp; cd $_
wget -e &quot;http_proxy = http://127.0.0.1:8087/&quot;  http://nodejs.org/dist/node-latest.tar.gz
tar zxvf node-latest.tar.gz
./configure
make &amp;&amp; make install
# Already installed npm with nodejs source
</code></pre><h2>Install nginx</h2><pre><code class="language-bash"># add nginx repo
cat &gt; /etc/yum.repos.d/nginx.repo &lt;&lt;WEN
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=0
enabled=1
WEN
# check
yum repolist
# install
yum install nginx -y
</code></pre><h2>Install php</h2><pre><code class="language-bash">yum groupinstall &#x27;PHP Support&#x27;
</code></pre><h1>安装服务</h1><h2>Install vsftpd</h2><pre><code class="language-bash"># 确定有
yum search vsftpd
</code></pre><h2>Install openssh-server</h2><pre><code class="language-bash"># 参考 http://www.centos.org/docs/5/html/Deployment_Guide-en-US/s1-openssh-server-config.html
yum install openssh-server -y
# 配置文件为 /etc/ssh/sshd_config
# 启动
/sbin/service sshd start
# 从主机连接
# ssh 用户名@该linux机器的IP
</code></pre><h2>Install tomcat</h2><pre><code class="language-bash">tar -zxvf apache-tomcat*.tar.gz
mv apache-tomcat* /opt/tomcat
# 启动
/opt/tomcat/bin/startup.sh
# 配置 iptable, 使外部可以访问
# 查看目前的 IPTables 设置
iptables -nL --linenumber
# 确保插入在 REJECT any 前面, 5 为行号 根据个人的情况修改
iptables -I INPUT 5 -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT -m comment --comment &quot;Tomcat Server port&quot;
service iptables save
</code></pre><h2>Install hadoop</h2><p>参考<a href="http://tecadmin.net/steps-to-install-hadoop-on-centosrhel-6/">这里</a></p><h2>Install apache</h2><p><a href="https://www.centos.org/docs/5/html/Cluster_Administration/s1-apache-inshttpd-CA.html">apache-inshttpd</a></p><pre><code class="language-bash">yum install httpd
# 完成后 需要在 /etc/httpd/conf/httpd.conf 中添加一句
# ServerName localhost
# 如果想要使用 apachectl status 命令 需要 elinks 和 mod_status
# 关于使用 status 出现错误的情况 参考
# http://www.mydigitallife.info/request-url-server-status-or-404-page-not-found-apache-error/
</code></pre><p>想要使用 apachectl status 在 httpd.conf 中添加如下配置</p><pre><code class="language-bash">ExtendedStatus on
&lt;IfModule mod_status.c&gt;
    # Allow server status reports generated by mod_status,
    # with the URL of http://servername/server-status
    # Change the &quot;.example.com&quot; to match your domain to enable.
    #
    &lt;Location /server-status&gt;
        SetHandler server-status
        Order deny,allow
        Allow from all
    &lt;/Location&gt;
&lt;/IfModule&gt;
</code></pre><h3>配置 mod_jk</h3><pre><code class="language-bash"># 使用的时候 只有 1.2.40 版本
# 可以查看其他版本 http://www.apache.org/dist/tomcat/tomcat-connectors/jk/
wget http://www.apache.org/dist/tomcat/tomcat-connectors/jk/tomcat-connectors-1.2.40-src.zip
unzip tomcat-connectors*.zip
cd tomcat-connectors*
cd native
# 这里有点扯淡的是 这些脚本都是dos 格式的 所以需要先 dos2unix
# 所以我直接换了个版本 使用的 1.2.39 的, 代码格没问题
yum install -y httpd-devel
./configure --with-apxs=/usr/sbin/apxs
make
make install
</code></pre><p>集群配置完成个可以通过刷新 http://cloud01/manager/status 这个页面, 观察 IP address 来判断是否成功.</p><h2>Install MySQL</h2><pre><code class="language-bash">yum -y groupinstall &#x27;MySQL Database server&#x27; &#x27;MySQL Database client&#x27;
yum -y install php-mysql
#/sbin/service mysqld start
#/sbin/service mysqld stop
#/sbin/service mysqld restart
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[消息中间件简介 mom-intro]]></title>
            <link>https://wener.me/story/mom-intro</link>
            <guid>mom-intro</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[同步]]></description>
            <content:encoded><![CDATA[<h2>同步</h2><p>分布式对象技术(Distributed Object Technologies - DOT), 远程过程调用 RPC: 同步操作 (调用被阻塞,直到被调用者返回).</p><pre><code class="language-sequence">title: 简单的远程调用
客户端-&gt;&gt;服务端: 1.远程调用
Note right of 服务端: 2.服务器处理请求
Note left of 客户端: 客户端被阻塞
服务端--&gt;&gt;客户端: 3. 调用返回
</code></pre><pre><code class="language-sequence">title: 带回调的远程调用
客户端-&gt;&gt;服务端: 1.远程调用
Note right of 服务端: 2.服务器处理请求
Note left of 客户端: 客户端被阻塞
服务端-&gt;&gt;客户端: 3. 回调
客户端--&gt;&gt;服务端: 4. 回调返回
服务端--&gt;&gt;客户端: 5. 返回远程调用
</code></pre><p>该种模式引发的问题:</p><ol><li>客户端会一直被阻塞,直到服务(对象操作)返回(紧耦合).</li><li>过度的链接(每次调用都需要一个链接来进行处理和网络访问等).</li><li>很难对调用失败做出响应(调用的服务可能抛出异常,可能服务未启动等...).</li><li>不适用于嵌套调用(服务对象调用客户端的对象又需要引入另外一个服务对象的操作).</li></ol><h2>异步</h2><p>消息中间件 (Message Oriented Middleware - MOM)</p><ul><li>异步操作(调用者发送一个消息,然后继续工作,&quot;fire and forget&quot;)</li><li>存储,转发通信</li><li>发送和接收之间是松耦合的<ol><li>不需要在同一时间存活</li><li>发送者不需要知道接收者的具体位置,反之亦然.</li></ol></li></ul><pre><code class="language-sequence">发送应用-&gt;发送队列:非阻塞消息发送操作
发送队列-&gt;网络
网络-&gt;接收队列
接收队列-&gt;接收应用
</code></pre><p>类比:</p><p>同步(RPC/DOT) -&gt; 电话
异步(MOM) -&gt; 邮件</p><h1>2. 消息模型</h1><ol><li>点到点 (P2P - Point to Point) {#ch-2-1}</li></ol><hr/><ul><li>每个接收者(应用)一个队列</li><li>一对一(1 个发送者,一个接收者)或者多对一(多个发送者,一个接收者)的消息机制.</li></ul><ol start="2"><li>发布-订阅 (PubSub - Publish - Subscribe) {#ch-2-2}</li></ol><h1>3. 队列类型</h1><ul><li>所有的消息都有相同的优先级</li><li>消息以他们发送的顺序进行分发</li></ul><pre><code class="language-sequence">Note over 先进先出队列: 发送应用
Note over 先进先出队列: 消息 3
Note over 先进先出队列: 消息 2
Note over 先进先出队列: 消息 1
Note over 先进先出队列: 消息队列
Note over 先进先出队列: 消息 3
Note over 先进先出队列: 消息 2
Note over 先进先出队列: 消息 1
Note over 先进先出队列: 接收应用
</code></pre><h2>优先级队列</h2><ul><li>消息缓存在 FIFO 队列中,并以优先级进行排序</li><li>该排序会应用在已经接收到的消息上</li></ul><pre><code class="language-sequence">Note over 优先级队列: 发送应用
Note over 优先级队列: 消息 3 优先级 1
Note over 优先级队列: 消息 2 优先级 3
Note over 优先级队列: 消息 1 优先级 2
Note over 优先级队列: 消息队列 - 根据消息的优先级从排序
Note over 优先级队列: 消息 2 优先级 3
Note over 优先级队列: 消息 1 优先级 2
Note over 优先级队列: 消息 3 优先级 1
Note over 优先级队列: 接收应用
</code></pre><h2>共有/私有队列</h2><ul><li>定义不同的访问权限<ol><li>共有队列: 所有发送者均能发送消息,不需要访问控制</li><li>私有队列: 发送者发送到私有队列需要进行认证</li></ol></li></ul><h2>其他类型队列</h2><p>日志队列
: 消息系统会保存一个该队列的副本,达到日志记录或监控的目的</p><p>Dead-letter 队列
: 该队列会持有所有无法分发的消息(因为 TTL 过时的消息或队列地址无法解析的消息).</p><p>桥接和连接器队列(Bridge/connector queue)
: 连接不同的队列系统,例如: MSMQ, JMS</p><h1>4. 消息中转(Message broker) - 应用集成模式</h1><p>Message broker 将消息分发给接收者</p><h1>参考</h1><ul><li>原文 <a href="http://www.slideshare.net/PeterREgli/mom-message-oriented-middleware">http://www.slideshare.net/PeterREgli/mom-message-oriented-middleware</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[一致性Hash算法]]></title>
            <link>https://wener.me/story/ketama-consistence-hash</link>
            <guid>ketama-consistence-hash</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[该算法最开始是开发来替代memcached键到服务器的映射算法的.]]></description>
            <content:encoded><![CDATA[<p>该算法最开始是开发来替代<code>memcached</code>键到服务器的映射算法的.</p><p>在这之前,客户端映射键到服务器的方法类似于:
<code> server = serverlist[hash(key)%serverlist.length];</code>
这就意味着,不管我们从池中增加或删除节点,都会导致所有已经 hash 的值从新 hash 到不同的节点,这会导致所有<code>memcached</code>的所有缓存失效.</p><p>Ketama 使用以下方式来解决了该问题:</p><ul><li>使用指定的一组服务(例如: 1.2.3.4:11211, 5.6.7.8:11211, 9.8.7.6:11211)</li><li>将每个服务的字符串都 hash 为多个(100-200 个)无符号整数</li><li>概念上,这些数字是放置在一个环上的.(想象一个时钟那样,从 0 - 2^32 次方的一个环)</li><li>每个数组都关联它 hash 之前的那个服务器地址,因此,一个服务会在环上出现多次.出现的方式会以他们 hash 后的数字来表示</li><li>为了将一个键映射到服务器,首先将键值 hash 为一个无符号整数,然后在环上找到下一个最大的数字.该服务会被选择来存放该键值</li><li>如果 hash 的键值接近 2^32 次方,那么可能在环上没有比该 hash 值大的的 hash,此时返回环上的第一个服务.</li></ul><p>这样实现以后,在该服务列表上进行添加和删除只会对一小部分的键值映射产生影响,因此只需要从新映射一小部分值.</p><p>此外,如果想要控制服务器的权重,则可以通过增加该服务的 hash 值数量来实现.</p><p><em>原文</em></p><p>This was initially written to replace how our memcached clients mapped keys to servers.</p><p>Previously, clients mapped keys-&gt;servers like this:
<code> server = serverlist[hash(key)%serverlist.length];</code></p><p>This meant that whenever we added or removed servers from the pool, everything hashed to different servers, which effectively wiped the entire cache.</p><p>Ketama solves this problem in the following way:</p><ul><li>Take your list of servers (eg: 1.2.3.4:11211, 5.6.7.8:11211, 9.8.7.6:11211)</li><li>Hash each server string to several (100-200) unsigned ints</li><li>Conceptually, these numbers are placed on a circle called the continuum. (imagine a clock face that goes from 0 to 2^32)</li><li>Each number links to the server it was hashed from, so servers appear at several points on the continuum, by each of the numbers they hashed to.</li><li>To map a key-&gt;server, hash your key to a single unsigned int, and find the next biggest number on the continuum. The server linked to that number is the correct server for that key.</li><li>If you hash your key to a value near 2^32 and there are no points on the continuum greater than your hash, return the first server in the continuum.</li></ul><p>If you then add or remove a server from the list, only a small proportion of keys end up mapping to different servers.</p><h2>参考</h2><ul><li><a href="http://www.audioscrobbler.net/development/ketama/">原文</a></li><li><a href="https://github.com/RJ/ketama/blob/master/java_ketama/SockIOPool.java">参考 Java 实现</a></li><li><a href="http://en.wikipedia.org/wiki/Consistent_hashing">维基百科 Consistent hashing</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Ubuntu 新服务器配置]]></title>
            <link>https://wener.me/story/ubuntu-new-server</link>
            <guid>ubuntu-new-server</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[* How I spend my first 5 minutes on a server]]></description>
            <content:encoded><![CDATA[<pre><code class="language-bash"># 修改主机名
hostnamectl set-hostname myHostName
# 如果想要直接使用主机名,还需要在 /etc/hosts 里添加相关记录
# nano /etc/hostname
# nano /etc/hosts

# 生成中文
locale-gen zh_CN.UTF-8
# 基本更新
apt-get update
apt-get upgrade

# 出现 The following packages have been kept back 可考虑 apt dist-upgrade 或 install
# 当 /etc/apt/sources.list* 有其他仓库时使用 dist-upgrade 相对没那么安全

# 修改密码
passwd


# 创建用于部署的用户
useradd deploy
mkdir /home/deploy
mkdir /home/deploy/.ssh
chmod 700 /home/deploy/.ssh
# 将需要使用该用户的公钥添加进去
vim /home/deploy/.ssh/authorized_keys

chmod 400 /home/deploy/.ssh/authorized_keys
chown deploy:deploy /home/deploy -R

# 编辑 sudoers
visudo
# 将需要 sudo 的用户添加进去
# deploy  ALL=(ALL) ALL

# 修改 sshd 权限
vim /etc/ssh/sshd_config
# PermitRootLogin no # 不允许直接 root 登陆
# PasswordAuthentication no # 不允许密码登陆
# AllowUsers deploy@(your-ip) deploy@(another-ip-if-any) # 只允许指定地址的人登陆
# service ssh restart

# 防火墙设置
# DNS 53
# mosh allow 60000:61000/udp 或 allow mosh
ufw allow 22
ufw allow 80
ufw allow 443
ufw default deny
ufw enable
</code></pre><ul><li><a href="https://news.ycombinator.com/item?id=5316093">How I spend my first 5 minutes on a server </a></li><li><a href="https://www.upguard.com/blog/10-essential-steps-for-configuring-a-new-server">10 Essential Steps for Configuring a New Server</a></li></ul><h2>Tips</h2><p>当有多台主机需要部署的时候,建议使用 sshrc, tmuxrc, 这样能快速的将所有的配置都带给服务器,能够快速方便的对多台进行安装部署.</p><h3>mosh-dev</h3><p>由于 mosh 部分鼠标相关的功能需要最新版,所以建议直接安装 dev 版本</p><pre><code class="language-bash">apt-get install -y software-properties-common
add-apt-repository ppa:keithw/mosh-dev
apt-get update
apt install -y mosh
</code></pre><h2>fail2ban</h2><pre><code class="language-bash">apt-get install fail2ban
cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
# bantime = 3600 # ban 1 小时
# destemail = admin@admin # 发送警告的邮箱地址
# 将 ssh/ssh-ddos 等段落下的 enable 设置为 true 打开相应的 filter
</code></pre><h2>env</h2><pre><code class="language-bash">apt-get install software-properties-common
# 添加 Oracle Java 仓库
add-apt-repository ppa:webupd8team/java#
apt-get update
# 安装 Oracle Java 8 JDK
apt-get install oracle-java8-installer
# 如果有多个 Java 环境可调整配置
update-alternatives --config java
</code></pre><h2>ipv6</h2><pre><code class="language-bash"># https://jiandanxinli.github.io/2016-08-06.html

# /etc/sysctl.conf
# net.ipv6.conf.all.disable_ipv6=0
# net.ipv6.conf.default.disable_ipv6=0
# net.ipv6.conf.lo.disable_ipv6=0
sysctl -p

# https://www.tunnelbroker.net/
# 选择 linux route2, 然后执行脚本

# 检测 ipv6 是否可用
# http://ready.chair6.net/?url=wener.me

# 如果操作失败了则删除通道从来
ip tun del he-ipv6
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[进击的程序猿]]></title>
            <link>https://wener.me/story/attack-on-programmer</link>
            <guid>attack-on-programmer</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[2016 年会节目]]></description>
            <content:encoded><![CDATA[<p>2016 年会节目</p><ul><li><a href="https://github.com/wenerme/wener/tree/master/story/2017/am2016/%E8%BF%9B%E5%87%BB%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%8C%BF.fountain">脚本</a>/<a href="https://github.com/wenerme/wener/tree/master/story/2017/am2016/%E8%BF%9B%E5%87%BB%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%8C%BF.pdf">PDF</a></li><li>舞台前端/舞台后端</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Ubuntu 家用]]></title>
            <link>https://wener.me/story/ubuntu-home</link>
            <guid>ubuntu-home</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[- Ubuntu 桌面版]]></description>
            <content:encoded><![CDATA[<ul><li>Ubuntu 桌面版</li><li>安装至少需要 <code>1024*768</code> 的显示器</li></ul><pre><code class="language-bash">apt update
apt upgrade
apt dist-upgrade

# 桌面版没有 sshd
apt install -y openssh-server

############
# brew
############
brew install gcc redis tmux mosh

############
# 容器服务配置
############
# 使用阿里提供的仓库进行安装会非常快
curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -
# 安装完毕后为当前用户添加权限,需要退出重新登录才能生效
sudo usermod -aG docker $USER

# 安装完成建议选择一家容器镜像,比如 https://cr.console.aliyun.com 或者 daocloud

docker pull gogs/gogs
docker network create --subnet=172.18.1.0/24 home-net

# 准备数据目录
sudo mkdir /data
sudo chown $USER:$USER /data
cd /data

# ==========
# 监控配置
# ==========
docker pull grafana/grafana
docker pull prom/container-exporter
docker pull prom/prometheus

docker run --net home-net --ip 172.18.1.10 -d --restart always -v /etc/localtime:/etc/localtime:ro \
    -v $PWD/grafana:/var/lib/grafana \
    -v $PWD/grafana.ini:/etc/grafana/grafana.ini \
    --name grafana grafana/grafana

nohup node_exporter 2&gt;node_exporter.log &amp;

docker run -d --net home-net --ip 172.18.1.21 \
    -v /sys/fs/cgroup:/cgroup \
    -v /var/run/docker.sock:/var/run/docker.sock \
    --name container-exporter prom/container-exporter

docker run --net home-net --ip 172.18.1.20 -d --restart always -v /etc/localtime:/etc/localtime:ro \
    -v $PWD/prom:/prometheus \
    -v $PWD/prom.yaml:/etc/prometheus/prometheus.yml \
    --name prom prom/prometheus

# Web 服务
# 选择需要的 Caddy 插件用于构建容器
mkdir -p /tmp/caddy &amp;&amp; cd /tmp/caddy
wget &#x27;https://caddyserver.com/download/build?os=linux&amp;arch=amd64&amp;features=cors%2Cexpires%2Cfilemanager%2Cgit%2Chugo%2Cipfilter%2Cjsonp%2Cjwt%2Clocale%2Cmailout%2Cminify%2Cmultipass%2Cprometheus%2Cratelimit%2Crealip%2Csearch%2Cupload&#x27; -O caddy.tar.gz
tar -zxvf caddy.tar.gz

docker build -t home/caddy -f caddy.Dockerfile .
cd -

docker run --net home-net --ip 172.18.1.30  -d --restart always -v /etc/localtime:/etc/localtime:ro \
    -v $PWD/Caddyfile:/etc/Caddyfile \
    -v $PWD/caddy:/data \
    -v $HOME/.caddy:/root/.caddy \
    -p 80:80 -p 443:443 \
    --name web home/caddy



</code></pre><h3>caddy.Dockerfile</h3><pre><code class="language-Dockerfile">FROM alpine
MAINTAINER wener &lt;wener@wener.me&gt;

COPY caddy /app/caddy

VOLUME     [ &quot;/data&quot; ]
WORKDIR    /data

EXPOSE 2015
EXPOSE 2000
ENTRYPOINT [&quot;/app/caddy&quot;]
CMD [&quot;-conf&quot;,&quot;/etc/Caddyfile&quot;,&quot;-log&quot;,&quot;./internal/log&quot;]
</code></pre><h3>grafana.ini</h3><pre><code class="language-ini">##################### Grafana Configuration Example #####################
#
# Everything has defaults so you only need to uncomment things you want to
# change

# possible values : production, development
; app_mode = production

# instance name, defaults to HOSTNAME environment variable value or hostname if HOSTNAME var is empty
; instance_name = ${HOSTNAME}

#################################### Paths ####################################
[paths]
# Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used)
#
;data = /var/lib/grafana
#
# Directory where grafana can store logs
#
;logs = /var/log/grafana
#
# Directory where grafana will automatically scan and look for plugins
#
;plugins = /var/lib/grafana/plugins

#
#################################### Server ####################################
[server]
# Protocol (http or https)
;protocol = http

# The ip address to bind to, empty will bind to all interfaces
;http_addr =

# The http port  to use
;http_port = 3000

# The public facing domain name used to access grafana from a browser
domain = d.yikaiye.com

# Redirect to correct domain if host header does not match domain
# Prevents DNS rebinding attacks
;enforce_domain = false

# 使用 /monitor 作为路径,以便于反向代理
;root_url = %(protocol)s://%(domain)s:%(http_port)s/
root_url = /monitor

# Log web requests
;router_logging = false

# the path relative working path
;static_root_path = public

# enable gzip
enable_gzip = true

# https certs &amp; key file
;cert_file =
;cert_key =

#################################### Database ####################################
[database]
# Either &quot;mysql&quot;, &quot;postgres&quot; or &quot;sqlite3&quot;, it&#x27;s your choice
;type = sqlite3
;host = 127.0.0.1:3306
;name = grafana
;user = root
;password =

# For &quot;postgres&quot; only, either &quot;disable&quot;, &quot;require&quot; or &quot;verify-full&quot;
;ssl_mode = disable

# For &quot;sqlite3&quot; only, path relative to data_path setting
;path = grafana.db

#################################### Session ####################################
[session]
# Either &quot;memory&quot;, &quot;file&quot;, &quot;redis&quot;, &quot;mysql&quot;, &quot;postgres&quot;, default is &quot;file&quot;
;provider = file

# Provider config options
# memory: not have any config yet
# file: session dir path, is relative to grafana data_path
# redis: config like redis server e.g. `addr=127.0.0.1:6379,pool_size=100,db=grafana`
# mysql: go-sql-driver/mysql dsn config string, e.g. `user:password@tcp(127.0.0.1:3306)/database_name`
# postgres: user=a password=b host=localhost port=5432 dbname=c sslmode=disable
;provider_config = sessions

# Session cookie name
;cookie_name = grafana_sess

# If you use session in https only, default is false
;cookie_secure = false

# Session life time, default is 86400
;session_life_time = 86400

#################################### Analytics ####################################
[analytics]
# Server reporting, sends usage counters to stats.grafana.org every 24 hours.
# No ip addresses are being tracked, only simple counters to track
# running instances, dashboard and error counts. It is very helpful to us.
# Change this option to false to disable reporting.
;reporting_enabled = true

# Set to false to disable all checks to https://grafana.net
# for new vesions (grafana itself and plugins), check is used
# in some UI views to notify that grafana or plugin update exists
# This option does not cause any auto updates, nor send any information
# only a GET request to http://grafana.net to get latest versions
check_for_updates = true

# Google Analytics universal tracking code, only enabled if you specify an id here
;google_analytics_ua_id =

#################################### Security ####################################
[security]
# default admin user, created on startup
;admin_user = admin

# default admin password, can be changed before first start of grafana,  or in profile settings
;admin_password = admin

# used for signing
;secret_key = SW2YcwTIb9zpOOhoPsMm

# Auto-login remember days
;login_remember_days = 7
;cookie_username = grafana_user
;cookie_remember_name = grafana_remember

# disable gravatar profile images
;disable_gravatar = false

# data source proxy whitelist (ip_or_domain:port separated by spaces)
;data_source_proxy_whitelist =

[snapshots]
# snapshot sharing options
external_enabled = false
;external_snapshot_url = https://snapshots-origin.raintank.io
;external_snapshot_name = Publish to snapshot.raintank.io

#################################### Users ####################################
[users]
# 禁用注册功能
allow_sign_up = false

# 不允许非管理员创建组织
allow_org_create = false

# Set to true to automatically assign new users to the default organization (id 1)
auto_assign_org = true

# Default role new users will be automatically assigned (if disabled above is set to true)
auto_assign_org_role = Viewer

# Background text for the user field on the login page
login_hint = 用户名

# Default UI theme (&quot;dark&quot; or &quot;light&quot;)
default_theme = light

#################################### Anonymous Auth ##########################
[auth.anonymous]
# enable anonymous access
enabled = false

# specify organization name that should be used for unauthenticated users
;org_name = Main Org.

# specify role for unauthenticated users
;org_role = Viewer

#################################### Auth Proxy ##########################
[auth.proxy]
;enabled = false
;header_name = X-WEBAUTH-USER
;header_property = username
;auto_sign_up = true

#################################### Basic Auth ##########################
[auth.basic]
;enabled = true

#################################### SMTP / Emailing ##########################
[smtp]
;enabled = false
;host = localhost:25
;user =
;password =
;cert_file =
;key_file =
;skip_verify = false
;from_address = admin@grafana.localhost

[emails]
;welcome_email_on_sign_up = false

#################################### Logging ##########################
[log]
# Either &quot;console&quot;, &quot;file&quot;, &quot;syslog&quot;. Default is console and  file
# Use space to separate multiple modes, e.g. &quot;console file&quot;
;mode = console, file

# Either &quot;trace&quot;, &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;critical&quot;, default is &quot;info&quot;
;level = info

# For &quot;console&quot; mode only
[log.console]
;level =

# log line format, valid options are text, console and json
;format = console

# For &quot;file&quot; mode only
[log.file]
;level =

# log line format, valid options are text, console and json
;format = text

# This enables automated log rotate(switch of following options), default is true
;log_rotate = true

# Max line number of single file, default is 1000000
;max_lines = 1000000

# Max size shift of single file, default is 28 means 1 &lt;&lt; 28, 256MB
;max_size_shift = 28

# Segment log daily, default is true
;daily_rotate = true

# Expired days of log file(delete after max days), default is 7
;max_days = 7

[log.syslog]
;level =

# log line format, valid options are text, console and json
;format = text

# Syslog network type and address. This can be udp, tcp, or unix. If left blank, the default unix endpoints will be used.
;network =
;address =

# Syslog facility. user, daemon and local0 through local7 are valid.
;facility =

# Syslog tag. By default, the process&#x27; argv[0] is used.
;tag =


#################################### AMQP Event Publisher ##########################
[event_publisher]
;enabled = false
;rabbitmq_url = amqp://localhost/
;exchange = grafana_events

;#################################### Dashboard JSON files ##########################
[dashboards.json]
;enabled = false
;path = /var/lib/grafana/dashboards

#################################### Internal Grafana Metrics ##########################
# Metrics available at HTTP API Url /api/metrics
[metrics]
# Disable / Enable internal metrics
;enabled           = true

# Publish interval
;interval_seconds  = 10

# Send internal metrics to Graphite
; [metrics.graphite]
; address = localhost:2003
; prefix = prod.grafana.%(instance_name)s.

#################################### Internal Grafana Metrics ##########################
# Url used to to import dashboards directly from Grafana.net
[grafana_net]
url = https://grafana.net
</code></pre><h3>prom.yaml</h3><pre><code class="language-yaml">global:
  scrape_interval: 5s
  # Attach these labels to any time series or alerts when communicating with
  # external systems (federation, remote storage, Alertmanager).
  external_labels:
    monitor: &#x27;dev-monitor&#x27;

rule_files:
  - mysql.rules

# A scrape configuration containing exactly one endpoint to scrape:
# Here it&#x27;s Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.
  - job_name: &#x27;prometheus&#x27;

    # Override the global default and scrape targets from this job every 5 seconds.
    scrape_interval: 5s

    static_configs:
      - targets: [&#x27;localhost:9090&#x27;]

  - job_name: container_exporter
    static_configs:
      - targets: [&#x27;172.18.1.21:9104&#x27;]

  - job_name: node_exporter
    static_configs:
      - targets: [&#x27;172.18.1.1:9100&#x27;]

  - job_name: caddy
    static_configs:
      - targets: [&#x27;172.18.1.30:2000&#x27;]
</code></pre><h3>Caddyfile</h3><pre><code>:80 {
  log internal/access.log {
      rotate {
          size 50
          age  14
          keep 10
      }
  }
  prometheus :2000
  root .
  internal ./internal
  filemanager /file {
    show file/
  }
  proxy /monitor 172.18.1.10:3000 {
    without /monitor
    transparent
  }
}
</code></pre><pre><code>
$ sudo vim /etc/udev/rules.d/75-persistent-net-generator.rules

SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, ATTR{address}==&quot;f0:42:1c:85:07:41&quot;, NAME=&quot;eth0&quot;
sudo vim /etc/network/interfaces

</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google API Design Guide]]></title>
            <link>https://wener.me/story/google-api-design-guide</link>
            <guid>google-api-design-guide</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[Google API Design Guide]]></description>
            <content:encoded><![CDATA[<h2>Google API Design Guide</h2><ul><li><a href="https://cloud.google.com/apis/design/">API Design Guide</a></li></ul><h3>面向资源设计</h3><ul><li>设计流程<ul><li>确定 APi 提供的资源类型</li><li>确定资源之间的关系</li><li>决定资源的名字格式, 基于类型和关系</li><li>决定资源的格式</li><li>为资源添加最低限度的方法</li></ul></li><li>资源<ul><li>集合</li><li>资源</li></ul></li><li>方法</li></ul><h3>资源名字</h3><ul><li>基本概念<ul><li>资源是被命名的实体</li><li>资源名即为其标识符</li><li>每个资源必须有其唯一的资源名</li><li>资源名由 资源 ID, 父资源 ID 和服务名</li><li>gRPC 资源名应该使用 scheme-less 的 URI</li><li>集合为特殊的资源, 包含一列相同类型的子资源</li><li>集合资源的 ID 为 集合 ID</li></ul></li><li>完整资源名<ul><li><code>//library.googleapis.com/shelves/shelf1/books/book2</code></li></ul></li><li>相对资源名<ul><li>相对于服务</li><li><code>shelves/shelf1/books/book2</code></li></ul></li><li>资源 ID<ul><li>资源名中的资源 ID 可能会有超过一个的 URI segment</li><li>服务应该使用 URL 友好的资源 ID</li><li>必须要明确资源 ID 是由客户端指定,服务指定或都可以<ul><li>例如文件名通常由客户端指定</li><li>有限 ID 通常由服务端指定</li></ul></li><li>Collection ID -&gt; <code>files</code></li><li>Resource ID -&gt; <code>/source/py/parser.py</code></li></ul></li><li>集合 ID<ul><li>必须是有效的 C/C++ 标识符</li><li>必须是负数的 <code>lowerCamel</code> 形式<ul><li>如果没有合适的负数形式, 那么应该使用单数形式, 例如 <code>evidence</code>,<code>weather</code></li></ul></li><li>必须使用明确简洁的英语词汇</li><li>通用的词汇应该避免使用或加限定符<ul><li><code>values</code> -&gt; <code>rowValues</code></li><li>应该避免直接使用的词汇<ul><li>elements</li><li>entries</li><li>instances</li><li>items</li><li>objects</li><li>resources</li><li>types</li><li>values</li></ul></li></ul></li></ul></li><li>资源名 vs URL<ul><li>在 REST API 使用时, 应该转换为相应的 URL 格式</li><li>添加版本号和 Schema</li><li>资源名 -&gt; <code>//calendar.googleapis.com/users/john smith/events/123</code></li><li>URL -&gt; <code>https://calendar.googleapis.com/v3/users/john%20smith/events/12</code></li></ul></li><li>资源名作为字符串<ul><li>资源名必须能被呈现为字符串</li><li>资源名应该能像文件名一样被处理, 不支持百分号编码</li><li>对于资源定义, 第一个字段应该为资源名, 应该为 <code>name</code></li><li>其他名字相关的字段应该添加限定符避免混淆, 例如 <code>display_name</code>, <code>first_name</code></li><li>资源名禁止包含前 <code>/</code></li></ul></li><li>为什么不适用资源 ID 来标识一个资源<ul><li>例如为什么不使用诸如 <code>(bucket, object)</code> 或 <code>(user, album, photo)</code> 的形式</li><li>开发者必须要理解并且记住这样的匿名元组</li><li>传递元组比字符串一般更加困难</li><li>很多系统不能理解这样的形式</li><li>特点的元组限制 API 设计的灵活性</li></ul></li><li>为什么使用 <code>name</code> 而不使用 <code>id</code><ul><li>遵从资源名的概念</li><li>通常 <code>name</code> 的定义会非常混淆, 保留 <code>name</code> 使得开发者选择一个更合适的名字, 例如 <code>display_name</code>, <code>title</code></li></ul></li></ul><table><thead><tr><th>API Service Name</th><th>Collection ID</th><th>Resource ID</th><th>Collection ID</th><th>Resource ID</th></tr></thead><tbody><tr><td>//storage.googleapis.com</td><td>/buckets</td><td>/bucket-id</td><td>/objects</td><td>/object-id</td></tr></tbody></table><table><thead><tr><th>API Service Name</th><th>Collection ID</th><th>Resource ID</th><th>Resource ID</th><th>Resource ID</th></tr></thead><tbody><tr><td>//mail.googleapis.com</td><td>/users</td><td>/<a href="mailto:name@example.com">name@example.com</a></td><td>/settings</td><td>/customFrom</td></tr></tbody></table><h3>标准方法</h3><table><thead><tr><th>Std.Method</th><th>HTTP Mapping</th><th>HTTP Request Body</th><th>HTTP Response Body</th></tr></thead><tbody><tr><td>List</td><td><code>GET &lt;collection URL&gt;</code></td><td>N/A</td><td>Resource<!-- -->*<!-- --> list</td></tr><tr><td>Get</td><td><code>GET &lt;resource URL&gt;</code></td><td>N/A</td><td>Resource<!-- -->*</td></tr><tr><td>Create</td><td><code>POST &lt;collection URL&gt;</code></td><td>Resource</td><td>Resource<!-- -->*</td></tr><tr><td>Update</td><td><code>PUT or PATCH &lt;resource URL&gt;</code></td><td>Resource</td><td>Resource<!-- -->*</td></tr><tr><td>Delete</td><td><code>DELETE &lt;resource URL&gt;</code></td><td>N/A</td><td>google.protobuf.Empty<!-- -->*<!-- -->*</td></tr></tbody></table><h3>自定义方法</h3><ul><li>HTTP 映射<ul><li><code>https://service.name/v1/some/resource/name:customVerb</code></li><li>应该使用 <code>POST</code> 方法</li><li>如果是类似 List 的方法也许使用 <code>GET</code></li><li>不应该使用 <code>PATCH</code>, 也许会使用其他方法, 但应该遵从 HTTP 语义</li><li>使用 <code>GET</code> 方法, 必须要求请求幂等, 不会有副作用<ul><li>例如自定义视图应该使用 <code>GET</code></li></ul></li><li>请求消息中的资源名应该被映射到路径上</li><li>URL 路径必须以 <code>:customVerb</code> 结束</li><li>如果允许请求体, 必须使用 <code>body: &quot;*&quot;</code>, 应该将所有字段映射到请求消息上</li><li>如果不接受请求体, 禁止使用 <code>body</code> 语句</li><li>自定义的方法动词禁止重叠</li></ul></li></ul><table><thead><tr><th>Method Name</th><th>Custom verb</th><th>HTTP verb</th><th>备注</th></tr></thead><tbody><tr><td>Cancel</td><td>:cancel</td><td>POST</td><td>取消一个未完成的操作 (构建,计算 等)</td></tr><tr><td><code>BatchGet&lt;plural noun&gt;</code></td><td>:batchGet</td><td>GET</td><td>批量获取多个资源</td></tr><tr><td>Move</td><td>:move</td><td>POST</td><td>将资源从父节点移动到另外一个父节点</td></tr><tr><td>Search</td><td>:search</td><td>GET</td><td>获取资源列表, 但不同于 List 语义</td></tr><tr><td>Undelete</td><td>:undelete</td><td>POST</td><td>恢复一个已删除的资源. 建议做 30 天的保留期</td></tr></tbody></table><h3>标准字段</h3><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>name</td><td>string</td><td>包含相对资源名</td></tr><tr><td>parent</td><td>string</td><td>对资源定义和 List/Create 请求, 该字段表示相对的父节点资源名</td></tr><tr><td>create_time</td><td>Timestamp</td><td>创建时间</td></tr><tr><td>update_time</td><td>Timestamp</td><td>最后一次更新时间, 在 create/patch/delete 时更新</td></tr><tr><td>delete_time</td><td>Timestamp</td><td>删除时间, 如果支持资源保留</td></tr><tr><td>expire_time</td><td>Timestamp</td><td>超时时间</td></tr><tr><td>start_time</td><td>Timestamp</td><td>开始时间</td></tr><tr><td>end_time</td><td>Timestamp</td><td>结束时间 (不管是否成功)</td></tr><tr><td>time_zone</td><td>string</td><td>时区名. IANA TZ name, 例如 &quot;America/Los_Angeles&quot;, <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a></td></tr><tr><td>region_code</td><td>string</td><td>地区的 Unicode country/region code (CLDR), 例如 &quot;US&quot; and &quot;419&quot;,<a href="http://www.unicode.org/reports/tr35/#unicode_region_subtag">unicode_region_subtag</a></td></tr><tr><td>language_code</td><td>string</td><td>BCP-47 语言码, 例如 &quot;en-US&quot;. <a href="http://www.unicode.org/reports/tr35/#Unicode_locale_identifier">Unicode locale identifier</a></td></tr><tr><td>mime_type</td><td>string</td><td>IANA 发布的 MIME 类型. <a href="https://www.iana.org/assignments/media-types/media-types.xhtml">media-types</a></td></tr><tr><td>display_name</td><td>string</td><td>实体的显示名字</td></tr><tr><td>title</td><td>string</td><td>实体的官方名字, 例如公司名. 作为正式的 display_name.</td></tr><tr><td>description</td><td>string</td><td>实体描述</td></tr><tr><td>filter</td><td>string</td><td>List 方法的标准过滤参数</td></tr><tr><td>query</td><td>string</td><td>等同于 List 方法的 filter, 不过用于 Search</td></tr><tr><td>page_token</td><td>string</td><td>List 请求的分页符</td></tr><tr><td>page_size</td><td>int32</td><td>List 请求的分页大小</td></tr><tr><td>total_size</td><td>int32</td><td>总数</td></tr><tr><td>next_page_token</td><td>string</td><td>下一页的分页符, 如果为空则表示没有更多结果</td></tr><tr><td>order_by</td><td>string</td><td>指定 List 请求的排序</td></tr><tr><td>request_id</td><td>string</td><td>用于检测重复请求的唯一标识符</td></tr><tr><td>resume_token</td><td>string</td><td>用于恢复一个流请求的不透明标识符</td></tr><tr><td>labels</td><td><code>map&lt;string, string&gt;</code></td><td>资源标签</td></tr><tr><td>deleted</td><td>bool</td><td>如果资源允许 undelete 操作, 则应该有被删除标示</td></tr><tr><td>show_deleted</td><td>bool</td><td>如果资源允许 undelete 操作, 相应的 List 操作应该可以死指定显示已删除的资源</td></tr><tr><td>update_mask</td><td>FieldMask</td><td>用于 Update 对资源进行部分更新操作. 该属相对于资源而非请求消息</td></tr><tr><td>validate_only</td><td>bool</td><td>如果为 true, 则应该只验证该请求, 而不执行</td></tr></tbody></table><h3>错误</h3><ul><li>错误模型 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto">google.rpc.Status</a></li><li>错误码 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto">google.rpc.Code</a><ul><li>单独的接口应该避免定义额外的错误码, 如果一个接口需要处理三四种错误码, 那么代码将大部分都是错误处理</li></ul></li><li>错误信息<ul><li>不要假设用户非常了解你的接口</li><li>不要假设用户知道任何服务的实现相关, 或者了解错误的上下文信息</li><li>如果可以, 错误信息应该能被一个技术人员理解并且修复错误</li><li>保持错误信息简介, 如果可以, 可提供一个错误链接以供提问或反馈</li></ul></li><li><a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto">google/rpc/error_details.proto</a><ul><li>定义了常用的错误详情</li></ul></li></ul><pre><code class="language-protobuf">package google.rpc;

message Status {
  // 简单的错误码, 实际的错误码由 `google.rpc.Code` 定义
  int32 code = 1;

  // 面向开发者的错误信息. 应该解释错误原因并提可操作的解决办法
  string message = 2;

  // 附加的错误信息, 例如重试延迟或帮助链接
  repeated google.protobuf.Any details = 3;
}
</code></pre><h3>名称转换</h3><ul><li>遵循 简介, 直观, 一致 的原则</li><li>产品名<ul><li>产品的营销名称</li><li>应该与 接口, UI, 文档, TOS, 账单, 合同保持一致</li><li>必须以 Google 开头, 除非由多个产品使用, 例如 Gmail, Youtube</li><li>应该由产品或营销团队决定</li></ul></li><li>服务名<ul><li>应该是一个合法的 DNS 名字, 可以被解析为一个或多个网络地址<ul><li>谷歌接口的服务名均为 <code>xxx.googleapis.com</code></li><li>例如 <code>calendar.googleapis.com</code></li></ul></li><li>如果 API 由多个服务组成, 名字应该帮助其发现相应的其他服务, 例如使用一个统一的前缀<ul><li>例如 <code>build.googleapis.com</code> 和 <code>buildresults.googleapis.com</code> 同属于 Google Build API</li></ul></li></ul></li><li>包名<ul><li>在 <code>.proto</code> 中定义的包名, 应该尽量与产品和服务名保持你一直</li><li>如果 API 有版本, 那么包必须以版本号作为结束</li><li>不由具体服务使用的抽象 API, 应该使用与产品一致的包名<ul><li><code>google.watcher.v1</code></li></ul></li><li>Java 包必须与包名一直, 只在其前面加相应前缀 (<code>com</code>.<code>net</code> 等)</li></ul></li><li>集合标识符<ul><li>应该使用复数形式和驼峰命名</li></ul></li><li>接口名<ul><li>即 <code>.proto</code> 中的 <code>service</code>, 避免与服务名冲突</li><li>可认为服务名是一组 API 实现的合集, 而接口是 API 的抽象定义</li><li>应该使用只管的名字, 例如 <code>Calendar</code> <code>Blob</code></li><li>不应该使用与已有的概念产生冲突, 例如 <code>File</code></li><li>在极端情况下, 避免与其他 API 冲突, 应该使用一个后缀(<code>Api</code>,<code>Service</code>)来避免歧义</li></ul></li><li>方法名<ul><li>应该使用 <code>VerbNoun</code> <code>动词名字</code> 的格式, 其中的每次应该为资源类型</li><li>动词应该使用<a href="https://zh.wikipedia.org/wiki/%E7%A5%88%E4%BD%BF%E8%AF%AD%E6%B0%94">祈使语气</a>, 而不是疑问语气<ul><li>表达直接命令或请求</li></ul></li></ul></li><li>消息名<ul><li>应该与方法名为前缀, 添加 <code>Request</code> 和 <code>Response</code> 作为后缀, 除非<ul><li>消息为空, google.protobuf.Empty</li><li>资源类型</li><li>表示一个操作的资源</li></ul></li></ul></li><li>枚举名<ul><li>类型名必须为 <code>UpperCamelCase</code></li><li>值名必须为 <code>CAPITALIZED_NAMES_WITH_UNDERSCORES</code></li><li>每个枚举值必须以 <code>;</code> 结束</li><li>第一个值应该为 <code>ENUM_TYPE_UNSPECIFIED</code>, 表示该值未被指定</li></ul></li><li>字段名<ul><li>字段名必须为 <code>lower_case_underscore_separated_names</code></li><li>应该避免使用<a href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E8%AF%8D">介词</a><ul><li><code>reason_for_error</code> -&gt; <code>error_reason</code></li><li><code>cpu_usage_at_time_of_failure</code> -&gt; <code>failure_time_cpu_usage</code></li></ul></li><li>应该避免使用后置形容词 <a href="https://en.wikipedia.org/wiki/Postpositive_adjective">Postpositive adjective</a><ul><li><code>items_collected</code> -&gt; <code>collected_items</code></li><li><code>objects_imported</code> -&gt; <code>imported_objects</code></li></ul></li><li>重复字段应该使用复数形式</li><li>时间点和持续时间<ul><li>使用 <code>google.protobuf.Timestamp</code> 和 <code>google.protobuf.Duration</code></li><li>以 <code>_time</code> 或 <code>_duration</code> 作为后缀</li><li>如果需要时间相关的后缀, 必须遵循 <code>xxx_{time|duration|delay|latency}_{seconds|millis|micros|nanos}</code> 格式</li><li>如果不得不使用字符串格式, 那么应该使用 RFC 3339 格式, 例如 <code>2014-07-30T10:43:17Z</code></li></ul></li><li>日期和一天中的时间<ul><li>应该使用 <code>google.type.Date</code> 和 <code>google.type.TimeOfDay</code></li><li>应该以 <code>_date</code> 和 <code>_time</code> 作为后缀</li><li>如果日期不得不使用字符串形式, 应该使用 ISO 8601 日期格式 <code>YYYY-MM-DD</code> 例如 <code>2014-07-30</code></li><li>如果时间不得不使用字符串形式, 应该使用 ISO 8601 24 小时的事件格式, <code>HH:MM:SS[.FFF]</code> 例如 <code>14:55:01.672</code></li></ul></li><li>数量<ul><li>比包含测量单位<ul><li><code>xxx_{bytes|width_pixels|meters}</code></li></ul></li><li>如果是项目的数量, 应该以 <code>_count</code> 作为后缀</li></ul></li><li>List 过滤字段应该使用 <code>filter</code></li><li>List 响应<ul><li>返回的资源字段必须是复数形式</li></ul></li></ul></li><li>名字缩写<ul><li>在接口定义时应该使用常见的缩写, 在文档中应该使用标准格式<ul><li>config (configuration)</li><li>id (identifier)</li><li>spec (specification)</li><li>stats (statistics)</li></ul></li></ul></li></ul><table><thead><tr><th>API Name</th><th>Example</th></tr></thead><tbody><tr><td>产品名</td><td>Google Calendar API</td></tr><tr><td>服务名</td><td>calendar.googleapis.com</td></tr><tr><td>包名</td><td>google.calendar.v3</td></tr><tr><td>接口名</td><td>google.calendar.v3.CalendarService</td></tr><tr><td>源码目录</td><td>//google/calendar/v3</td></tr><tr><td>API 名</td><td>calendar</td></tr></tbody></table><p><strong>方法名</strong></p><table><thead><tr><th>Verb</th><th>Noun</th><th>Method name</th><th>Request message</th><th>Response message</th></tr></thead><tbody><tr><td>List</td><td>Book</td><td>ListBooks</td><td>ListBooksRequest</td><td>ListBooksResponse</td></tr><tr><td>Get</td><td>Book</td><td>GetBook</td><td>GetBookRequest</td><td>Book</td></tr><tr><td>Create</td><td>Book</td><td>CreateBook</td><td>CreateBookRequest</td><td>Book</td></tr><tr><td>Update</td><td>Book</td><td>UpdateBook</td><td>UpdateBookRequest</td><td>Book</td></tr><tr><td>Rename</td><td>Book</td><td>RenameBook</td><td>RenameBookRequest</td><td>RenameBookResponse</td></tr><tr><td>Delete</td><td>Book</td><td>DeleteBook</td><td>DeleteBookRequest</td><td>google.protobuf.Empty</td></tr></tbody></table><h3>版本</h3><ul><li><code>MAJOR.MINOR.PATCH</code><ul><li>MAJOR 接口不兼容</li><li>MINOR 添加新的功能</li><li>PATCH 问题修正</li></ul></li></ul><table><thead><tr><th>Version</th><th>Proto Package</th><th>Description</th></tr></thead><tbody><tr><td>v1alpha</td><td>v1alpha1</td><td>The v1 alpha release.</td></tr><tr><td>v1beta1</td><td>v1beta1</td><td>The v1 beta 1 release.</td></tr><tr><td>v1beta2</td><td>v1beta2</td><td>The second beta release of v1.</td></tr><tr><td>v1test</td><td>v1test</td><td>An internal test release with dummy data.</td></tr><tr><td>v1</td><td>v1</td><td>The v1 major version, general availability.</td></tr><tr><td>v1.1beta1</td><td>v1p1beta1</td><td>The first beta release for minor changes to v1.</td></tr><tr><td>v1.1</td><td>v1</td><td>The minor update to v1.1 release.</td></tr><tr><td>v2beta1</td><td>v2beta1</td><td>The v2 beta 1 release.</td></tr><tr><td>v2</td><td>v2</td><td>The v2 major version, general availability.</td></tr></tbody></table>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Redis 流简介]]></title>
            <link>https://wener.me/story/redis-stream-intro</link>
            <guid>redis-stream-intro</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[概述]]></description>
            <content:encoded><![CDATA[<h2>概述</h2><p>对 Redis 的印象可能很多人都还只停留在 2.8 的阶段，一个结构化的内存存储（嗯，好像也没什么问题）。虽然距离 4.0 发布(2017.7.14)已经一年过去了，但相信很多人已经不再去关心 Redis 的新特性了，因为从 2.8 后的 Redis 已经足够好用了。😄</p><p>Redis 3.0 添加了集群的能力，4.0 添加了模块化能力，5.0 添加了流类型。如果说 3.0 和 4.0 添加的新特性对于一般用户来说无足轻重，那 5.0 新的流类型就不可忽视啦！</p><p>在没有 Stream 类型之前，其实 Redis 也支持各种类似于流的处理模式，例如 Fire and forget 模式的 Pub/Sub，阻塞队列 BLPOP，时间序列 zsort 存储，等各种方式都能模拟类似的场景，但却都觉得有点欠缺，终于，流类型成功的解决了以上所有问题，并能支持其他的常见使用场景。</p><p>说到流消息就不得不说到 Kafka 啦，我相信大家应该都听说过消息中间件 Kafka，至于 RocketMQ 或者 MetaQ 就不再赘述他们与 Kafka 的关系啦，Redis 作者在实现流类型时大量参考了 Kafka 中的概念，例如消费模型，流消息的概念。当然所有的参考只局限于 Kafka 的文档，与 Kafka 的代码实现没有任何关系哦。</p><p>心动不如心动，那先一睹为快吧。</p><h2>环境准备</h2><p>如果你是 macOs 用户，并且安装了 brew（如果没有安装，那建议先安装 <code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>），那么只需要</p><pre><code class="language-bash">brew install redis
</code></pre><p>即可，如果你是非 macOs 用户，那要嘛考虑换 mac，要嘛使用 docker 启动</p><pre><code class="language-bash">docker run --rm -it -p 6379:6379 -v $PWD:/data --name redis redis:alpine
# 题外话: 使用 alpine 更小更省心，强烈推荐，有任何使用问题都可以交流哦，至于有多好，在这里怕是说不完。

# 验证安装的版本
docker exec redis redis-cli info server
# 客户端链接
docker exec -it redis redis-cli
</code></pre><p>一切准备就绪，就开始实践吧。既然流是新的数据类型，那我们就先从支持的操作开始吧。</p><h2>命令列表</h2><p>Stream 类型一共支持 13 个<a href="https://redis.io/commands#stream">命令</a>，这里简单列举一下支持的命令。</p><table><thead><tr><th>命令</th><th>功能概述</th></tr></thead><tbody><tr><td>xinfo</td><td>获取消费者，分组和流信息</td></tr><tr><td>xadd</td><td>添加消息到流</td></tr><tr><td>xtrim</td><td>将流重置为指定大小</td></tr><tr><td>xdel</td><td>通过 ID 删除</td></tr><tr><td>xrange</td><td>返回范围内的消息，特殊起始 + -</td></tr><tr><td>xrevrange</td><td>与 xrange 相同，但返回顺序相反</td></tr><tr><td>xlen</td><td>获取流长度</td></tr><tr><td>xread</td><td>从流中指定 id 开始读取指定量消息，可选择阻塞返回</td></tr><tr><td>xgroup</td><td>管理消费组</td></tr><tr><td>xreadgroup</td><td>以订阅组成员的身份读取流消息 - 即订阅/消费消息</td></tr><tr><td>xack</td><td>响应消息被正确处理</td></tr><tr><td>xpending</td><td>查询正在处理中的消息 - 尚未 ACK 的消息</td></tr><tr><td>xclaim</td><td>获取正在处理中的消息</td></tr></tbody></table><p>在开始之前，简单概述一下使用过程中需要注意的点</p><ol><li>流消息内容是字典 - 即 KV 结构</li><li>每个消息有一个 ID - 128bit - 由时间戳和序列号组成</li><li>插入消息时使用 <code>*</code> 作为 ID 则是由服务端生成 ID</li><li>ID 必须递增</li><li><code>-</code>/<code>+</code> 分别表示最小和最大消息 ID</li><li><code>$</code> 表示最新的消息位置，在创建消费组时使用</li><li><code>&gt;</code> 表示最新消费的消息位置，在消费消息时使用</li></ol><h2>命令交互</h2><pre><code class="language-bash"># 往流中添加消息 - 会返回消息 ID
# 手动指定 ID
xadd s 1-0 name wener age 18
xadd s 1-1 name wen age 17
# 由服务端生成消息 ID
xadd s * name xx age 16
# 返回所有消息
xrange s - +
# 返回第一条
xrange s - + count 1
# 返回最后一条
xrevrange s + - count 1
# 返回消息长度
xlen s

# 读第一条消息
xread count 1 streams s1 0-0
# 读取第二条 - 指定的消息 ID 是 1-0 ，会返回这个 ID 之后的消息
xread count 1 streams s1 1-0

# 模拟消息的 Roling 处理
# ------
del s
# 在插入消息时，可限制消息的最大长度，类似于 rolling 日志文件的逻辑
# 逻辑等同于先 add 再 trim
# 插入时限制最大长度 2
xadd s MAXLEN 2 * ts 1
xadd s MAXLEN 2 * ts 2
xadd s MAXLEN 2 * ts 3
xadd s MAXLEN 2 * ts 4
# 流中只会有 3 4 这两条消息
xrange s - +

# 消费组
# ======
# 重置流内容
del s
# 创建消费组 g1 并将消费位置置为最新消息位置 $
# 因为 s 不存在，指定 MKSTREAM 会自动创建一个空的流 s
xgroup create s g1 $ MKSTREAM
# 添加新的消息
xadd s 1-1 name zz age 16
# 会返回最新插入的消息，当前消费者为 c1
xreadgroup group g1 c1 count 1 streams s &gt;
# 当消息处理完成后对服务端进行响应
xack s g1 1-1

# 模拟消息处理失败场景
# ------
# 添加新的消息
xadd s 1-2 name aa age 16
# 由 c2 消费
xreadgroup group g1 c2 count 1 streams s &gt;
# 但在处理过程中异常，未 ACK，此时通过 pending 查看 c2 堆积的消息
xpending s g1 - + 1 c2
# c1 有能力处理，因此可以将 c2 处理失败的消息拿过来处理
# retrycount 由应用自己维护，记录重试次数
# 500 为表示该消息的处理时间超过 500ms 才能“拿”过来
xclaim s g1 c1 500 1-2 retrycount 2
# c1 成功处理该消息
xack s g1 1-2
</code></pre><p>Stream 的操作相当简介，能实现什么样的功能主要取决于业务的设计。使用 cli 完成了基本的操作再来看看 Java 的操作吧。</p><h2>Java 交互</h2><p><a href="https://github.com/lettuce-io/lettuce-core">lettuce</a> 是一个基于 Netty 的异步 Redis 客户端，在最新版中支持了 Stream 的操作。</p><p><strong>生产和消费</strong></p><pre><code class="language-java">public void stream() throws InterruptedException {
    RedisClient client = RedisClient.create(&quot;redis://localhost&quot;);
    StatefulRedisConnection&lt;String, String&gt; connection = client.connect();
    // 流的名字
    String streamName = &quot;s&quot;;
    // 消费组名
    String groupName = &quot;g1&quot;;

    AtomicInteger counter = new AtomicInteger();
    // 总消息量
    long total = 1000000;
    // 并发生产
    int producerCount = 2;
    // 并发消费
    int consumerCount = 4;
    for (int i = 0; i &lt; producerCount; i++) {
        int id = i;
        CompletableFuture.runAsync(() -&gt; {
            String name = &quot;producer.&quot; + id;
            StatefulRedisConnection&lt;String, String&gt; connect = client.connect();
            while (true) {
                int n = counter.incrementAndGet();
                if (n &gt; total) {
                    return;
                }
                // 同步生产
                Timer.Context context = metrics.timer(name).time();
                connect
                        .sync()
                        .xadd(streamName, &quot;ts&quot;, String.valueOf(System.currentTimeMillis()), &quot;i&quot;, String.valueOf(n))
                ;
                context.close();
            }
        });
    }

    for (int i = 0; i &lt; consumerCount; i++) {
        StatefulRedisConnection&lt;String, String&gt; connect = client.connect();

        // 消费的上下文
        ConsumerContext c = new ConsumerContext();
        c
                .setConnection(connect)
                .setConsumer(Consumer.from(groupName, &quot;c&quot; + i))
                .setStreamName(streamName)
                .setGroupName(groupName)
                .setName(&quot;consumer.&quot; + i)
                .setXReadArgs(XReadArgs.Builder.block(Duration.ofSeconds(5)))
                .setXreadLastOffset(XReadArgs.StreamOffset.lastConsumed(streamName))
        ;
        // 异步消费
        consume(c);
    }

    Thread.sleep(Duration.ofMinutes(10).toMillis());
}


private CompletionStage&lt;?&gt; consume(ConsumerContext c) {
    Timer.Context context = metrics.timer(c.name).time();
    return c.connection
            .async()
            .xreadgroup(c.consumer, c.xReadArgs, c.xreadLastOffset)
            // 消息处理
            .thenCompose(v -&gt; {
                context.close();
                if (v.isEmpty()) {
                    metrics.meter(c.name + &quot;.empty&quot;).mark();
                    return CompletableFuture.completedFuture(null);
                }
                StreamMessage&lt;String, String&gt; message = v.get(0);

                // 输出一定日志量
                if (ThreadLocalRandom.current().nextDouble() &lt; 0.01) {
                    log.info(&quot;[{}] {}&quot;, c.name, message.getBody());
                }

                // 成功处理
                return c.connection.async().xack(c.streamName, c.groupName, message.getId());
            })
            // 异常处理
            .exceptionally(e -&gt; {
                metrics.meter(c.name + &quot;.error&quot;).mark();
                return null;
            })
            // 循环 - 没有推出逻辑
            .thenCompose((v) -&gt; consume(c));
}


@Data
@Accessors(chain = true)
public static class ConsumerContext {
    String name;
    String streamName;
    String groupName;
    Consumer&lt;String&gt; consumer;

    StatefulRedisConnection&lt;String, String&gt; connection;

    XReadArgs.StreamOffset&lt;String&gt; xreadLastOffset;

    XReadArgs xReadArgs;
}
</code></pre><p><strong>处理未成功的消息</strong></p><p>同步操作，逻辑相对清晰</p><pre><code class="language-java">public void testClaimPendingSingleThreadSync() {
    RedisClient client = RedisClient.create(&quot;redis://localhost&quot;);
    StatefulRedisConnection&lt;String, String&gt; connection = client.connect();
    String streamName = &quot;s&quot;;
    String groupName = &quot;g1&quot;;

    RedisCommands&lt;String, String&gt; sync = connection.sync();
    Consumer&lt;String&gt; consumer = Consumer.from(groupName, &quot;c1&quot;);
    Range&lt;String&gt; fullRange = Range.create(&quot;-&quot;, &quot;+&quot;);

    while (true) {
        try (Timer.Context ignored = metrics.timer(consumer.getName() + &quot;.pending&quot;).time()) {
            PendingResult result = PendingResult.of(sync.xpending(streamName, consumer, fullRange, Limit.from(1)));

            if (!result.hasPending()) {
                break;
            }

            List&lt;StreamMessage&lt;String, String&gt;&gt; list = sync.xclaim(
                    streamName,
                    consumer,
                    new XClaimArgs().minIdleTime(500).retryCount(result.getDeliverCount() + 1),
                    result.getMessageId()
            );
            if (list.isEmpty()) {
                continue;
            }
            StreamMessage&lt;String, String&gt; message = list.get(0);
            if (ThreadLocalRandom.current().nextDouble() &lt; 0.001) {
                log.info(&quot;[{}] {}&quot;, consumer.getName(), message.getBody());
            }
            sync.xack(streamName, groupName, message.getId());
        }
    }
}

/**
 * Pending 返回的结果处理
 */
interface PendingResult {
    static PendingResult of(List&lt;Object&gt; v) {
        return () -&gt; v;
    }

    List&lt;Object&gt; getResult();

    default boolean hasPending() {
        List&lt;Object&gt; result = getResult();
        if (result != null &amp;&amp; !result.isEmpty()) {
            List list = (List) result.get(0);
            return !list.isEmpty() &amp;&amp; list.get(0) != null;
        }
        return false;
    }

    default String getMessageId() {
        return String.valueOf(((List) getResult().get(0)).get(0));
    }

    default String getConsumer() {
        return String.valueOf(((List) getResult().get(0)).get(1));
    }

    default long getElapseTime() {
        return ((Number) ((List) getResult().get(0)).get(2)).longValue();
    }

    default long getDeliverCount() {
        return ((Number) ((List) getResult().get(0)).get(3)).longValue();
    }
}

</code></pre><p>某次的性能统计</p><pre><code>Java CPU 70%
c1.pending
             count = 769903
         mean rate = 3360.66 calls/second
     1-minute rate = 3267.08 calls/second
     5-minute rate = 2855.18 calls/second
    15-minute rate = 2538.15 calls/second
               min = 0.22 milliseconds
               max = 1.80 milliseconds
              mean = 0.30 milliseconds
            stddev = 0.13 milliseconds
            median = 0.26 milliseconds
              75% &lt;= 0.32 milliseconds
              95% &lt;= 0.49 milliseconds
              98% &lt;= 0.65 milliseconds
              99% &lt;= 0.88 milliseconds
            99.9% &lt;= 1.66 milliseconds
</code></pre><p><strong>处理未成功的消息</strong></p><p>异步操作，逻辑相对不那么清晰～</p><pre><code class="language-java">public void testClaimPendingSingleThreadAsync() throws ExecutionException, InterruptedException {
    RedisClient client = RedisClient.create(&quot;redis://localhost&quot;);
    StatefulRedisConnection&lt;String, String&gt; connection = client.connect();
    String streamName = &quot;s&quot;;
    String groupName = &quot;g1&quot;;

    RedisAsyncCommands&lt;String, String&gt; async = connection.async();
    Consumer&lt;String&gt; consumer = Consumer.from(groupName, &quot;c2&quot;);
    Range&lt;String&gt; fullRange = Range.create(&quot;-&quot;, &quot;+&quot;);

    AtomicReference&lt;Supplier&lt;CompletionStage&lt;?&gt;&gt;&gt; process = new AtomicReference&lt;&gt;();
    AtomicReference&lt;Timer.Context&gt; context = new AtomicReference&lt;&gt;();
    // 一次处理
    process.set(() -&gt; {
        context.set(metrics.timer(consumer.getName() + &quot;.process&quot;).time());
        return async
                .xpending(streamName, consumer, fullRange, Limit.from(1))
                .thenCompose(v -&gt; {
                    PendingResult result = PendingResult.of(v);
                    if (!result.hasPending()) {
                        throw new RuntimeException(&quot;DONE&quot;);
                    }

                    return async.xclaim(
                            streamName,
                            consumer,
                            new XClaimArgs().minIdleTime(500).retryCount(result.getDeliverCount() + 1),
                            result.getMessageId()
                    );
                })
                .thenCompose(list -&gt; {
                    StreamMessage&lt;String, String&gt; message = list.get(0);
                    if (ThreadLocalRandom.current().nextDouble() &lt; 0.001) {
                        log.info(&quot;[{}] {}&quot;, consumer.getName(), message.getBody());
                    }
                    return async.xack(streamName, groupName, message.getId());
                })
                .thenCompose(v -&gt; {
                    context.get().close();
                    return process.get().get();
                });
    });
    // 循环
    process.get()
            .get()
            .whenComplete((v, e) -&gt; {
                if (e != null) {
                    e.printStackTrace();
                }
                log.info(&quot;Complete&quot;);
            })
            .toCompletableFuture()
            .get();
}
</code></pre><p>但性能会比同步操作的性能要好呢，Java 的 CPU 也比同步的更低</p><pre><code>Java CPU 50%
redis-server CPU 50%
c2.process
            count = 879207
        mean rate = 5145.76 calls/second
    1-minute rate = 5128.23 calls/second
    5-minute rate = 3779.55 calls/second
15-minute rate = 3132.92 calls/second
            min = 0.14 milliseconds
            max = 0.81 milliseconds
            mean = 0.18 milliseconds
        stddev = 0.06 milliseconds
        median = 0.16 milliseconds
            75% &lt;= 0.19 milliseconds
            95% &lt;= 0.29 milliseconds
            98% &lt;= 0.34 milliseconds
            99% &lt;= 0.40 milliseconds
        99.9% &lt;= 0.81 milliseconds
</code></pre><h2>总结</h2><p>当什么时候选择 Redis 的流呢？</p><ol><li>内存存储满足需求</li><li>速度要求高</li><li>能接收 Redis 的持久化保障 - （保障是不一定持久 😄）</li></ol><p>合理的应用也是需要合理的场景。</p><p>流总的来说还是很不错的，还有很多可能使用的场景在这里不做一一赘述，流的内部实现也是非常的有意思的，等有时间再做另外的一个分享。此外 Redis 4 的 Module 也是非常有魅力，例如甚至可以用 <a href="https://github.com/wenerme/go-rm">Golang</a> 来实现模块添加新的命令功能，嗯嗯，机会多多。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Java 11 JavaFX 第一个应用]]></title>
            <link>https://wener.me/story/java11-javafx-first-app</link>
            <guid>java11-javafx-first-app</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[概述]]></description>
            <content:encoded><![CDATA[<h2>概述</h2><p>Java 11 自 2018.9.25 发布以来，已经好几个月了，在还没正式 GA 之前都习惯性的去 <a href="http://www.java-countdown.xyz/">java-countdown.xyz</a> check 发布倒计时。Java 11 有比较多的新功能，而其中最吸引我的</p><ul><li>Java 11 是 LTS 版本<ul><li>这意味着体验 Java9 带来的模块特性变得更有意义</li></ul></li><li>JavaFX 从 JDK 中移除，作为独立模块</li></ul><p>在 11 发布时，JavaFX 也发布了 11 的 GA 版本。JavaFX 本身并不新奇，但自 Java9 模块化后，JavaFX 得益于 jlink 的能力，能够将 JavaFX 封装为独立的 GUI 应用，<strong>不要求安装 JDK</strong> 。这使得在桌面应用开发的场景，除了 Electron、Mono、QT 等跨平台开发框架，Java 也能作为其中的一项选择了。在 Swing 时代，Java 的桌面应用开发体验也不差（曾经做过的小游戏 <a href="https://github.com/wenerme/GTetris">wenerme/GTetris</a>），但由于累赘的 JDK （大约 150m）使得开发一个小应用变得不切实际。</p><p>JLink 可以将项目依赖的模块加上基础 VM 来生成一个新的 JDK，应用的体积能够大大减小，如果还能再配合 progard，那体积还能再缩小一圈。</p><h2>Motivation</h2><p>基于体验 Java11 和 JavaFX 的前提（每个 Java 程序员都会写界面是常识？），将生成 奥格人群服务化接口文档 的生成器做成了一个 GUI 工具，源码在 wener.cyw/tools。</p><p>doc/screenshot-java.png</p><p>doc/screenshot-markdown.png</p><p>工具下载地址见附件 - 只打包了 Mac 版应用，因为没有 Windows。</p><h2>安装</h2><p>从 Java 11 开始，Oracle 的 JDK 便不再建议使用了，因此首选 OpenJDK，而 OpenJDK 的二进制提供方也有不少，在这里推荐使用 <a href="https://adoptopenjdk.net/">adoptopenjdk</a>，与 Oracle 不同的是，在这里下载的 JDK 都是压缩包，无须安装，解压就能使用，当然也不会有自动更新的能力。</p><p><strong><a href="https://adoptopenjdk.net/archive.html?variant=openjdk11&amp;jvmVariant=hotspot">点击前往下载</a></strong></p><p>下载后我解压到了 <code>~/jdk</code> 目录，然后建立软连接 <code>~/jdk/11</code> 指向到了该版本。</p><h2>开发</h2><p>总结一下在整个过程中遇到的问题</p><ol><li>项目搭建 - 10%</li><li>应用开发 - 20%</li><li>生成 JDK - 非模块依赖转模块依赖 - 50%</li><li>应用打包 - 20%</li></ol><h3>项目搭建</h3><p>搭建一个 Java 11 的 Maven 项目与搭建一个普通的项目区别并不大，只是会多一些配置，并且所有的依赖都需要使用最新的。</p><p>父 POM 的 build/plugins 配置说明</p><pre><code class="language-xml">&lt;!-- 对 Java 11 持有基本的尊敬 --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.8.0&lt;/version&gt;
    &lt;configuration&gt;
        &lt;release&gt;11&lt;/release&gt;
        &lt;source&gt;11&lt;/source&gt;
        &lt;target&gt;11&lt;/target&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;

&lt;!-- 打包时打包到 modules 目录 --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;configuration&gt;
        &lt;outputDirectory&gt;
            ${project.build.directory}/modules
        &lt;/outputDirectory&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
&lt;!-- 将依赖拷贝到 modules 目录 --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;copy-dependencies&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;outputDirectory&gt;
                    ${project.build.directory}/modules
                &lt;/outputDirectory&gt;
                &lt;includeScope&gt;runtime&lt;/includeScope&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;

&lt;!-- 因为并不是所有依赖都是模块化的，所以可能会出现 illegal-access 的问题 --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.22.0&lt;/version&gt;
    &lt;configuration&gt;
        &lt;argLine&gt;
            --illegal-access=permit
        &lt;/argLine&gt;
        &lt;forkCount&gt;0&lt;/forkCount&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.22.0&lt;/version&gt;
    &lt;configuration&gt;
        &lt;argLine&gt;
            --illegal-access=permit
        &lt;/argLine&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre><p>应用项目的 build 配置</p><pre><code class="language-xml">&lt;build&gt;
    &lt;!-- 因为用到了 fxml，且 fxml 是放在类旁边的，所以需要手动指定该类资源 --&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.fxml&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;plugins&gt;
        &lt;!-- 确保 jar 中生成正确的信息 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
            &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;1.6.0&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;module-main-class&lt;/id&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;exec&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;!-- 因为 PATH 中的 jar 是 Java8，所以这里指定的绝对路径 --&gt;
                        &lt;executable&gt;/Users/wener/jdk/11/Contents/Home/bin/jar&lt;/executable&gt;
                        &lt;arguments&gt;
                            &lt;argument&gt;
                                --update
                            &lt;/argument&gt;
                            &lt;argument&gt; --file=${project.build.directory}/modules/${project.build.finalName}.jar
                            &lt;/argument&gt;
                            &lt;!-- 启动类 --&gt;
                            &lt;argument&gt; --main-class=me.wener.tools.app.AppMain
                            &lt;/argument&gt;
                            &lt;argument&gt; --module-version=${project.version}
                            &lt;/argument&gt;
                        &lt;/arguments&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre><p>最终的配置在 <code>mvn package</code> 后，会在 <code>target/modules</code> 目录下看到所有的 jar 包。这里的 jar 在生成 JDK 时会用到。</p><p>在项目搭建好后，建立出对应的子模块，且在子模块中 <code>src/main/java</code> 设置好 <code>module-info.java</code></p><h3>应用开发</h3><p>JavaFX 的开发非常有意思，因为可以使用 FXML，开发的过程体验与 React/Vue/Angular 这样的前端开发体验非常相似，只需要在 FXML 做好布局，在 css 中定义好样式，然后绑定好交互处理方法即可。</p><p>应用的启动类</p><pre><code class="language-java">public class AppMain extends Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage stage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getResource(&quot;scene/Main.fxml&quot;));

        Scene scene = new Scene(root, 640, 480);
        stage.setTitle(&quot;@文迩 的小工具&quot;);
        stage.setScene(scene);
        stage.show();
    }
}
</code></pre><p>因为是基于 fxml，启动类只需要将该场景初始化展示即可。</p><p>一个 fxml 的基本框架</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;?import javafx.scene.control.*?&gt;
&lt;?import javafx.scene.layout.*?&gt;
&lt;?import javafx.stage.Screen?&gt;
&lt;AnchorPane fx:id=&quot;masterPane&quot;
            xmlns=&quot;http://javafx.com/javafx/8.0.121&quot;
            xmlns:fx=&quot;http://javafx.com/fxml/1&quot;
            fx:controller=&quot;me.wener.tools.app.scene.MainScene&quot;&gt;
&lt;/AnchorPane&gt;
</code></pre><p>其中比较关键的是 <code>fx:controller</code> 绑定了控制类 <code>me.wener.tools.app.scene.MainScene</code>。</p><p>因此在后续的 <code>action</code> 定义中可直接引用控制类上的方法，或者将页面元素直接关联到控制类。</p><p>绑定元素
<img src="./javafx-binding.png" alt="javafx-binding.png"/></p><p>元素关联
<img src="./javafx-relation.png" alt="javafx-relation.png"/></p><p>Intellij 比较智能，可直接在这两个地方互相跳转。</p><pre><code class="language-xml">&lt;!-- 按钮点击关联控制类上的方法 doConvert --&gt;
&lt;Button mnemonicParsing=&quot;false&quot; onAction=&quot;#doConvert&quot; text=&quot;生成文档&quot;/&gt;
</code></pre><h3>生成 JDK</h3><p>在 APP 开发完成后，即可为该 APP 生成一个定制的 JDK，该 JDK 只需要包含 APP 所需依赖，生成的 JDK 可重复使用，除非 APP 的依赖变更。</p><pre><code class="language-bash"># 确保下面的 Java 命令是 Java 11 的
export PATH=$JAVA_11_HOME/bin:$PATH

# 查看打包拷贝的模块
# 其中会发现很多 automatic 的模块
java --list-modules -p target/modules/

# 查看主应用 jar 的依赖请求
jdeps  --module-path target/modules/ target/modules/tools-app-1.0-SNAPSHOT.jar

# 生成 JDK 到该目录 jdk/Contents/Home/jre
# add-modules 的列表来自于 module-info 的定义
jlink --strip-debug --compress 2 \
    --no-header-files --no-man-pages \
    --output jdk/Contents/Home/jre \
    -p $PWD/target/modules \
    --add-modules javafx.controls,javafx.fxml,com.google.common,com.github.javaparser.core,com.github.javaparser.symbolsolver.logic,com.github.javaparser.symbolsolver.model,me.wener.tools.core
</code></pre><p>但在生成 JDK 时会发现异常</p><pre><code>Error: automatic module cannot be used with jlink: com.github.javaparser.symbolsolver.logic from xxx.jar
</code></pre><p>异常的原因是 jlink 不支持 automatic 的模块，所谓 automatic 模块，指的是没有 module-info 的模块，但在 jar 的 <code>META-INF/MANIFEST.MF</code> 中定义了 <code>Automatic-Module-Name</code> 信息。</p><p>针对这类 jar，唯一能比较好的处理方式</p><ol><li>生成 module-info.java</li><li>解包</li><li>编译 module-info.java</li><li>更新 jar</li></ol><p>一下以 javax.inject 为案例</p><pre><code class="language-bash">wget http://central.maven.org/maven2/javax/inject/javax.inject/1/javax.inject-1.jar

# 查看依赖情况，非模块化的 jar 依赖和模块化 jar 的依赖现实不同
# 输出: javax.inject-1.jar -&gt; java.base
# 模块化的 jar 输出: javax.inject -&gt; java.base
jdeps javax.inject-1.jar


# 生成 module-info.java
jdeps --generate-open-module info javax.inject-1.jar
# 解压 jar
unzip javax.inject-1.jar -d classes/
# 编译 module-info.java
javac -p javax.inject -d classes/ info/javax.inject/module-info.java
# 更新 jar
jar uf javax.inject-1.jar -C classes/ module-info.class
# 再次查看依赖
jdeps javax.inject-1.jar
</code></pre><p>其中 <code>info/javax.inject/module-info.java</code> 的内容为</p><pre><code>open module javax.inject {
}
</code></pre><p>接下来的一段时间便是将所有用到的依赖进行这样的转换，其中需要注意的是 <strong>间接依赖也需要模块处理</strong>。其中最难处理的是 guava，因为需要将 guava 模块化，也需要它依赖的所有模块都存在。</p><pre><code>open module com.google.common {
    requires j2objc.annotations;
    requires java.logging;
    requires jdk.unsupported;
    requires jsr305;

    requires transitive error.prone.annotations;

}
</code></pre><p>因此为了将 guava 模块化，需要从 maven 上下载所有的这些 jar 并进行模块化。</p><p>完成所有的模块化后，再次通过 jlink 生成 jdk 到 <code>jdk/Contents/Home/jre</code>，之所以生成到这样的一个目录，是因为在应用打包时能符合默认的 Java 目录结构。</p><pre><code class="language-bash"># 使用生成的 JDK 来运行应用
./jdk/Contents/Home/jre/bin/java -Xmx64m --upgrade-module-path target/modules -m me.wener.tools.app

# 生成的 JDK 大约 50m - 对此已经非常满意了，Electron 一般都是 100m 左右
du -s jdk/
</code></pre><h3>应用打包</h3><p>应用打包主要是将现在已经能运行的 jdk 环境打包为一个 macOs 的 app。打包器有不同的选择，但用下来还是 jar2app 比较好用。如果需要打包其它平台应用，需要选择其它平台的打包器。</p><pre><code class="language-bash">git clone https://github.com/Jorl17/jar2app
# jar2app 是 Python 脚本，因此需要 Python 环境
# 打包，使用自定义 jdk target/jdk
./jar2app/jar2app ./target/modules/tools-app-1.0-SNAPSHOT.jar -r target/jdk/ -b me.wener.tools -n WenerTools -j &quot;-Xmx64M --upgrade-module-path $APP_ROOT/Contents/PlugIns/jdk/modules&quot;

# 最终打包后的应用约 50m
# 50M     WenerTools.app
du -s WenerTools.app

# 双击启动或命令行启动
open WenerTools.app
</code></pre><p>一切大功告成，一个 APP 就此诞生了！如果还想要提交到 AppStore，这个过程还会需要其他的不少步骤，在这就不详细说明啦。</p><h2>总结</h2><p>应用开发过程，打包过程都还是比较愉快的，最困难的是模块化 jar 的处理，因为很多模块都还没有 module-info.java，导致大部分的 jar 都得先处理一遍，不过这个过程是可以累计的，被处理过的 jar 可以被重复利用。如果不需要配合 jlink，那么是不需要处理的。</p><p>Java 11 意味着 Java 9、10、11 的所有新特性，JavaFX 开发也异常的简单，整个过程还是很爽的！</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何从0到1实现一门语言]]></title>
            <link>https://wener.me/story/get-started-with-dsl</link>
            <guid>get-started-with-dsl</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[语言就是程序员的酒精/Languages are alcohol to programmer。🍺]]></description>
            <content:encoded><![CDATA[<blockquote><p>语言就是程序员的酒精/Languages are alcohol to programmer。🍺
⏤ wener</p></blockquote><h2>DSL</h2><p>DSL 全名为 Domain-specific Lnaguage/领域特定语言，说到 domain-specific 会不会第一个想到的是 DDD 呢？DDD 中的语言叫做 Ubiquitous Language，即通用语言，指的是在当前 Domain 下使用统一的自然语言进行沟通交流便于上下文的理解和沟通。DSL 的目的是非常类似的，为特定领域实现的语言，目的是为了更加高效便捷的解决特定领域的问题。</p><p>DSL 是领域特定语言，与之相反的语言叫做 General purpose language/通用语言。通用语言均为图灵完备语言，而 DSL 则不必要具备这样的能力。一个通用语言也有其特定的应用领域，例如 系统编程、Web 编程、脚本 等，来区别于其它语言，因此某种程度上来说通用语言也是“DSL”。</p><p><strong>常见的 DSL</strong></p><table><thead><tr><th>语言</th><th>领域</th></tr></thead><tbody><tr><td>JSON</td><td>数据交换</td></tr><tr><td>CSS</td><td>样式编排</td></tr><tr><td>SQL</td><td>结构查询</td></tr><tr><td>JSX</td><td>结构化组件</td></tr></tbody></table><p>但无论领域为何，DSL 本质是语言，有特定的词法、语法和上下文逻辑。当需要实现一种 DSL 语言时，需要考虑</p><ul><li>语言的目的</li><li>期望的语法词法</li><li>处理逻辑</li></ul><p>驱动实现一门语言，往往因为</p><ul><li>设计理念不同</li><li>更安全可控 - 限制语言能力</li><li>为应用提供更加灵活的处理能力 - 脚本</li><li>扩展现有语言增强表达能力 - 转译 - JSX、TS</li><li>利用现有的运行环境实现更简洁高效的语言 - Kotlin、Elixir</li><li>能够更快更容易的解决/描述特定领域问题 - DSL</li></ul><p>目的不同驱动实现的方式也各不相同，每种的做法也不尽相同，在这里以实现一个简单的数学计算语言作为演示。</p><h2>实现一门语言</h2><ul><li>目的: 实现简单的数值计算，支持基本的三角函数</li><li>语言
<em> 数学操作支持 加减乘除
</em> 三角函数支持 sin、cos <!-- -->*<!-- --> 运行时数值类型均为双精度浮点数</li></ul><p>当语言的基础确定后，需要将语言的语法以某种形式表现出来，表现语言语法的方式也是使用一门语言(♻️😄)。<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a> - 扩展巴科斯范式，语法表述如下</p><pre><code>表达式 = 操作符表达式 | 函数表达式 | 数值
操作符表达式 = 表达式 操作符 表达式
函数表达式 = 函数名 ( 表达式 )
操作符 = + | - | * | /
数值 = 一个或多个 数字
数字 = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</code></pre><p>语法能用通用的 EBNF 表述出来，在各种语言里面有实现类似 EBNF 表达语言语法结构的库，在这里使用 <a href="https://pegjs.org">pegjs</a> 来进行原型验证和实验。</p><p>在 pegjs 的<a href="https://pegjs.org/online">在线 Demo</a>我们可以看到已经有一个支持数学运算的语言。现将左侧语法替换为将要实现的语法描述</p><pre><code>表达式 = 加减表达式
加减表达式  = 乘除表达式 ((&#x27;+&#x27; / &#x27;-&#x27;) 乘除表达式)*
乘除表达式 = 函数表达式 ((&#x27;*&#x27; / &#x27;/&#x27;) 函数表达式)*
函数表达式 = 函数名 &#x27;(&#x27; 表达式 &#x27;)&#x27; / 数值
数值 = [0-9]+
函数名 = [a-z]+
</code></pre><p>:::tip PEG</p><p>细心的你可能会发现我们这里定义的语法与 EBNF 有一定区别，例如单独定义了 <code>加减表达式</code>,<code>乘除表达式</code>，并且是自顶向下嵌套的，而不是 EBNF 的 <code>表达式 = 操作符表达式 | 函数表达式 | 数值</code> 一层直接展开。</p><p>之所以书写成这样，是因为 pegjs 是 <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG</a> 类的解析器，不能做左递归。该细节涉及到如何实现语言解析和语法的优先级处理，将会在额外的文章中进行阐述解释，并讲解如何实现一个解析语言的语言。</p><p>:::</p><p>然后在右上输入表达式 <code>sin(1)*2+3</code>, 解析完成后，右下角出现如下 JSON 内容</p><pre><code class="language-json">[[[[&quot;s&quot;, &quot;i&quot;, &quot;n&quot;], &quot;(&quot;, [[[&quot;1&quot;], []], []], &quot;)&quot;], [[&quot;*&quot;, [&quot;2&quot;]]]], [[&quot;+&quot;, [[&quot;3&quot;], []]]]]
</code></pre><p>该 JSON 是 pegjs 的输出，在没做任何处理的情况下，也可以理解为语法树。其中每一个数组对应了语法描述中的一个定义。例如 <code>[ &quot;s&quot;, &quot;i&quot;, &quot;n&quot; ], &quot;(&quot;, [ [ [ &quot;1&quot; ], [] ], [] ], &quot;)&quot;</code> 对应语法树中的 <code>函数名 &#x27;(&#x27; 表达式 &#x27;)&#x27;</code>，表示对<code>1</code>执行函数<code>sin</code>。</p><p>为了更好的展示语法树，我们在语法树中调整返回结果</p><pre><code>表达式 = 加减表达式
加减表达式  = a:乘除表达式 b:(op:(&#x27;+&#x27; / &#x27;-&#x27;) right:乘除表达式 {return {type:&#x27;Op&#x27;,op,right}})* {return b.reduce((left,right)=&gt;(right.left=left,right),a)}
乘除表达式 = a:函数表达式 b:(op:(&#x27;*&#x27; / &#x27;/&#x27;) right:函数表达式 {return {type:&#x27;Op&#x27;,op,right}})* {return b.reduce((left,right)=&gt;(right.left=left,right),a)}
函数表达式 = name:函数名 &#x27;(&#x27; arg:表达式 &#x27;)&#x27; {return {type:&#x27;Func&#x27;,name,arg}} / 数值
数值 = [0-9]+ {return {type:&#x27;Int&#x27;,value:parseInt(text())}}
函数名 = [a-z]+ {return {type:&#x27;Name&#x27;,name:text()}}
</code></pre><p>对同样的表达式 <code>sin(1)*2+3</code> 我们得到的语法树为</p><pre><code class="language-json">{
  &quot;type&quot;: &quot;Op&quot;,
  &quot;op&quot;: &quot;+&quot;,
  &quot;left&quot;: {
    &quot;type&quot;: &quot;Op&quot;,
    &quot;op&quot;: &quot;*&quot;,
    &quot;left&quot;: { &quot;type&quot;: &quot;Func&quot;, &quot;name&quot;: { &quot;type&quot;: &quot;Name&quot;, &quot;name&quot;: &quot;sin&quot; }, &quot;arg&quot;: { &quot;type&quot;: &quot;Int&quot;, &quot;value&quot;: 1 } },
    &quot;right&quot;: { &quot;type&quot;: &quot;Int&quot;, &quot;value&quot;: 2 }
  },
  &quot;right&quot;: { &quot;type&quot;: &quot;Int&quot;, &quot;value&quot;: 3 }
}
</code></pre><p>这时候看上去更像是树的结构，type 为每个节点的类型。</p><ul><li>Func 函数调用节点 - 有 name 和 arg 属性</li><li>Op 数学操作符节点 - 有 op、left、right 属性</li><li>Int 数值节点 - 有 value 属性</li><li>Name 名字节点 - 有 name 属性</li></ul><p>语法结构表现的内容与表达式本身是完全等价的，可认为是程序/计算机理解的表达式，是更加结构化的内容。
语法树会有很多应用场景，因为语法树与表达式等价，也包含了完整的计算逻辑和上下文信息，并且不需要解析器进行解析。可用于生成更加底层的表现形式，也可用于直接执行。场景的场景包含</p><ul><li>生成 IR - 中间形式，便于进行更多后续处理 - .Net、GnuRTL、LLVM</li><li>生成汇编 - 生成能直接在目标平台执行的二进制 - x86</li><li>代码转译 - 利用一定的规则生成非原始类型代码 - Gwt(Java to Js)、java2objc</li><li>代码优化 - 语法树结构比较通用，程序便于处理，可利用公共的规则进行匹配判断</li><li>代码简化 - 在不影响语义的情况下调整代码 - UglifyJs、代码混淆 - 生成原始类型代码</li><li>代码分析 - 静态类型、安全、“坏”代码检测</li><li>代码索引 - 一般生成的语法树节点都可以包含原始代码位置，可实现基于方法或引用等进行快速索引 - sourcegraph</li><li>代码预处理</li><li>...</li></ul><p>表达式转换成语法树，就好比使用机器学习从自然语言中抽取出意图、实体、上下文等信息，是计算机对理解“人”要做什么的第一步。</p><p>既然同样的语法能调整为生成语法树，那么也就能调整为直接计算结果，因此得到如下内容</p><pre><code>表达式 = 加减表达式
加减表达式  = a:乘除表达式 b:((&#x27;+&#x27; / &#x27;-&#x27;) 乘除表达式)* {return b.reduce((r,[o,v])=&gt;o==&#x27;+&#x27;?r+v:r-v,a)}
乘除表达式 = a:函数表达式 b:((&#x27;*&#x27; / &#x27;/&#x27;) 函数表达式)* {return b.reduce((r,[o,v])=&gt;o==&#x27;*&#x27;?r*v:r/v,a)}
函数表达式 = name:函数名 &#x27;(&#x27; arg:表达式 &#x27;)&#x27; {return Math[name](arg)} / 数值
数值 = [0-9]+ {return parseInt(text())}
函数名 = [a-z]+ {return text()}
</code></pre><p>输入表达式 <code>sin(1)*2+3</code>，得到的输出值为 <code>4.6829419696157935</code>。</p><p>至此，一门简单的语言便验证实现完成了。</p><h2>总结</h2><p>pegjs 是非常方便的工具，但实际在生产中使用时，语法的解析处理需要在个个语言里找类似的实现，当然也可以解析与计算是异构的，例如通过服务端解析完成，下发语法树到客户端进行执行。这也与最近一个 js 标准请求的目的类似,<a href="https://github.com/tc39/proposal-binary-ast">tc39/proposal-binary-ast</a> 希望浏览器能执行二进制的语法树，而不再是每次都进行解析 js，这样的好处是显而易见的。二进制的语法树与汇编/bytecode 几乎只有一线之隔，然后这也正是<a href="https://webassembly.org/">webassembly</a>的目的，直接让浏览器执行汇编，😄。语言与运行环境是周而复始迭代的，多么的“自然”。</p><h2>附录：常用的语法解析器</h2><table><thead><tr><th>解析器</th><th>目标语言</th></tr></thead><tbody><tr><td>flex/yacc</td><td>C</td></tr><tr><td>Antlr4</td><td>Java、JS、Python、Switf、C#、C++、Go</td></tr><tr><td>JavaCC</td><td>Java</td></tr><tr><td>pegjs</td><td>JavaScript</td></tr></tbody></table><ul><li><a href="https://github.com/antlr/grammars-v4">antlr/grammars-v4</a><ul><li>其中的 <a href="https://github.com/antlr/grammars-v4/blob/master/dart2/Dart2.g4">Dart2</a> 由我提交</li><li>假如能实现一个针对 Dart2 的 JSX，那么 Flutter 的开发将会更加美好 🤩</li></ul></li><li><a href="https://en.wikipedia.org/wiki/Comparison_of_parser_generators">Comparison of parser generators</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[囧 -《哪吒之魔童降世》观后感]]></title>
            <link>https://wener.me/story/tt10627720-review</link>
            <guid>tt10627720-review</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[在想标题的时候，看到主演里有 囧（森瑟夫），突然觉得好贴切感受，在观影时大部分是这个表情。]]></description>
            <content:encoded><![CDATA[<p>在想标题的时候，看到主演里有 囧（森瑟夫），突然觉得好贴切感受，在观影时大部分是这个表情。</p><p>最近值得去电影院看的电影并不多，看到哪吒过了两周影院还那么爆满，评分依然 8.7，基本可谓之神作待遇了。在没有人主动安利，媒体上各种吹爆的前提下，怀着满满的期待驶向了电影院。坐着好不容易抢到的 10:40 的6排4座开始了激动的观影。</p><p>当以为影片开始时，才发现还是影业公司LOGO，才发现还是影业公司LOGO，才发现还是影业公司LOGO。。。这，未免业太长了吧，而且除了 COLOROOM 的，其他的也太哪个啥了吧，电影这么高大上，咱就不能多投入点把自己LOGO给做好么？</p><p>好吧，影片正式开始。承认去看这个电影的时候只知道名字叫哪吒，并没看到副标，所以对一开始的展开一下子没缓过来。第一次看到太乙真人上场，觉得形象还是比较讨喜比较搞笑的，然后开口四川话（算是吧）？作为一个四川人，觉得还是蛮有意思的。但接下来气氛开始逐渐凝固，场面一度十分尴尬。</p><p>太乙真人从一开始搞笑，一直搞笑到最后，但搞笑没有任何驱动，纯粹是天然的弱智？第一次，第二次，第三次，就开始受不了了。开始以为这个角色后期肯定会有反转，但看到那朵云的德性后，才发现是我想多了，这整部剧就这尿性，制作组很好的表达了“你们爱看不看”，我: 无言以对😦。</p><p>如果全局所有人都这样纯粹搞笑也就算了，但却偏偏就要正儿八经给你讲讲故事，搞得十分难受，看着都是鸡皮疙瘩。哪吒的“魔”只是为魔而魔，因为是魔丸，所以要很野，很狂妄，很嚣张？然而导演告诉我并不是的，是因为本来有小妹妹要和我玩，结果别人家长不让，那我就要搞死他们！WTF？这哪是魔丸，这完全就是熊孩子的定位，而且还是很让人厌烦那种熊孩子，一度感到恶心难受🤢。她妈与他也是同样的问题，一口不知道什么味的口音，听的一度出戏（好像也没入戏过🤭）。觉得最受不了的是，我很爱你，很想陪伴你，你只能活三年，可是我要去打妖怪，那你就哪边凉快哪边呆着去吧？？？斩妖除魔为他积德，是希望能多活一分钟么？？？那不然，放弃与娃儿相处，你得到了什么？？？影片并没有强调希望得到认同，如果是希望被认同，那应该是带着一路去打妖怪，看到踢键子的时候一度以为会这样发展。</p><p>看到龙宫出场后，又开始YY这条故事线，感觉很有意思很有搞头呀，场景布置的那么好，也是一个那么有故事的背景线。描绘的这天庭，真的很“天庭”，感觉也释怀为什么要选择太乙真，为什么要当申公豹的面给太乙真人升职🤣。</p><p>影片的价值观和不想做过多评价，太多人讲了，这思想，这态度，这评论反馈，第一联想到的就是战狼、流浪地球。。。不可说</p><p>最后这结尾，强行打一架，强行帮你忙，强行黑化，再强行洗白，这。。。短短的一二十分钟发生的事情太多了，有点接受的不能。太智障，让人想到的可能就是大鱼海棠了～～😂</p><p>以上只是个人吐槽，都熬夜看电影了，再熬夜写个吐槽好像也说得过去。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Jackson 使用总结]]></title>
            <link>https://wener.me/story/jackson-summary</link>
            <guid>jackson-summary</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[动态策略]]></description>
            <content:encoded><![CDATA[<h2>动态策略</h2><p>动态策略概念相对宽泛，在进入正式的内容之前容我先明确题目中动态策略的范畴。</p><p>这里的动态策略指，现在以 A 方式来做某件事，在过程中可能被切换为 B 方案，但对上层来说是无感的。策略可以映射为策略模式（Strategy Pattern），例如</p><p><em>图片缺失</em></p><p>上下文依赖了一个 IStrategy 接口，而 IStrategy 有两种实现，StrategyA、StrategyB，在运行中可能是选择的 A 策略或 B 策略。再一个现实一点的例子</p><p><em>图片缺失</em></p><p>图例描述了一个具体的存储策略，CachedStrategy 是带缓存的存储策略， cache 和 backend 实现缓存逻辑，IStorage 本身是抽象的接口，因此缓存逻辑也只需要依赖接口而不需要关心具体实现。MemoryStorage 是一个内存存储，数据存在内存的 Map 中，RedisStorage 是访问远程的存储。所有的这些策略细节对上层而言都是无感的，最上层使用的依然是一个存储接口。</p><p>这样的策略是还可以叠加的，这样做策略的目的是简化了单个策略实现的复杂度，专注于实现一个功能点，如果不使用策略，则需要在一个实现类里实现过多的逻辑，当面临新的需求，接入新的适配的时候，导致改动会异常困难，以下的伪代码展示了这样的区别</p><p><strong>单个类实现</strong></p><pre><code class="language-js">class StorageImpl {
  constructor({ redisUrl, redisPort }) {
    this.cache = {};
    this.redis = new Redis({ url: redisUrl, port: redisPort });
  }
  get(key) {
    if (this.cache[key]) {
      return this.cache[key];
    }
    let val = this.redis.get(key);
    if (val) {
      this.cache[key] = val;
    }
    return val;
  }
  set(key, value) {
    delete this.cache[key];
    this.redis.set(key, value);
  }
}
</code></pre><p><strong>接口策略实现</strong></p><pre><code class="language-js">class CachedStorage {
  constructor({ cache, backend }) {
    this.cache = cache;
    this.backend = backend;
  }
  get(key) {
    let val = this.cache.get(key);
    if (!val) {
      val = this.backend.get(key);
      if (val) {
        this.cache.set(key, val);
      }
    }
    return val;
  }
  set(key, val) {
    this.cache.set(key, null);
    this.backend.set(key, val);
  }
}

class MemoryStorage {
  constructor() {
    this.data = {};
  }
  get(key) {
    return this.data[key];
  }
  set(key, val) {
    this.data[key] = val;
  }
}

class RedisStorage {
  constructor({ url, host }) {
    this.redis = new Redis({ url, port });
  }
  get(key) {
    return this.redis.get(key);
  }
  set(key, val) {
    this.redis.set(key, val);
  }
}
</code></pre><p>当代码和策略较少的时候，可能直接实现是更简单的，但当策略逐渐增多，业务逻辑越加复杂的时候，写在单个实现中是非常难以维护的，一些简单的例子，例如 后端访问需要支持按 key 进行分片访问，支持从另外一种存储加载数据。</p><p>策略可以很灵活，且不可预知的，因此需要实现这样的策略管理直接硬编码的方式是不可行的。</p><h2>基于 JSON 的动态策略配置</h2><p>每个策略都是一个通用的接口实现，一个策略的实现可能依赖其它策略，这样的结构是一个树形的，那么配置也是一个树形的结构，例如</p><pre><code class="language-json">{
  &quot;type&quot;: &quot;cached&quot;,
  &quot;cache&quot;: {
    &quot;type&quot;: &quot;memory&quot;
  },
  &quot;backend&quot;: {
    &quot;type&quot;: &quot;redis&quot;,
    &quot;port&quot;: 6379,
    &quot;host&quot;: &quot;127.0.0.1&quot;
  }
}
</code></pre><p>整体结构与策略的组成一致，从配置角度来说，非常直观便于理解。但实际使用时需要进行解析处理并映射为具体的策略实现。</p><p>在现有的 Java JSON 解析库中，Jackson 功能最为丰富，要实现这样的策略配置有三种方式</p><ol><li>JSON -&gt; 配置对象 -&gt; 实现<ul><li>何时选用：实现复杂，有较多运行状态</li><li>需要额外的一次实现映射</li><li>序列化反序列化简单</li></ul></li><li>JSON -&gt; 实现<ul><li>何时选用：实现简单，运行状态可控</li><li>需要额外方法进行初始化</li><li>状态字段需要注意不要被序列化 - <code>@JsonIgnore</code> 或 transient</li></ul></li><li>JSON-&gt;抽象配置对象-&gt;抽象实现-&gt;实际配置对象-&gt;实际实现<ul><li>何时选用：实现复杂且有继承关系，每一层实现复杂处理不同的配置</li><li>需要基于配置对象，配置对象有继承关系</li><li>配置对象能持有任意配置内容，不同配置对象可在不丢失数据的前提下互相转换</li></ul></li></ol><h3>配置过程</h3><p>以下代码演示了使用配置对象来实现配置的抽象序列化和反序列化</p><pre><code class="language-java">public class ConfigObjectDemo {
    @Test
    public void test() throws IOException {
        ObjectMapper mapper = new ObjectMapper();

        String config = &quot;{\&quot;type\&quot;:\&quot;cached\&quot;,\&quot;cache\&quot;:{\&quot;type\&quot;:\&quot;memory\&quot;},\&quot;backend\&quot;:{\&quot;type\&quot;:\&quot;redis\&quot;,\&quot;port\&quot;:6379,\&quot;host\&quot;:\&quot;127.0.0.1\&quot;}}&quot;;
        StorageConfig storageConfig = mapper.readValue(config, StorageConfig.class);
        // 输出 CachedStorageConfig(cache=MemoryConfig(), backend=RedisConfig(host=127.0.0.1, port=6379))
        System.out.println(storageConfig);
        // 输出 {&quot;type&quot;:&quot;cached&quot;,&quot;cache&quot;:{&quot;type&quot;:&quot;memory&quot;},&quot;backend&quot;:{&quot;type&quot;:&quot;redis&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:6379}}
        System.out.println(mapper.writeValueAsString(storageConfig));
    }
}

@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = &quot;type&quot;)
@JsonSubTypes({
        @JsonSubTypes.Type(value = CachedStorageConfig.class, name = &quot;cached&quot;),
        @JsonSubTypes.Type(value = MemoryConfig.class, name = &quot;memory&quot;),
        @JsonSubTypes.Type(value = RedisConfig.class, name = &quot;redis&quot;)
})
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY, getterVisibility = JsonAutoDetect.Visibility.NONE)
interface StorageConfig{ String getType();}

@Data
class CachedStorageConfig implements StorageConfig{
    private StorageConfig cache;private StorageConfig backend;
    @Override public String getType() { return &quot;cached&quot;; }
}
@Data
class MemoryConfig implements StorageConfig{ @Override public String getType() { return &quot;memory&quot;; }}
@Data
class RedisConfig implements StorageConfig{
    private String host; private int port;
    @Override public String getType() { return &quot;redis&quot;; }
}
</code></pre><p>在这里看到比较复杂的注解是 <code>@JsonSubTypes</code>，该注解配置了类型与实际实现的映射关系，而 <code>@JsonTypeInfo</code> 配置了那个字段作为类型信息字段。通过注解的方式配置不太灵活，可能有时候会忽略配置或配置错误，且不能动态增加。</p><p>解决配置比较问题也有两种办法，第一种办法是保留 <code>@JsonTypeInfo</code> 注解，然后手动进行映射关系的配置，例如</p><pre><code class="language-java">ObjectMapper mapper = new ObjectMapper();
mapper.registerSubtypes(new NamedType(CachedStorageConfig.class,&quot;cached&quot;));
mapper.registerSubtypes(new NamedType(MemoryConfig.class,&quot;memory&quot;));
mapper.registerSubtypes(new NamedType(RedisConfig.class,&quot;redis&quot;));
</code></pre><p>结果与通过注解的方式配置是相同的，这样就可以动态配置了。如果连 <code>@JsonTypeInfo</code> 也不想要，希望通过代码完全动态添加，这样的过程会比较复杂。最终的结果类似于</p><pre><code class="language-java">// 注册一个动态类型，且说明如何获取到类型
MyJson.registerDynamicType(StorageConfig.class, StorageConfig::getType);
MyJson.registerDynamicSubtypes(StorageConfig.class, new NamedType(CachedStorageConfig.class, &quot;cached&quot;));
MyJson.registerDynamicSubtypes(StorageConfig.class, new NamedType(MemoryConfig.class, &quot;memory&quot;));
MyJson.registerDynamicSubtypes(StorageConfig.class, new NamedType(RedisConfig.class, &quot;redis&quot;));
</code></pre><p><code>registerDynamicType</code> 和 <code>registerDynamicSubtypes</code> 的实现可参考<a href="https://github.com/wenerme/wava/blob/a216dfe8e92fe4822c9659949fbe862b9419eef4/wava-common/src/main/java/me/wener/wava/util/JSON.java#L114">这里</a>。</p><p>至此便完成了所有的动态配置，反序列化为配置对象和实现没有特别大的区别，只需要控制好字段可见性即可。</p><p>使用抽象配置，则需要能够记录完整的信息，从抽象配置转换为实际配置时不能丢配置内容，使用 Jackson，可使用 <code>@JsonAnyGetter</code> 和 <code>@JsonAnySetter</code> 实现，因为我会定义一个类似如下的基础类</p><pre><code class="language-java">public class PropertyObject {
    @JsonIgnore @Setter private Map&lt;String, Object&gt; properties;

    @JsonAnyGetter public Map&lt;String, Object&gt; getProperties() { return properties; }
    @JsonAnySetter
    public Object set(String name, Object value) {
        if (properties == null) { properties = Maps.newHashMap(); }
        return properties.put(name, value);
    }
}
</code></pre><p>完整定义参考 <a href="https://github.com/wenerme/wava/blob/a216dfe8e92fe4822c9659949fbe862b9419eef4/wava-common/src/main/java/me/wener/wava/model/PropertyObject.java">PropertyObject</a>。</p><p>对配置的处理则可以使用类似责任链的方式，如果实现对配置感兴趣，则将其转换为自己感兴趣的配置对象，这样也便于添加注解进行校验和验证。</p><blockquote><p>实现过程</p><p>配置的正确处理和校验使得实现过程相对简单，相当于确定了程序的所有入参，实现便不在此赘述。</p></blockquote><h2>策略扩展</h2><p>每一种策略实际对应的都是一部分业务逻辑，那么 <code>1+1</code> 和 <code>1-1</code> 也是可以被认为是两种策略，在<a href="https://wener.me/story/get-started-with-dsl/">从 0 到 1 实现自定义语言</a>中有提到，语言被解析后会生成语法树，而语法树也可以理解为是一种树形的策略逻辑。表达式中的通用节点一般叫做 Expression，而每个 Expression 都可以计算出来一个值，这个值可以隐含在其它的一个 Expression 中，例如 1+1 可以表示为</p><pre><code class="language-json">{
  &quot;type&quot;: &quot;BinaryOperation&quot;,
  &quot;operator&quot;: &quot;ADD&quot;,
  &quot;left&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: 1 },
  &quot;right&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: 1 }
}
</code></pre><p>而 1+1+1 则表示为</p><pre><code class="language-json">{
  &quot;type&quot;: &quot;BinaryOperation&quot;,
  &quot;operator&quot;: &quot;ADD&quot;,
  &quot;left&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: 1 },
  &quot;right&quot;: {
    &quot;type&quot;: &quot;BinaryOperation&quot;,
    &quot;operator&quot;: &quot;ADD&quot;,
    &quot;left&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: 1 },
    &quot;right&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: 1 }
  }
}
</code></pre><p>其序列化和反序列化之前讨论的配置是完全一致的。很多的业务逻辑本身也是可以通过表达式来表述的，而使用表达式则能是的场景配置更为灵活。</p><h2>实际应用</h2><p>以下列举在实例开发中使用到的场景，三种场景各不相同。</p><h3>奥格存储</h3><p>在 奥格人群二方包开发总结 中有提到底层存储的复杂性</p><p><em>图片缺失</em></p><p>该配置的实现便是基于这样的配置逻辑实现的。分别对应接口</p><ul><li>CrowdStorage</li><li>CrowdStore</li></ul><p>如果集成了奥格二方包 是看得到相应实现的。</p><p>使用的是 JSON 直接反序列化为实现的方式。</p><h3>任务调度</h3><p>奥格的渠道管理底层实现是一套相对通用的，在总结中提到多层级的支持便是通过抽象配置实现</p><ul><li>任务调度支持
<em> 渠道投放
</em> 渠道支持 - 短信、外呼、邮件/SMTP
<em> 数据源支持 - 接口、人群、ODPS
</em> 调度支持 - 单次、周期、手动</li></ul><p>配置对象类图如下</p><p><em>图片缺失</em></p><h3>状态人群表达式</h3><p>奥格二方包现有表达式处理能力，但在下一个版本中该功能会被增强，将不在客户端解析编译，而是在服务端处理后下发语法树，下发的语法树其实就是一个策略配置，表达式的类图如下</p><p><em>图片缺失</em></p><h2>总结</h2><p>熟练的掌握和使用各种场景下的配置可以减少大量的不必要的处理逻辑，且能减少不少的 BUG，一些 Bad Smell 例如 <code>JSON.parse(jsonString).get(&quot;someThing&quot;).asLong()</code> 是应该被避免的，因为没有人能知道这是在做什么，也不知道里面都有什么，像是一个黑盒。开发时往往业务逻辑是相对简单的，但是确保拿到正确的配置很难，面向失败设计，开闭原则，有问题的地方必然会出问题，往往我们用来校验是否正确的代码比实际的代码还要多，当遇到这样问题的时候，思考是否有更好的方式来做这些事情。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hello CGO]]></title>
            <link>https://wener.me/story/hello-cgo</link>
            <guid>hello-cgo</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[Tips]]></description>
            <content:encoded><![CDATA[<h2>Tips</h2><ul><li><a href="https://gist.github.com/zchee/b9c99695463d8902cd33">类型转换</a></li></ul><h2>初试</h2><pre><code class="language-bash"># 生成 libdemo.so libdemo.h
go build -buildmode=c-shared -o libdemo.so ./demo.go
# 编译 main
go build main.go
./main

# macos - 查看内容
nm libdemo.so | grep hello -i
# linux
nm libdemo.so
# windows
dumpbin /EXPORTS libdemo.dll

# windows 交叉编译 - 需要安装 mingw
brew install mingw-w64

# 32 位 交叉编译
GOOS=windows GOARCH=386 CGO_ENABLED=1 CC=i686-w64-mingw32-gcc go build -buildmode=c-shared -o libdemo.dll ./demo.go
GOOS=windows GOARCH=386 CGO_ENABLED=1 CC=i686-w64-mingw32-gcc go build main.go

# macos wine 不支持 32 位 - mingw 版本低不支持 64 位
# mac 会出现异常 cc1: sorry, unimplemented: 64-bit mode not compiled in
# 通过 docker 编译
docker run --rm -v $HOME/go:/root/go -v $PWD:/host -w /host wener/go:win sh

GOOS=windows GOARCH=amd64 CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc go build -buildmode=c-shared -o libdemo.dll ./demo.go
GOOS=windows GOARCH=amd64 CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc go build main.go

# 回到 mac 使用 wine 执行
# wine 无法在 macos 上编译安装 - 系统版本问题 - 需要使用 cask 安装
brew cask install wine-stable
wine64 main.exe

# wine 4.0 初始化 dll 失败
# 0010:fixme:winsock:set_dont_fragment IP_DONTFRAGMENT for IPv4 not supported in this platform
# 0009:err:module:attach_dlls &quot;libdemo.dll&quot; failed to initialize, aborting
# 0009:err:module:attach_dlls Initializing dlls for L&quot;Z:\\Users\\wener\\demo\\main.exe&quot; failed, status c0000005
</code></pre><p><strong>demo.go</strong></p><pre><code class="language-go">package main

import &quot;C&quot;

//export Version
func Version() int32 {
    return 123
}

//export Hello
func Hello(name *C.char) *C.char {
    return C.CString(&quot;Hello &quot;+C.GoString(name)+&quot;!&quot;)
}

func main() {}
</code></pre><p><strong>main.go</strong></p><pre><code class="language-go">package main

import &quot;fmt&quot;

/*
#cgo CFLAGS: -I.
#cgo LDFLAGS: -L. -ldemo
#include &quot;libdemo.h&quot;
*/
import &quot;C&quot;

func main() {
    fmt.Printf(&quot;Int %v String %v\n&quot;,C.Version(), C.GoString(C.Hello(C.CString(&quot;Wener&quot;))))
}
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[一周 K3S 学习心得]]></title>
            <link>https://wener.me/story/k3s-one-week</link>
            <guid>k3s-one-week</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[k3s-one-week]]></description>
            <content:encoded><![CDATA[<p><img src="./k3s-one-week.png" alt="k3s-one-week"/></p><blockquote><p>K3S is five times eaiser than K8S 😊</p></blockquote><h2>一点点历史</h2><p>刚开始了解 K8S 是大约 1.4 版本 Beta 时（2016），<a href="http://kubernetes.io/docs/getting-started-guides/kubeadm/">kubeadm</a> 刚开始有一定雏形，K8S 才开始在一般大众面前展露头角。</p><p>当时的 Docker 编排工具算是百花齐放，但当时如果想要玩好 K8S 是相当难的，因为 K8S 谷歌牵头开发，所有镜像都在 gcr 上，门槛已经算比较高了。而且部署用的工具也还相当不成熟，没有专业的运维部署都很难，况且还需要专人维护。</p><p>而今天，2020，K8S 已经有很多发行版了，大多编排平台底层如果不是基于 K8S 那也是支持 K8S。Rancher 1.0 转型到 2.0 时抛弃了之前的模式，选择了基于 K8S，Rancher 定位为集群管理。</p><p>因此 Rancher 之下诞生了很多辅助于 K8S 平台的工具和周边，K3S 也算是核心之一。</p><p>在这之前对于 K8S 仅限于了解，而现在则是需要考虑使用了，因此开始重新学习。</p><h2>关于 K3S</h2><p>K3S 大大降低了 K8S 的门槛，主要在于</p><ul><li>单机可启动</li><li>Docker 可启动</li><li>不再依赖 etcd</li></ul><p>如果用不到集群，K3S+Dashboard 用来做单机的 Docker 界面都是非常合适的。</p><h2>学习过程总结</h2><h3>理解 K3S</h3><p>Kubernates 的核心是依赖 ETCD 作为核心状态存储，就好比 Hadoop 核心依赖 Zookeeper 一样，而 K3S 以 Adapter <a href="https://github.com/rancher/kine">kine</a> 替代了对 etcd 的依赖，暴露 etcd 能力，但后端存储被适配到</p><ul><li>SQLite</li><li>DQLite</li><li>MySQL</li><li>Postgres</li></ul><p>在部署集群 K3S 时候只要选择的存储是网络数据库存储或者内嵌的 DQLite 即可。</p><p>K3S 是单独的可执行文件，将所需的大部分功能都打包到了内部</p><ul><li>k3s server - 主节点守护进程</li><li>k3s agent - 从节点守护进程</li><li>kubectl - 与 k8s 的交互工具</li><li>crictl - containerd 调试工具</li></ul><p>在启动 k3s 的 server 或 agent 时会通过容器（docker 或者 containerd）启动 K8S 的核心服务（例如 apiserver）。使得在部署 K3S 时异常简单，所有依赖都在一个二进制，也因为这样，支持 arm 也只需要再次进行编译单个的可执行文件即可（当然也要有容器镜像是支持对应架构的）。</p><p>不仅是简化了部署和集群一致性的依赖，K3S 针对部分核心服务有默认配置，并且提供了部分核心服务的实现</p><ul><li>servicelb - <a href="https://github.com/rancher/klipper-lb">rancher/klipper-lb</a><ul><li>提供最简化的 lb 实现 - 选择开放端口</li></ul></li><li>traefik<ul><li>提供 Ingress 和 LB</li></ul></li><li><a href="https://github.com/kubernetes-sigs/metrics-server">metric-server</a></li><li>cloud manager - K8S 能获取到节点信息</li><li>corndns</li></ul><p>K3S server/agent 相当于是 kubeadm + 部分控制器实现。</p><h3>部署 K3S</h3><p>官方给的部署就一行命令</p><pre><code class="language-bash">curl -sfL https://get.k3s.io | sh -
</code></pre><p>拉取脚本并执行，但初次使用，还是建议自行手动部署，脚本简单明了，阅读后就知道<a href="https://wener.me/notes/devops/kubernetes/k3s#getk3sio">做了什么</a>。</p><p>如果对于大批量部署，建议提前下载 k3s 然后上传启动即可。</p><h3>部署选择</h3><p>K8S 是分布式的 容器 编排工具，所有的功能都是围绕这个核心来展开的，因为分布式，那也必然面对着所有分布式平台都会面临的问题。</p><p>通常的单节点应用我们考虑的是</p><ul><li>CPU+内存 - 计算 - 基础资源</li><li>带宽 - 网络</li><li>磁盘 - 存储</li></ul><p>在部署 Kubernates 的时候最开始也是考虑这些问题，K3S 的单节点部署能够把这些问题的思考时间滞后，但还是需要解决的。
并且部署的过程就是各种选择权衡的问题，再结合自身实际使用情况和资源硬件情况进行决策。</p><ul><li>计算资源 - 阿里云、物理机、虚拟机</li><li>网络 - 如何组网<ul><li>跨网络</li><li>混合网络</li></ul></li><li>存储</li><li>容器运行环境 - docker、containerd</li><li>cni<ul><li>flannel 组网方式 - wireguard、host-gw、vxlan</li><li>calico</li><li>wave</li><li>其他。。。</li></ul></li><li>servicelb - 内建、metallb</li><li>ingress - traefik1（默认）、traefik2、nginx、haproxy、envoy、云平台提供</li><li>K3S 存储后端 - Postgres、MySQL</li></ul><p>目前有的人员、硬件资源、平台、已有环境</p><ul><li>人员 - 1 个人 - 我</li><li>硬件<ul><li>1 服务器 - 40 核 250G</li><li>阿里云若干</li><li>腾讯云若干</li><li>小型物理机若干</li><li>树莓派若干</li></ul></li><li>平台<ul><li>AMD64、ARM64</li><li>阿里云、腾讯云</li></ul></li><li>已有<ul><li>Tinc</li></ul></li></ul><p>做了如下的规划部署</p><ul><li>计算资源<ul><li>阿里云 - Bare Metal</li><li>服务器开虚拟机 - libvirt+qemu+kvm</li><li>物理机看情况开始虚拟机或直接使用</li><li>树莓派直接安装</li></ul></li><li>网络 - flannel-host-gw + tinc + metallb<ul><li>例如 10.10.0.0/16、其中 10.10.0.0/18 预留为宿主机、10.10.64.0/18 预留给 metallb 分配</li></ul></li><li>存储 - zfs+longhorn<ul><li>选取部分节点</li></ul></li><li>容器运行环境 - docker</li><li>servicelb - metallb</li><li>ingress - traefik2<ul><li>阿里云节点作为对外入口</li></ul></li><li>K3S 存储后端 - 阿里云 Postgres</li></ul><p>部署完成后只是第一步，开始了解<a href="https://wener.me/notes/devops/kubernetes/k8s-glossary">各种概念</a>部署各种服务适配各种场景才是更重要的。</p><h2>是否应该选择 K3S</h2><p>如果你犹豫使用 K3S 还是使用 K8S 请思考以下问题</p><ul><li>公司在平台投入多少 ？</li><li>有多少专人维护 ？<ul><li>K8S 建议至少 3-5 人</li></ul></li><li>节点资源性能如何 ？<ul><li>K8S 建议至少 8 核 32G - 否则基础服务占用资源不能被平摊</li></ul></li><li>是否选择托管的 K8S ？<ul><li>不存在使用 K3S</li></ul></li><li>混合云、私有云、公有云 ？</li></ul><p>或者用最简单的方式判断</p><ul><li>节点数 &lt;=50 选择 K3S<ul><li>一人工作量</li></ul></li><li>50 &lt; 节点数 &lt;= 150 选择 K3S 或 K8S</li><li>节点数量 &gt; 150 选择 K8S<ul><li>有这样的规模，运维必然是一个团队，因此不存在 K8S 复杂的问题</li></ul></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[你就是你]]></title>
            <link>https://wener.me/story/cyw-without-w</link>
            <guid>cyw-without-w</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[YUN]]></description>
            <content:encoded><![CDATA[<p><img src="./yun-explained.png" alt="YUN"/></p><blockquote><p>CYW 没有了 我(W) 便是 你(CY)</p><p>-- wener</p></blockquote><p>天晴下雨是个很难说得清楚的东西，但蕴和温其实是两个字。</p><p>对于社会人的不理解，你可以认识“蕴藏”，可以认识“温暖”，但当单独看到蕴的时候，他应该还是读作 yùn。</p><p>妈妈说：“你欠我的太多！”（不可否认）🤷‍♂️
妈妈还说：“名‘欠肖’好了”</p><p>但你还是你，不应该携带我们的影子。</p><p>2020一个一点点起伏动荡的数字，但你能看到2100，那应该是一番非常值得期待的景象，有憧憬才会有前进的动力。
而你是我们的憧憬，不过所幸的是你的父母足够“大条”，不需要有心里压力（生活有压力了还请自助），保持现在的开心快乐就好。
不过其实开心快乐的可能是我们？那这些年还请多多担待，多多包容，多多理解。</p><p>我们彼此的伴随是生命的延续，这些年且算是为了更好的了解彼此，生活在一起。</p><p>伴随的是爽朗的笑声，豪放的哭声，咿咿呀呀哦哦的儿星语？
还有现在会说的话，“妈妈”，“爸爸”，“奶奶”，“拿来”？好像没什么问题？🤭</p><p>给你的是所有，毕竟你是唯一留下的。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[开源 BI 产品比较]]></title>
            <link>https://wener.me/story/compare-os-bi-tool</link>
            <guid>compare-os-bi-tool</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[比较 Metabase、Redash、Superset 这几款开源的 BI 产品。]]></description>
            <content:encoded><![CDATA[<p>比较 Metabase、Redash、Superset 这几款开源的 BI 产品。</p><table><thead><tr><th>Name</th><th>License</th><th>Stars</th><th>Languages</th><th>Deps</th><th>Github</th></tr></thead><tbody><tr><td>Metabase</td><td>AGPL</td><td><img src="https://img.shields.io/github/stars/metabase/metabase"/></td><td>Clojure</td><td>H2/PostgreSQL</td><td><a href="https://github.com/metabase/metabase">metabase/metabase</a></td></tr><tr><td>Redash</td><td>BSD</td><td><img src="https://img.shields.io/github/stars/getredash/redash"/></td><td>JS</td><td>Redis+DB</td><td><a href="https://github.com/getredash/redash">getredash/redash</a></td></tr><tr><td>Superset</td><td>Apache</td><td><img src="https://img.shields.io/github/stars/apache/superset"/></td><td>Python</td><td>Cache+DB</td><td><a href="https://github.com/apache/superset">apache/superset</a></td></tr></tbody></table><ul><li>metabase<ul><li>界面操作友好</li><li>偏向于产品</li><li>图表类型少</li><li>AGPL</li><li>嵌入去 Logo 收费 - 300$/月 3000$/年</li><li>商业版 - 10000+ \$/年<ul><li>嵌入无 Logo</li><li>SSO - SAML</li><li>行级权限</li><li>审计工具</li></ul></li><li>可单个 Docker 直接启动 - 使用 H2 嵌入式数据库</li><li>界面好看 - 本地化很好、分享友好</li></ul></li><li>redash<ul><li>纯 SQL</li><li>图表使用 PlotlyJS<ul><li>可以理解为 Redash 只负责处理数据</li></ul></li><li>支持最多的数据源/JDBC</li><li>没有本地化</li></ul></li><li>superset<ul><li>支持最多的图表</li><li>既可以 SQL 又可以 UI</li><li>功能最强</li><li>扩容性最好 - 支持大规模分析场景</li><li>界面偏运维 - 部分本地化</li><li>能自定义 CSS</li><li>默认 <strong>不能</strong> 公共分享</li></ul></li></ul><h2>数据源类型</h2><ul><li>Redash <a href="https://redash.io/help/data-sources/supported-data-sources">Supported Data Sources</a></li><li>Superset <a href="https://superset.incubator.apache.org/#databases">supported database</a><ul><li>DB-API</li><li>SQLAlchemy</li></ul></li></ul><table><thead><tr><th>Data Source</th><th>Redash</th><th>Metabase</th><th>Superset</th></tr></thead><tbody><tr><td>Amazon Athena</td><td>✅</td><td></td><td>✅</td></tr><tr><td>Amazon DynamoDB</td><td>✅</td><td></td><td></td></tr><tr><td>Amazon Redshift</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Apache Drill</td><td></td><td></td><td>✅</td></tr><tr><td>Apache Hive</td><td>✅</td><td></td><td>✅</td></tr><tr><td>Apache Impala</td><td>✅</td><td></td><td>✅</td></tr><tr><td>Apache Kylin</td><td>✅</td><td></td><td>✅</td></tr><tr><td>Apache Pinot</td><td></td><td></td><td>✅</td></tr><tr><td>Apache SparkSQL</td><td></td><td>✅</td><td>✅</td></tr><tr><td>Axibase Time Series Database</td><td>✅</td><td></td><td></td></tr><tr><td>CSV</td><td>✅</td><td></td><td></td></tr><tr><td>Cassandra</td><td>✅</td><td></td><td></td></tr><tr><td>ClickHouse</td><td>✅</td><td></td><td>✅</td></tr><tr><td>CockroachDB</td><td>✅</td><td></td><td>✅</td></tr><tr><td>DB2 by IBM</td><td>✅</td><td></td><td>✅</td></tr><tr><td>Databricks (Apache Spark)</td><td>✅</td><td></td><td></td></tr><tr><td>Dremio</td><td></td><td></td><td>✅</td></tr><tr><td>Druid</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Elasticsearch</td><td>✅</td><td></td><td>✅</td></tr><tr><td>Exasol</td><td></td><td></td><td>✅</td></tr><tr><td>Google Analytics</td><td>✅</td><td></td><td></td></tr><tr><td>Google BigQuery</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Google Spreadsheets</td><td>✅</td><td></td><td>✅</td></tr><tr><td>Graphite</td><td>✅</td><td></td><td>✅</td></tr><tr><td>Greenplum</td><td>✅</td><td></td><td>✅</td></tr><tr><td>H2</td><td></td><td>✅</td><td></td></tr><tr><td>Hana</td><td></td><td></td><td>✅</td></tr><tr><td>InfluxDB</td><td>✅</td><td></td><td></td></tr><tr><td>JIRA</td><td>✅</td><td></td><td></td></tr><tr><td>JSON</td><td>✅</td><td></td><td></td></tr><tr><td>MemSQL</td><td>✅</td><td></td><td></td></tr><tr><td>Microsoft Azure Data Warehouse / Synapse</td><td>✅</td><td></td><td></td></tr><tr><td>Microsoft Azure SQL Database</td><td>✅</td><td></td><td></td></tr><tr><td>Microsoft SQL Server</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>MongoDB</td><td>✅</td><td>✅</td><td></td></tr><tr><td>MySQL</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>OmniSciDB (Formerly MapD)</td><td>✅</td><td></td><td></td></tr><tr><td>Oracle</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>PostgreSQL</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Presto</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Prometheus</td><td>✅</td><td></td><td></td></tr><tr><td>Python</td><td>✅</td><td></td><td></td></tr><tr><td>Qubole</td><td>✅</td><td></td><td></td></tr><tr><td>Rockset</td><td>✅</td><td></td><td></td></tr><tr><td>SQLite</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Salesforce</td><td>✅</td><td></td><td></td></tr><tr><td>ScyllaDB</td><td>✅</td><td></td><td></td></tr><tr><td>Shell Scripts</td><td>✅</td><td></td><td></td></tr><tr><td>Snowflake</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>TreasureData</td><td>✅</td><td></td><td></td></tr><tr><td>Vertica</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Yandex AppMetrrica</td><td>✅</td><td></td><td></td></tr><tr><td>Yandex Metrica</td><td>✅</td><td></td><td></td></tr></tbody></table><h2>metabase</h2><ul><li>语言<ul><li>Clojure</li><li>React</li></ul></li><li>参考<ul><li><a href="https://www.metabase.com/docs/latest/operations-guide/running-metabase-on-docker.html">安装文档</a></li></ul></li></ul><pre><code class="language-bash"># H2
docker run -d -p 3000:3000 \
  -v $PWD/metabase-data:/metabase-data \
  -e &quot;JAVA_TIMEZONE=Asia/Shanghai&quot; \
  -e &quot;MB_DB_FILE=/metabase-data/metabase.db&quot; \
  --name metabase metabase/metabase

# PG
docker run -d -p 3000:3000 \
 -e &quot;MB_DB_TYPE=postgres&quot; \
 -e &quot;MB_DB_DBNAME=metabase&quot; \
 -e &quot;MB_DB_PORT=5432&quot; \
 -e &quot;MB_DB_USER=&lt;username&gt;&quot; \
 -e &quot;MB_DB_PASS=&lt;password&gt;&quot; \
 -e &quot;MB_DB_HOST=my-database-host&quot; \
 --name metabase metabase/metabase
</code></pre><h2>redash</h2><ul><li>语言<ul><li>NodeJS</li><li>Python + Flask + gunicorn + celery</li></ul></li><li>依赖<ul><li>PostgreSQL</li><li>Redis</li></ul></li><li>参考<ul><li><a href="https://redash.io/help/open-source/setup">安装文档</a></li><li><a href="https://github.com/getredash/setup/blob/master/data/docker-compose.yml">docker-compose.yml</a><ul><li>server - redash/redash</li><li>scheduler</li><li>scheduled_worker</li><li>adhoc_worker</li><li>redis</li><li>postgres</li><li>nginx</li></ul></li><li><a href="https://discuss.redash.io/t/worker-architecture-question/5025">Worker architecture question</a></li></ul></li><li>架构<ul><li>热查询（adhoc query - 用户发起）使用 查询 Celery 队列</li><li>周期查询（scheduled_queries - scheduler 发起）使用 scheduled 队列</li><li>Celery 支持设置队列的 worker 数，默认启动会分离 adhoc 和 scheduled 队列</li><li>会切换到 RQ - Redis Queue</li></ul></li></ul><h3>启动配置</h3><ul><li><a href="https://redash.io/help/open-source/admin-guide/env-vars-settings">环境变量配置</a></li><li>初始化使用 python <a href="https://github.com/getredash/redash/blob/master/redash/settings/__init__.py">脚本</a></li><li><a href="https://redash.io/help/open-source/admin-guide/how-to-upgrade">升级</a></li></ul><pre><code class="language-bash"># compose 中使用的该目录
mkdir /opt/redash
cd /opt/redash

curl -LO https://raw.githubusercontent.com/getredash/setup/master/data/docker-compose.yml
touch env

docker-compose -f docker-compose.yml up
</code></pre><h3>ERROR: relation &quot;queries&quot; does not exist</h3><ul><li>脚本位于 <code>./setup/docker/create_database.sh</code></li></ul><pre><code class="language-bash">docker-compose run --rm server manage database create_tables
docker-compose run --rm server manage db upgrad
</code></pre><h2>superset</h2><ul><li>语言<ul><li>Python - Flask + Celery</li><li>Typescript</li></ul></li><li>机构依赖<ul><li>元数据存储 MySQL, Postgres, MariaDB, SQLite</li><li>消息队列 Redis, RabbitMQ, SQS</li><li>结果存储 S3, Redis, Memcached</li><li>缓存 Memcached, Redis</li><li>WebServer 和 Celery 是无状态的 - 易于扩容</li></ul></li><li>注意<ul><li>默认不允许公共访问，需要 <a href="https://superset.incubator.apache.org/security.html?highlight=public#public">配置</a></li></ul></li><li>参考<ul><li><a href="https://superset.incubator.apache.org/installation.html">安装文档</a></li><li><a href="https://github.com/apache/incubator-superset/blob/master/docker-compose.yml">docker-compose.yml</a><ul><li>需要先 Build 在启动</li><li>redis</li><li>db - postgres</li><li>superset</li><li>superset-init - 构建</li><li>superset-node - 前端</li><li>superset-worker</li><li>superset-tests-worker</li></ul></li><li><a href="https://github.com/amancevice/docker-superset">amancevice/docker-superset</a> - 单 docker 启动 superset<ul><li><a href="https://github.com/amancevice/docker-superset/tree/main/examples">启动示例</a></li></ul></li><li><a href="https://preset.io/blog/2020-07-02-hello-world/">如何新增插件</a></li><li>K8S Helm 部署 <a href="https://github.com/helm/charts/blob/master/stable/superset">stable/superset</a></li></ul></li></ul><pre><code class="language-bash">mkdir /opt/superset
cd /opt/superset

# SQLite
# ==========
curl -LO https://raw.githubusercontent.com/amancevice/docker-superset/main/examples/sqlite/superset_config.py
curl -LO https://raw.githubusercontent.com/amancevice/docker-superset/main/examples/sqlite/docker-compose.yml

# 会使用 local volume 挂载数据
docker-compose up -d
sleep 30
# 初始化 - 创建账号密码、初始数据库
docker-compose exec superset superset-demo

# 已有 PostgreSQL
# ==========
cat &lt;&lt;YAML &gt; docker-compose.yml
version: &#x27;3&#x27;
services:
  redis:
    image: redis
    restart: always
    volumes:
      - redis:/data
  superset:
    image: amancevice/superset
    restart: always
    depends_on:
      - redis
    environment:
      MAPBOX_API_KEY: ${MAPBOX_API_KEY}
    ports:
      - &quot;8088:8088&quot;
    volumes:
      - ./superset_config.py:/etc/superset/superset_config.py
volumes:
  redis:
YAML
# 数据库链接
# postgresql+psycopg2://superset:superset@postgres:5432/superset
DATABASE_URL=
SECRET_KEY=$(cat /dev/urandom | env LC_CTYPE=C tr -dc &#x27;a-zA-Z0-9&#x27; | head -c 32)

cat &lt;&lt;PY &gt; superset_config.py
import os

MAPBOX_API_KEY = os.getenv(&#x27;MAPBOX_API_KEY&#x27;, &#x27;&#x27;)
CACHE_CONFIG = {
    &#x27;CACHE_TYPE&#x27;: &#x27;redis&#x27;,
    &#x27;CACHE_DEFAULT_TIMEOUT&#x27;: 300,
    &#x27;CACHE_KEY_PREFIX&#x27;: &#x27;superset_&#x27;,
    &#x27;CACHE_REDIS_HOST&#x27;: &#x27;redis&#x27;,
    &#x27;CACHE_REDIS_PORT&#x27;: 6379,
    &#x27;CACHE_REDIS_DB&#x27;: 1,
    &#x27;CACHE_REDIS_URL&#x27;: &#x27;redis://redis:6379/1&#x27;}
SQLALCHEMY_DATABASE_URI = &#x27;${DATABASE_URL}&#x27;
SQLALCHEMY_TRACK_MODIFICATIONS = True
SECRET_KEY = &#x27;${SECRET_KEY}&#x27;
PY
</code></pre><h3>UserWarning: Flask-Caching: CACHE_TYPE is set to null, caching is effectively disabled.</h3>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[微服务杂念]]></title>
            <link>https://wener.me/story/microservice-thoughts</link>
            <guid>microservice-thoughts</guid>
            <pubDate>Mon, 21 Feb 2022 08:07:21 GMT</pubDate>
            <description><![CDATA[微服务已经是一个不再新鲜的概念，但我却依然模糊不清。]]></description>
            <content:encoded><![CDATA[<p><a href="https://wener.me"><img src="https://www.plantuml.com/plantuml/svg/TP51I-D068Rlyok6x3NTiikoM3Mb9csyUF9QYinqFjjWceIPqLfABmL12Zs8UDE3NeKgY8Y2-ckI-ZFCcCOqjSqflFDyxpnyKn6ISCbyYPZJuYHeustSHvxFe2xQ9023-iUwa3qNZ7t7TO7fJT_rkI4vyKH0E7YoWPB1EbPZ0WBZZnwV7Z276zhEhjP0w500nuKoRX49NT93QFQZilZeo6d27baMKeHGNvKPWdHW8uCpOf3Krrr2mJKsmybDTFeqlRqhwrWP9xhQBzEircnJQwItfFpqzImyULY0hRNQVwiKmz_tfNXqEGv7rrjbVHwtRQjQ_Jk7qpnkhi3LlhBgZz5mEdp-KMsNh7yfI_EikO9bT4xuuZuQJyANyuLYzlN5S2QTUuqi9ofFL9TaD3UVSaftHYaPX18RBNoR92k9heRX-oCkuBQKWLWl5hlW0V_T0GqDK0Kyndpv2G00"/></a></p><p>微服务已经是一个不再新鲜的概念，但我却依然模糊不清。</p><p>微服务，抛开 微 不看，首先是一个面向服务的架构，即 SOA。系统模块，业务逻辑之间的界限是服务，服务为 服务名+方法名，与 CRUD/REST 不同。服务重在交互，CRUD/REST 重在数据。</p><p>SOA 曾经有 SOAP、 Java RMI，现在主流的 gRPC 和常见的 JsonRPC。这些定义的都是服务交互协议，而微服务更多的关注服务的组合、分布、编排、容错、发现、通信、跟踪等。因此会想到这样的一些主题：</p><ul><li>服务通信<ul><li>点对点 - 简单好理解，想要稳定使用则会导致实现复杂</li><li>广播总线 - 实现简单但依赖额外服务</li><li>网关 - 实现简单，易于理解，额外的一次跳转</li></ul></li><li>服务序列化<ul><li>一个发展了很久，认为已经被解决的问题</li><li>曾经序列化主要以性能作为考虑，现今计算冗余，前期选择最简单的 JSON 已经足够</li></ul></li><li>服务发现</li><li>服务容错</li></ul><h2>服务通信</h2><p>服务之间的通信可类比为网络通信，主要分为点对点，广播和网关：</p><ul><li>点对点场景<ul><li>前后端通信</li><li>服务端调用</li></ul></li><li>广播场景<ul><li>服务发现</li><li>服务总线</li></ul></li><li>网关场景<ul><li>前后端通信</li><li>服务路由</li><li>协议适配</li><li>鉴权</li></ul></li></ul><p>从服务提供方来说服务的通信也可以区分为主动和被动：</p><ul><li>主动<ul><li>监听过滤特定服务进行处理<ul><li>例如 监听 Topic，维护链接稳定性，过滤只处理本地提供的服务</li></ul></li><li>长链接注册服务<ul><li>链接断开则服务停止</li></ul></li></ul></li><li>被动<ul><li>监听固定接口<ul><li>例如 监听本地 8080，提供 JsonRPC，处理主动请求过来的服务调用</li></ul></li><li>启动时注册服务<ul><li>由注册中心服务定期检测服务存活</li></ul></li></ul></li></ul><h3>点对点通信</h3><p><strong>HTTP</strong></p><p>目前 HTTP 在快速发展，新的协议提高的主要是性能和对长链接流的支持，如果选择简单实现服务调用，HTTP 请求足以。</p><p>使用 HTTP POST 实现 单次请求响应，使用 WebSocket 实现流式请求。使用 HTTP 的好处是能利用现有的基础设施，HTTP 是目前支持最为广泛的协议，也是最受关注的协议。</p><p>但选择 HTTP 时，如果自行实现，则最好选择 HTTP 1，避免使用 HTTP 2 等新增特性，HTTP 2+ 能传递 HTTP 1 的所有语义，且性能各方面能得到很好的提升，这样足以。如果要独立使用 HTTP 协议新特性，例如 Trailer，则实现会变得过于复杂。</p><p><strong>非 HTTP 语义</strong></p><p>当使用非 HTTP 语义语义时，可能是基于 TCP，也可能是对 Payload 进行定义，抽象传输层，但如今想要跨语言，使用非 HTTP 协议阻碍会非常大，因此宁愿选择对 Payload 做自定义也不会选择不使用 HTTP。</p><h4>点对点网关</h4><p>通常点对点是需要直接通信，但现今有提供 Mesh 网络的网关组件，使得原本不互通的网络服务能够互相访问。同时也能实现对应的服务之间的权限管理和监控。</p><p>使用 Mesh 网关则可以让客户端的网络层实现更为简单，由网关去维护服务网络的稳定性，对服务网络的变化也能更快的反应。但成本是维护额外的基础设施组件，且注册中心与网关有强关联和交互，每个节点运行一个网关也是额外的资源消耗。</p><h3>广播通信</h3><p>服务总线本来是一种设计模式，比较常见的是基于事件驱动的设计，但在服务场景会有所不同。事件驱动一般有固定的 主题/Topic ，在定订阅初已经确定了部分语义。而服务总线则可以理解为只有一个 Topic，通过消息的内容来进行过滤谁处理谁不需要处理。</p><p>总线的通信模式解决了服务之间网络隔离的阻碍，不再需要 A 服务 与 B 服务 网络互通，网络的变化也不会阻碍服务的通信。但如果总线本身如果不支持一些 meta 信息的模式匹配，则会导致流量过大，处理能力受限。</p><p>选择广播通信，则必然会选择某种形式的 消息队列/MQ 实现，因此会牵扯到其他的基础设施服务，从部署跟踪上来说，这是扣分的。</p><h3>网关通信</h3><p>网关通信与 Mesh 网关不同，Mesh 的目的在于打通节点，网关的目的在于磨平/适配不同的环境服务，提供相同的能力。</p><p>所有的请求通过网关，由网关进行路由，这是典型的 Nginx 反向代理场景。因为所有请求都加了中间层，因此很多事情都可以在中间层完成：</p><ul><li>路由<ul><li>服务 A -&gt; 节点 B</li></ul></li><li>监控<ul><li>采集服务请求指标</li></ul></li><li>鉴权<ul><li>用户是否允许访问服务</li><li>服务之间是否允许通信</li></ul></li><li>适配<ul><li>前端 JsonRPC -&gt; 后端服务 gRPC</li></ul></li><li>跟踪<ul><li>添加 RequestID</li><li>记录请求到 Elastic</li></ul></li><li>集成服务<ul><li>服务 A -&gt; 外部服务 B</li></ul></li><li>服务错误熔断</li><li>负载均衡</li><li>TLS</li></ul><p>该模式与实际最底层的服务通信有有一点区别，主要作为适配和耦合存在，如果网关功能越多做的事情越多也越容易造成单点瓶颈。</p><h3>通信与其他组件的关联</h3><p>通信是服务的根本，对于微服务更是如此。通信的模式间接或直接的影响其他组件的选择和设计。但不同的通信模式并不是互斥的，在对于的场景选择对于的方式才是最好的选择。</p><ul><li>点对点<ul><li>优势<ul><li>易于跟踪</li><li>易于理解</li><li>可利用现有基础设施</li></ul></li><li>注册时候需要注册本地 IP、端口<ul><li>如果是被动，则还需要 IP 和 端口能够被注册中心访问以确保服务健康</li><li>如果是主动，则可能注册中心会成为瓶颈</li></ul></li><li>受网络影响较大<ul><li>部署节点变更可能需要一定时间才能更正为新的地址</li><li>影响因素主要有：<ol><li>检测到服务下线的时间</li></ol><ul><li>对于被动场景则是 心跳间隔<em>失败次数 - 一般为 `15s </em> 3 = 45s` - 不进行主动干预的情况</li></ul><ol start="2"><li>客户端检测到新服务信息的时间</li></ol></li><li>为了减少网络影响，可能抽象服务为 VIP<ul><li>例如 K8S 的服务定义，节点注册的地址作为 endpoing，实际请求 service</li><li>引入新的基础设施服务</li></ul></li></ul></li><li>重客户端<ul><li>想要实现稳定的服务请求，客户端设计实现会变得复杂，主要是服务发现和元数据变更相关。</li></ul></li><li>可用于 Web 端 - 但通常还是会使用 API 网关进行暴露</li></ul></li><li>广播/总线通信<ul><li>优势<ul><li>架构简单</li><li>部署时对环境要求更小</li></ul></li><li>注册时候只需要注册基本信息即可，消费端和提供端基本可以实现 0 耦合<ul><li>点对点需要知道提供端的地址信息</li></ul></li><li>强依赖额外的消息队列服务<ul><li>实时型消息队列</li><li>使用消息队列带来额外延时</li></ul></li><li>提供服务的一端必须是长链接监听消息<ul><li>因此 PHP 这类的 CGI 脚本语言比较难以使用</li></ul></li></ul></li><li>网关<ul><li>优势<ul><li>整合</li></ul></li><li>不一定与实际服务调用相关</li><li>与注册中心耦合 - 受注册中心控制</li><li>不管选用何种通信，一般都会存在一个网关</li></ul></li></ul><h2>服务发现</h2><p>服务发现通常只是一种行为，但实际使用的应该是服务注册中心，主要能力包括：</p><ul><li>记录服务节点信息 - 面向服务提供者<ul><li>提供 A 服务节点的 IP 是多少，端口是多少</li></ul></li><li>提供服务节点对应关系 - 面向服务消费者 - 发现<ul><li>谁提供 A 服务</li></ul></li><li>服务元数据记录 - 服务管理<ul><li>A 服务有那些版本，有那些方法，参数类型是什么样的</li><li>A 服务是用来做什么的服务</li></ul></li><li>服务健康状态 - 服务维护<ul><li>主动检查</li><li>被动上报</li></ul></li><li>服务安全 - 通常需要配合网关<ul><li>A 服务是否允许调用 B 服务</li></ul></li></ul><p>服务注册中心通常不是，而是一个集群，其中的服务元信息也可被同步到 RDBMS 便于开发人员查看和使用，场景例如：</p><ul><li>搜索接口</li><li>查找接口文档</li><li>查看服务状态</li><li>生成客户端代码</li><li>测试调用服务</li></ul><h2>服务容错</h2><p>服务容错包含服务异常、节点异常、网络异常，不同的异常可能采取不同的应对方式，我理解的常见功能包括</p><ul><li>限流</li><li>重试</li><li>负载</li></ul><p>容错的实现通常配合监控，网关，注册中心。算是优化服务体验的一部分，可以作为延伸支持考虑。</p><h2>微服务</h2><p>微服务，微的是除了服务之外的部分，也就是上述的所有内容。微服务的期望是让开发只关心业务逻辑的编写，开发好的业务逻辑能够快速稳定的上线被使用。</p><p>如果不在一套完善的体系下谈论开发微服务都是没有意义且难以实现的，而这套体系的搭建不背靠现在的 K8S 之类的体系也是难以成形的。</p><h2>总结</h2><p>将最近混乱思绪进行梳理，不一定都是正确，仅作为参考便于理解，引导之后的选择和决定。</p><h2>参考</h2><ul><li><a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></li><li><a href="http://www.richardrodger.com/monolithic-nodejs">http://www.richardrodger.com/monolithic-nodejs</a></li><li><a href="https://wener.me/blog/microservice-thoughts">微服务杂念</a><ul><li><a href="https://mp.weixin.qq.com/s/JMTH-mr_jHq5U8qLFmqQjA">微信</a></li><li><a href="https://github.com/wenerme/wener/blob/master/story/2020/2020-08-15-microservice-thoughts.md">Markdown</a></li></ul></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Wener's APIs]]></title>
            <link>https://wener.me/story/wener-apis</link>
            <guid>wener-apis</guid>
            <pubDate>Tue, 28 Jan 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[Dev]]></description>
            <content:encoded><![CDATA[<h2>Dev</h2><pre><code class="language-bash"># lite dev
MOD_NAME=boot,root,test,dash,geo,client yarn rollup -c rollup.mod.ts --watch
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Java with GraphQL]]></title>
            <link>https://wener.me/story/jraphql</link>
            <guid>jraphql</guid>
            <pubDate>Mon, 21 May 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[Java with GraphQL]]></description>
            <content:encoded><![CDATA[<p>Java with GraphQL</p><table><thead><tr><th>Module</th><th>Description</th></tr></thead><tbody><tr><td>jraphql-lang</td><td>GraphQL language representation</td></tr><tr><td>jraphql-runtime</td><td>GraphQL execution engine</td></tr><tr><td>jraphql-parser-antlr</td><td>Parser written in Antlr4 parse to jraphql-lang</td></tr></tbody></table><h2>Get Started</h2><ul><li>Maven <a href="https://search.maven.org/#search%7Cga%7C1%7Cg%3A%22me.wener.jraphql%22">me.wener.jraphql</a></li></ul><pre><code>&lt;dependency&gt;
  &lt;groupId&gt;me.wener.jraphql&lt;/groupId&gt;
  &lt;artifactId&gt;jraphql-runtimer&lt;/artifactId&gt;
  &lt;version&gt;0.0.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;me.wener.jraphql&lt;/groupId&gt;
  &lt;artifactId&gt;jraphql-parser-antlr&lt;/artifactId&gt;
  &lt;version&gt;0.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2>Features</h2><h3>Language representation</h3><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody><tr><td><strong>Serializable</strong></td><td>can parse or stringify to or from JSON</td></tr><tr><td><strong>Immutable</strong></td><td>friendly to cache or precompile</td></tr><tr><td><strong>Buildable</strong></td><td>every type has a builder for it generated by lombok.</td></tr><tr><td><strong>Pluggable</strong></td><td>language representation is not related to parser impl</td></tr></tbody></table><h3>Syntax Extension</h3><h4>Add <code>extend by name</code> syntax for object and interface</h4><h4>Weave multi schemas</h4><pre><code class="language-graphql"># common.graphqls
scalar Version

# crm.graphqls
type CrmQuery {
  customer(id:ID!):Customer
  crmVersion: Version!
}
type CrmUser {
  customers: [Customer]
}
extend type Query by CrmQuery
extend type User by CrmUser

# erp.graphqls
type ErpQuery {
  product(id:ID!):Product
}
extend type Query by ErpQuery
</code></pre><h4>Conditional schema</h4><pre><code class="language-graphql"># Only admin can see and use these methods
type AdminMutation {
  changePassword(id:ID,password:String): ChangePasswordPayload
}
extend type Mutation by AdminMutation @Role(role:&quot;admin&quot;)
</code></pre><h4>Allowed directives on directive definition, add DIRECTIVE location</h4><pre><code class="language-graphql">directive @JavaType(type:String) on DIRECTIVE
directive @Auth(value:String) @JavaType(type:&quot;Auth&quot;) on FIELD_DEFINITION;
</code></pre><h4>Allowed schema has optional name</h4><pre><code class="language-graphql">schema Test {
  query: MyQuery
}
</code></pre><h3>Runtime Extension</h3><ol><li>Type implements interface don&#x27;t need to write the fields again.</li></ol><pre><code class="language-graphql">interface Node {
    id: ID!
}

type User implements Node {
    # id: ID! # This is optional
}
</code></pre><ol start="2"><li>Can disable introspection<ul><li><code>new MetaResolver().setDisableIntrospection(true)</code></li></ul></li></ol><h3>Embeddable Schema</h3><p>JraphQL Runtime contain a embedded schema <a href="https://raw.githubusercontent.com/wenerme/jraphql/master/jraphql-runtime/src/main/java/me/wener/jraphql/schema/MetaSchema.java">MetaSchema</a>, generated by <a href="https://raw.githubusercontent.com/wenerme/jraphql/master/jraphql-runtime/src/test/java/me/wener/jraphql/example/EmbededSchema.java">EmbededSchema</a>.   </p><ul><li>Parse Schema</li><li>Serialize to JSON</li><li>Best compress GZip</li><li>Encode use mime base64</li><li>Original JSON 32631 byte -&gt; Encoded Base64 5352 byte</li></ul><h2>Example</h2><h3>StarWar</h3><ul><li><a href="https://raw.githubusercontent.com/wenerme/jraphql/master/jraphql-runtime/src/test/java/me/wener/jraphql/example/StarWarApplication.java">StarWarApplication</a><ul><li>SpringBoot WebFlux based</li><li>start and visite http://localhost:8080</li></ul></li><li><a href="https://raw.githubusercontent.com/wenerme/jraphql/master/jraphql-runtime/src/test/java/me/wener/jraphql/example/StarWarResolverV1.java">StarWarResolver</a><ul><li>resolve the StarWar schema. </li></ul></li></ul><p>Queries you can try</p><pre><code class="language-graphql">mutation addRev {
  createReview(episode: EMPIRE, review: {stars: 4, commentary: &quot;Ok Good&quot;}) {
    stars
    commentary
  }
}

query rev($e:Episode = EMPIRE) {
  hero(episode: $e) {
    id
    name
    appearsIn
  }
  reviews(episode: $e) {
    stars
    commentary
  }
}

query search {
  search(text: &quot;o&quot;) {
    __typename
    ... on Human {
      id
      name
    }
    ... on Droid {
      primaryFunction
    }
    ... on Starship {
      length
    }
  }
}

query baseQuery {
  starship(id: &quot;3000&quot;) {
    id
    name
    length(unit: FOOT)
  }
  character(id: &quot;2000&quot;) {
    id
    ... on Human {
      mass
      starships {
        name
      }
    }
    ... on Droid {
      name
      appearsIn
    }
  }
  human(id: &quot;1003&quot;) {
    friendsConnection(after: &quot;1002&quot;) {
      friends {
        name
      }
      pageInfo {
        hasNextPage
        startCursor
        endCursor
      }
    }
    friends {
      name
    }
  }
}
</code></pre><h2>Work with GoaphQL</h2><p><a href="https://github.com/wenerme/goaphql">GoaphQL</a> can generate code from schema that depends on jrapgql-api, can directly run on jraphql-graphql-java-adapter.  </p><p>The generated code is static type and full featured, everything is an interface.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[分布式架构手记]]></title>
            <link>https://wener.me/story/learning-dist-arch</link>
            <guid>learning-dist-arch</guid>
            <pubDate>Thu, 25 Aug 2016 15:33:00 GMT</pubDate>
            <description><![CDATA[这几天尝试了很多的 \*aaS, 期望能找到在当前架构下适合公司后续发展的一个系统架构, 然而一路下来发现并没那么简单.]]></description>
            <content:encoded><![CDATA[<p>这几天尝试了很多的 <!-- -->*<!-- -->aaS, 期望能找到在当前架构下适合公司后续发展的一个系统架构, 然而一路下来发现并没那么简单.</p><p>由于人员紧缺,规模扩展,越来越多的基础设施需要管理部署和控制,并且公司没有自己的设施,主要的基础设施来源于 阿里云, 这也不知道是福还是祸.</p><p><a href="https://en.wikipedia.org/wiki/Kubernetes">Kubernetes</a> 用于容器集群进行管理,让用户忽略底层的 IaaS, 但如果没有底层的 IaaS 那么 Kubernetes 用起来是举步维艰的.我们想要实现的是 SaaS, 需要的平台是 PaaS Kubernetes, 那么需要的基础设施 IaaS 用于运行 Kubernetes 的平台必须要与 Kubernetes 十分&quot;友好&quot;才能让你感觉 Kubernetes 是一个有价值的系统.而阿里云并不在&quot;友好&quot;之列. Kubernetes 原生支持 Azure, GCE, AWS, 如果公司选择的是这其中一家平台的服务,那么我相信 Kubernetes 还是很好用的,那用阿里+ Kubernetes 的不便在何处?</p><ul><li>阿里云并算不上一个合格的 IaaS, 只是服务器租赁商</li><li>Kubernetes 无法对阿里云服务器做任何控制</li><li>阿里云现有服务无法和 Kubernetes 整合</li></ul><p>这就使得本来很简单的东西变得很麻烦了,因为发现很多东西都得自己做.我的目标是想要使用基于 Kubernetes 的 <a href="https://deis.com/workflow">Deis</a>, Kubernetes 缺少与底层 IaaS 的集成使得 Deis 几乎无法使用(例如: IP 的分配).诚然 Kubernetes 很好,然而与我们无缘.</p><p>因为所有的主机都是 Ubuntu 的,想要尝试 juju, 遇到与上述完全相同的问题,无法与云平台集成.而 MAAS, 感觉上不太成熟,使用起来不太友好所以选择了放弃.到头来似乎简单轻量的 Docker Swarm 是唯一的选择.</p><p>运行平台选定了,可是状态存储也是一大问题. Docker Volume 集成的第三方云存储基本是用不上的(例如: EFS,Azure File Storage),涉及到存储的例如 Docker Registry, 代码仓库,但阿里的 OSS 似乎在这里也是指望不上的,剩下的唯一选择也就只能自己搭建了.Ceph 似乎是不二选择, 只要能接受在阿里上购买足够多的硬盘即可.</p><p>使用 Docker Swarm 用于部署服务层是很方便的,但是对于代码仓库或 Docker Registry 还是建议部署于单台服务器中.使用 Overlay 进行网络隔离以实现不同的环境部署服务.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Go Redis module]]></title>
            <link>https://wener.me/story/go-rm</link>
            <guid>go-rm</guid>
            <pubDate>Tue, 09 Aug 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[Writing Redis Module in Golang.]]></description>
            <content:encoded><![CDATA[<p>Writing Redis Module in Golang.</p><p>go-rm will let you write redis module in golang.</p><p>Read in | <a href="https://raw.githubusercontent.com/wenerme/go-rm/master/README-zh_CN.md">中文</a> | <a href="https://raw.githubusercontent.com/wenerme/go-rm/master/README.md">English</a> | <a href="https://raw.githubusercontent.com/wenerme/go-rm/master/README-es.md">Spanish</a></p><h2>Modules</h2><ul><li><a href="https://github.com/redismodule">redismodule</a><ul><li><a href="https://github.com/redismodule/rxhash">rxhash</a></li></ul></li></ul><h2>Demo</h2><pre><code class="language-bash"># Ensure you installed the newest redis
# for example by using brew you can
# brew reinstall redis --HEAD

# Build redis module
go build -v -buildmode=c-shared github.com/redismodule/rxhash/cmd/rxhash

# Start redis-server and load our module with debug log
redis-server --loadmodule rxhash --loglevel debug
</code></pre><p><strong>Connect to out redis-server</strong></p><pre><code class="language-bash"># Test hgetset
redis-cli hset a a 1
#&gt; (integer) 1
redis-cli hgetset a a 2
#&gt; &quot;1&quot;
redis-cli hget a a
#&gt; &quot;2&quot;
# Return nil if field not exists
redis-cli hgetset a b 2
#&gt; (nil)
redis-cli hgetset a b 3
#&gt; &quot;2&quot;
</code></pre><p>Wow, it works, now you can distribute this redis module to you friends. :P</p><h2>How to write a module</h2><p>Implement a redis module is as easy as you write a cli app in go, this is all you need to implement above command.</p><pre><code class="language-go">package main

import &quot;github.com/wenerme/go-rm/rm&quot;

func main() {
    // In case someone try to run this
    rm.Run()
}

func init() {
    rm.Mod = CreateMyMod()
}
func CreateMyMod() *rm.Module {
    mod := rm.NewMod()
    mod.Name = &quot;hashex&quot;
    mod.Version = 1
    mod.Commands = []rm.Command{CreateCommand_HGETSET()}
    return mod
}
func CreateCommand_HGETSET() rm.Command {
    return rm.Command{
        Usage: &quot;HGETSET key field value&quot;,
        Desc: `Sets the &#x27;field&#x27; in Hash &#x27;key&#x27; to &#x27;value&#x27; and returns the previous value, if any.
Reply: String, the previous value or NULL if &#x27;field&#x27; didn&#x27;t exist. `,
        Name:   &quot;hgetset&quot;,
        Flags:  &quot;write fast deny-oom&quot;,
        FirstKey:1, LastKey:1, KeyStep:1,
        Action: func(cmd rm.CmdContext) int {
            ctx, args := cmd.Ctx, cmd.Args
            if len(cmd.Args) != 4 {
                return ctx.WrongArity()
            }
            ctx.AutoMemory()
            key, ok := openHashKey(ctx, args[1])
            if !ok {
                return rm.ERR
            }
            // get the current value of the hash element
            var val rm.String;
            key.HashGet(rm.HASH_NONE, cmd.Args[2], (*uintptr)(&amp;val))
            // set the element to the new value
            key.HashSet(rm.HASH_NONE, cmd.Args[2], cmd.Args[3])
            if val.IsNull() {
                ctx.ReplyWithNull()
            } else {
                ctx.ReplyWithString(val)
            }
            return rm.OK
        },
    }
}
// open the key and make sure it is indeed a Hash and not empty
func openHashKey(ctx rm.Ctx, k rm.String) (rm.Key, bool) {
    key := ctx.OpenKey(k, rm.READ | rm.WRITE)
    if key.KeyType() != rm.KEYTYPE_EMPTY &amp;&amp; key.KeyType() != rm.KEYTYPE_HASH {
        ctx.ReplyWithError(rm.ERRORMSG_WRONGTYPE)
        return rm.Key(0), false
    }
    return key, true
}
</code></pre><h2>Fantasy</h2><ul><li>A module management module, supplies<ul><li>mod.search<ul><li>Search module from repository(github?)</li><li>Repository structure like this<pre><code>/namespace
    /module-name
        /bin
            /darwin_amd64
                module-name.so
                module-name.sha
            /linux_amd64
        module-name.go     
</code></pre></li></ul></li><li>mod.get<ul><li>Download module to ~/.redismodule</li><li>Because module is write in go, so we can build for almost any platform</li><li>We can use tag/commit to version the binary, so we can download the old version too</li></ul></li><li>mod.install<ul><li>Install downloaded module by calling redis command</li></ul></li><li>...</li></ul></li><li>A cluster management module<ul><li>Easy to create/manage/monitor redis3 cluster</li></ul></li><li>A json data type to demonstration how to add new data type in redis.<ul><li>json.fmt key template</li><li>json.path key path <!-- -->[<!-- -->pretty]</li><li>json.get key <!-- -->[<!-- -->pretty]</li><li>json.set key value<ul><li>this will validate the json format</li></ul></li></ul></li></ul><h2>Pitfall</h2><ul><li>C can not call Go function, so every callback is pre-generated<ul><li>200 commands at most</li><li>5 data type at most</li><li>limits are easy to change, just need a proper max value</li></ul></li><li>Go can not call var_args, function call is pre-generated<ul><li>HashSet/HashGet can accept 20 args at most</li><li>limits are easy to change, just need a proper max value</li></ul></li><li>Don&#x27;t know what happens when unload a golang shared module<ul><li>Single module</li><li>Multi module<ul><li>Is there runtime are shared ?</li></ul></li></ul></li><li>Module write in go can not report it&#x27;s memory usage to redis, max memory limits is useless</li><li>If a module write in go also include a third party write in other language, the memory usage is unknown</li><li>Module can only accept command, seems there is no way to call redis initiative.</li></ul><h2>TODO</h2><ul><li>Find a proper limits for data types and var_args</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Play Titans using shell]]></title>
            <link>https://wener.me/story/2016/2016-08-06-tap-titans</link>
            <guid>/2016/2016-08-06-tap-titans</guid>
            <pubDate>Sat, 06 Aug 2016 23:43:00 GMT</pubDate>
            <description><![CDATA[Tap Titans on Play Store]]></description>
            <content:encoded><![CDATA[<p><a href="https://play.google.com/store/apps/details?id=com.gamehivecorp.taptitans">Tap Titans</a> on Play Store</p><h2>Features</h2><ul><li>Auto upgrade</li><li>Auto spell skill</li><li>Auto start challenge</li><li>Auto close ad dialog</li><li>Verify fast tap (0.03s/tap)</li></ul><blockquote><p><strong>NOTE</strong></p><ul><li>Only tested on Nexus 5, different devices may use different coordinates and event dev.</li><li>Used to plat tiantis long time ago, may not works in current version.Different version may use different color and coordinates</li></ul></blockquote><h2>Requirement</h2><ul><li>ADB</li><li>Image Magic</li><li>Bash</li></ul><h2>Get started</h2><ul><li>Start game</li><li>Get source <a href="https://github.com/wenerme/wener/tree/master/story/2016/tap-titans-play.sh">tap-titans-play.sh</a></li></ul><pre><code class="language-bash">chmod +x play.sh
# Connect through lan, so you don&#x27;t have to use the usb
./play.sh use-tcp
# Push the pre-generated event file
adb push events /mnt/sdcard
# Start playing
./play.sh
</code></pre><h2>How is works ?</h2><h3>Why fast ?</h3><ul><li>Because I don&#x27;t use <code>adb shell input tap</code>, instead use a generated file that represent a tap event, then <code>cat tap &gt; /dev/input/event1</code>.</li><li>Use generated shell run in android.</li></ul><h3>How to detect the screen event ?</h3><p>Use screen capture, then use the image magic to check the color,kind of slowly, but works.</p><h2>More</h2><p>Check the <a href="https://github.com/wenerme/wener/tree/master/story/2016/tap-titans-play.sh">source</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[BBVM - BeBasic Virtual Machine]]></title>
            <link>https://wener.me/story/bbvm</link>
            <guid>bbvm</guid>
            <pubDate>Fri, 30 Oct 2015 00:00:00 GMT</pubDate>
            <description><![CDATA[The first VM in my live.]]></description>
            <content:encoded><![CDATA[<p>The first VM in my live.</p><h1>BBVM - BeBasic Virtual Machine</h1><p><a href="https://travis-ci.org/wenerme/bbvm"><img src="https://travis-ci.org/wenerme/bbvm.svg" alt="Build Status"/></a>
<a href="https://coveralls.io/github/wenerme/bbvm?branch=master"><img src="https://coveralls.io/repos/wenerme/bbvm/badge.svg?branch=master&amp;service=github" alt="Coverage Status"/></a>
<a href="https://github.com/wenerme"><img src="https://img.shields.io/badge/bbvm-%F0%9F%92%97-orange.svg" alt="Build with love"/></a>
<a href="https://github.com/wenerme/bbvm/issues"><img src="https://img.shields.io/github/issues/wenerme/bbvm.svg" alt="GitHub issues"/></a>
<a href="https://raw.githubusercontent.com/wenerme/bbvm/master/LICENSE"><img src="https://img.shields.io/badge/license-Apache%202-blue.svg" alt="GitHub license"/></a>
<a href="https://twitter.com/intent/tweet?text=Wow:&amp;url=https://github.com/wenerme/bbvm/"><img src="https://img.shields.io/twitter/url/https/github.com/wenerme/bbvm.svg?style=social" alt="Twitter"/></a></p><pre><code>; ____________________
; \______   \______   \___  _______
;  |    |  _/|    |  _/\  \/ /     \
;  |    |   \|    |   \ \   /  Y Y  \
;  |______  /|______  /  \_/|__|_|  /
;         \/        \/            \/

JMP CODE
DATA STR CHAR &quot;Hello, BBvm&quot;,0
CODE:

OUT 1, STR
EXIT
</code></pre><pre><code>&gt;Hello, BBvm
</code></pre><hr/><pre><code class="language-bash">go get github.com/wenerme/bbvm/cmd/bb             # Install bb command tool
bb run examples/hello.bbasm                       # Directly run bbasm

bb compile -o hello.bbin -i examples/hello.bbasm  # Compile bbasm to bbin
bb run hello.bbin                                 # Run bbin
hexdump -C hello.bbin

go get github.com/wenerme/bbvm/cmd/bbin           # Bundled bbin
bbin                                              # Should output: Hello BBvm
</code></pre><table><thead><tr><th align="center">中文</th><th align="center">English</th></tr></thead><tbody><tr><td align="center"><a href="#BB%E8%99%9A%E6%8B%9F%E6%9C%BA">README</a>/<a href="https://github.com/wenerme/bbvm/wiki/%E4%B8%BB%E9%A1%B5">WIKI</a></td><td align="center"><a href="#bbvm">README</a>/<a href="https://github.com/wenerme/bbvm/wiki/Home">WIKI</a></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/wenerme/bbvm/master/doc/image/bbvm-monopoly-demo.png" alt="大富翁"/></p><h1>BBvm</h1><p>BBvm is a simple easy virtual machine that run bbin compile from bbasm which is a simple assembly too.</p><h2>Features</h2><p>BBvm has a lot built-in system invoke with a default screen enabled device.</p><ul><li>Graphic draw</li><li>Image load</li><li>File read/write</li><li>String op</li></ul><hr/><h1>BB虚拟机</h1><p>BBvm 是一个简单的虚拟机,其汇编码为 BBasm.</p><h2>主要功能</h2><p>BBvm 包含了大量的内建系统调用,并且运行于一个有屏幕的设备上.</p><ul><li>图形操作</li><li>图像操作</li><li>文件操作</li><li>字符串操作</li></ul><h2>BBasic</h2><p><a href="http://www.baike.com/wiki/BBASIC">BBasic</a> 是一种掌上学习机的编程平台.BBK BBASIC,简称BB,最早由通宵虫于2006年开发,是由VMBASIC结合QuickBASIC开发而成.
运行于早期步步高学习机平台.</p><p>该项目为原步步高 BBasic 虚拟机的一个仿照实现.并在原来的基础上进行了扩展.</p><ul><li>做到和 BBasic 的汇编码兼容</li><li>做到和 BBasic 的二进制兼容</li><li>实现编译 Vasm 的编译器</li><li>实现 BB 的虚拟机,包括图形界面等所有功能</li><li>对 BBAsm 进行扩展</li></ul><h1>参考</h1><ul><li><p>BBAsm 语法参考<a href="https://github.com/wenerme/bbvm/blob/master/doc/grammar/BBAsm.g4">这里</a></p></li><li><p>BB 虚拟机规范参考<a href="https://github.com/wenerme/bbvm/wiki/vm-spec">这里</a></p></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Guava 简介]]></title>
            <link>https://wener.me/story/guava-intro</link>
            <guid>guava-intro</guid>
            <pubDate>Fri, 02 Oct 2015 00:00:00 GMT</pubDate>
            <description><![CDATA[Overviews - Five Ws]]></description>
            <content:encoded><![CDATA[<h2>Overviews - Five Ws</h2><table><thead><tr><th>问题</th><th>答案</th></tr></thead><tbody><tr><td>是什么</td><td>一套开源的 Java 公共组件</td></tr><tr><td>谁开发的</td><td>主要由 Google 工程师开发维护</td></tr><tr><td>哪里用</td><td>所有使用 Java 的地方</td></tr><tr><td>什么时候出现的</td><td>2008 年九月 第一个 Google Collection 版本出现在 <a href="http://mvnrepository.com/artifact/com.google.collections/google-collections">maven 仓库</a>;<br/>2010 年四月第一个 Guava 版本出现在<a href="http://mvnrepository.com/artifact/com.google.guava/guava">maven 仓库</a></td></tr><tr><td>什么使用</td><td>为什么不使用 ?</td></tr></tbody></table><h2>Features</h2><blockquote><p><strong>TIPS</strong> 可参考<a href="https://code.google.com/p/guava-libraries/wiki/GuavaExplained">GuavaExplained</a>的左边栏.</p></blockquote><ul><li>集合初始化工具和辅助工具</li><li>有限的函数式编程支持</li><li>提供常用的特殊集合类型</li><li>排序组件</li><li>事件总线</li><li>缓存</li><li>并发辅助组件</li><li>字符串工具</li><li>原子类型工具</li><li>IO 辅助</li><li>哈希组件</li><li>反射组件</li><li>数学组件</li><li>....</li></ul><h2>Who use Guava</h2><ul><li>在 Maven 中央仓库大约有 <a href="http://mvnrepository.com/artifact/com.google.guava/guava">4500</a> 个项目依赖 Guava</li><li><a href="https://code.google.com/p/guava-libraries/wiki/FriendsOfGuava">FriendsOfGuava</a> 列举了一些 Guava 友好的项目</li><li>常见的使用 Guava 的项目
<em> GSON
</em> Guice
<em> Hadoop,HBase,Spark 等 Hadoop 生态圈项目
</em> Cassandra <!-- -->*<!-- --> ....</li></ul><h2>vs common-lang</h2><ul><li>Maven 中央仓库大约有 <a href="http://mvnrepository.com/artifact/commons-lang/commons-lang">3500</a> 个项目依赖 commons-lang</li><li>Maven 中央仓库大约有 <a href="http://mvnrepository.com/artifact/org.apache.commons/commons-lang3">2000</a> 个项目依赖 <a href="http://commons.apache.org/proper/commons-lang/">commons-lang3</a></li><li>Maven 中央仓库大约有 <a href="http://mvnrepository.com/artifact/com.google.guava/guava">4500</a> 个项目依赖 Guava</li></ul><table><thead><tr><th>-</th><th>版本</th><th>生产日期</th><th>大小</th></tr></thead><tbody><tr><td>Guava</td><td>18.0</td><td>2014.8</td><td>2.2 MB</td></tr><tr><td>commons-lang3</td><td>v3.4</td><td>2015.4</td><td>425 KB</td></tr><tr><td>commons-lang</td><td>v2.6</td><td>2015.4</td><td>278 KB</td></tr></tbody></table><blockquote><p><strong>TIPS</strong>
Guava 并没有将各个模块分离开来,而是作为一个大的 jar 包,官方推荐的是,使用 ProGuard 来剔除自己不使用的内容
commons-lang 只是 Apache Commons 下的一小部分,其他的还有 commons-io 等</p></blockquote><p>Guava 与 Commons-Lang 并不是相互对立的关系,而是可以相互并存的,其交集可能在集合工具组件较多,而其他方面都是各有所长,因为并非二选一的问题.</p><h2>Reference</h2><ul><li><a href="https://github.com/google/guava">Guava@Github</a></li><li><a href="https://code.google.com/p/guava-libraries/wiki/GuavaExplained">GuavaExplained</a></li><li><a href="https://github.com/goldmansachs/gs-collections">gs-collections</a> A supplement or replacement for the Java Collections Framework.</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[转战 Hugo, 博客迁移之路]]></title>
            <link>https://wener.me/story/2015/2015-09-25-blog-hugo</link>
            <guid>/2015/2015-09-25-blog-hugo</guid>
            <pubDate>Fri, 25 Sep 2015 09:32:05 GMT</pubDate>
            <description><![CDATA[都快要把自己感动, 从最初(2011年)的 Wordpress, 到后来自己开发的 Tellets , 现在又到了 Hugo.]]></description>
            <content:encoded><![CDATA[<p>都快要把自己感动, 从最初(2011年)的 Wordpress, 到后来自己开发的 Tellets , 现在又到了 Hugo.</p><p>之所以抛弃 Wordpress 是因为它太笨重了,那些年是租的虚拟主机来挂博客,每年也还会有些投入,但是后来很少维护了,便不在想续费了.</p><p>后面想找一个轻便的能根据文件时生成的博客系统,所幸找到了 Droplet,但发现好多东西都不能满足要求,后来把 Droplet 完全重写成了 Tellts,自己添加的最喜欢的功能是直接配置 Github 的文章引用. Tellets 也是 PHP 的,而且必须要支持文件操作,但很多 PHP 应用服务器都不提供文件操作(例如: 新浪 SEA, 当初的京东云擎),后来主机停了便没有去管了. 再后来有点想用 Go 重写 Tellts, 但实在没时间,然后又过了很长一段时间.</p><p>在工作的情况下需要了解 Docker, 顺势也就利用 Docker 部署了 Hugo.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《我把我的矜持都给了她》：第一章 - 差一毫米的缘分，吗？]]></title>
            <link>https://wener.me/story/here-my-love-ch1</link>
            <guid>here-my-love-ch1</guid>
            <pubDate>Sat, 03 May 2014 00:00:00 GMT</pubDate>
            <description><![CDATA[有些人，只是永远不可能在一起]]></description>
            <content:encoded><![CDATA[<p>有些人，只是永远不可能在一起
致 那些人</p><p>故事的开始，免不了有一个女孩一个男孩，感情不都这样开始的么？</p><p>那是一次约会，至少他是那样看待的。一生中的第一次约会，难免觉得有些紧张，过于隆重。反复的检查了几遍自己的着装和打扮后，始终还是觉得缺了点什么。其实他也就一个约摸17 8岁的普通小男孩，一件体恤一条七分库一头寸把长的黑发，身上也没有什么其它行头，算得上是轻装上阵了。他也实属无奈，没有好的家庭条件，自己身边也没人辅导打扮，只要自己看起来过得去就算满分了。只是这次不同，第一次难免，不，是必须得庄重点，自己的满分都不好意思拿出去见人。其实他也不是第一次见到她了，作为同班同学，甚至差一毫米的同桌。他总觉得那次或许会是他终生的遗憾，在安排座位的时候，本来他们两是没有靠在一起的，后来因老师觉得班上男女同学的座位坐标不符合某种数学上的坐标分布，就稍微调整了一下座位，看着看着，发现一不小心老师为了他把她调成自己的同桌，不过是隔着一条走到那种。他才不管走道不走道什么的，距离从来不是问题，换一个角度想想，这也算得上是彼此的同桌了。但是在这位同桌还没缓过神来的时候，同桌前面的左边的上边的右边和他的同桌对调了一下，顺便也把他给调了上去。唉，差一毫米的同桌。他习惯性的把遗憾的事情说成是差一毫米的，因为那样让他感觉其实当初还是距离很近很近可以抓住他的，只是差一毫米让它溜走了。一毫米的同桌他还是天天可以见到的，因为不只是一个班的，那次调整座位虽然遗憾，万幸的是和他一组，并且她还当上了组长。这样接触就更多了。因为她当上了组长，他也变得活泼了不少，因为总是瞅着看有没有哪篇课文是需要背诵的，这样又多了一次机会一个理由了！</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[学生考勤系统]]></title>
            <link>https://wener.me/story/student-checking-sys</link>
            <guid>student-checking-sys</guid>
            <pubDate>Fri, 27 Dec 2013 04:24:19 GMT</pubDate>
            <description><![CDATA[别人作业啥的~~,不过还是学到了一些技巧]]></description>
            <content:encoded><![CDATA[<p>别人作业啥的~~,不过还是学到了<a href="#%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7">一些技巧</a></p><p>尚且还有一些问题没解决的</p><ul><li>作为阴影的窗口,不能设置 <code>ShowInTaskBar = false</code>,
设置后会消失,这个相对比较麻烦,没处理</li><li>画阴影的函数还不是很完善,只能是类似的阴影</li></ul><h2>截图</h2><p><img src="https://raw.github.com/wenerme/blog/master/%E9%82%A3%E4%BA%9B%E5%B0%8F%E4%B8%9C%E8%A5%BF/%E8%80%83%E5%8B%A4%E7%B3%BB%E7%BB%9F/screenshot.png" alt="登录页面" title="登录页面"/></p><p><img src="https://raw.github.com/wenerme/blog/master/%E9%82%A3%E4%BA%9B%E5%B0%8F%E4%B8%9C%E8%A5%BF/%E8%80%83%E5%8B%A4%E7%B3%BB%E7%BB%9F/screenshot-main.png" alt="查询,操作页面" title="查询,操作页面"/></p><h1>一些技巧</h1><h2>让窗口可拖动</h2><p>是重写的WndProc,而不是传统的鼠标事件</p><pre><code class="language-C#">
// Let Windows drag this form for us
protected override void WndProc(ref Message m)
{
    if (m.Msg == 0x0084 /*WM_NCHITTEST*/)
    {
        m.Result = (IntPtr)2;   // HTCLIENT
        return;
    }
    base.WndProc(ref m);
}

</code></pre><p>传统版本</p><pre><code class="language-C#">// In form load

var lastPoint = new Point();
var _isDraging = false;
MouseDown += (sender, e) =&gt;
{
    _isDraging = true;
    lastPoint = e.Location;
};
MouseMove += (sender, e) =&gt;
{
    if (! _isDraging)
        return;

    int ox = e.X - lastPoint.X;
    int oy = e.Y - lastPoint.Y;
    Location = new Point(Location.X + ox, Location.Y + oy);
};
MouseUp += (sender, e) =&gt; { _isDraging = false; };

</code></pre><h2>实现类似的窗体阴影</h2><p>是使用的一个类 <code>Dropshadow</code>.</p><p>最开始从<a href="http://stackoverflow.com/questions/8793445/windows-7-style-dropshadow-in-borderless-form">这里</a>
看到能实现阴影的方法,后来有查找了很多东西,修改成了
我自己的 <code>Dropshadow</code> 版本.调用方法</p><pre><code class="language-C#">var f = new Dropshadow(this)
{
    BorderRadius = 40,
    ShadowColor = Color.Blue
};

f.RefreshShadow();
</code></pre><h2>在 DataGridView 中使用 DateTimePicker</h2><p>这个忘记了具体是在哪里找的了,使用 <code>CalendarColumn</code>
和 <code>CalendarCell</code> 即可.在设计时可以直接选择.</p><h2>圆角边框</h2><pre><code class="language-C#">[DllImport(&quot;Gdi32.dll&quot;, EntryPoint = &quot;CreateRoundRectRgn&quot;)]
public static extern IntPtr CreateRoundRectRgn
    (
    int nLeftRect, // x-coordinate of upper-left corner
    int nTopRect, // y-coordinate of upper-left corner
    int nRightRect, // x-coordinate of lower-right corner
    int nBottomRect, // y-coordinate of lower-right corner
    int nWidthEllipse, // height of ellipse
    int nHeightEllipse // width of ellipse
    );

// in form load
Region = Region.FromHrgn(Win32.CreateRoundRectRgn(0, 0, Width, Height, 20, 20));

</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[纪念那些在 BBK 的时光]]></title>
            <link>https://wener.me/story/bbk-memory</link>
            <guid>bbk-memory</guid>
            <pubDate>Sun, 15 Dec 2013 02:48:00 GMT</pubDate>
            <description><![CDATA[- 2010-09-02 我的第一条主题帖]]></description>
            <content:encoded><![CDATA[<ul><li>2010-09-02 我的第一条主题帖</li><li>2007-09-07 我的第一条回复帖</li><li>2007-08-26 注册到 <a href="http://club.eebbk.com/">http://club.eebbk.com/</a></li></ul><p>刚开始的时候我的 ID 还是 <code>a3160586</code>,
后来 曲曲 奉献了他的 G 币给我改了个名叫<code>小文儿</code>了,本来是想叫<code>文儿</code>的
,可惜已经被注册了,可惜呀.</p><p>那些时候,盛行的还是 9688, 写的还是 BBasic 和 basm, 用的还是 npp.</p><p>那些时候,还曾当过版主,怀揣着一个梦想,说过一些豪语.</p><p>那些时候,正值高三下期,天天熬夜写东西,即便逃课,老师也不会管.</p><p>那些时候,还能有礼物,还在追求精华,还想振兴编程区(现在合并到校外区了).</p><p>那些时候,有曲曲,弟弟,red,灰机,仙剑 等等..........</p><p>那些时候,真的很快乐,虽然我懂得真的不多,但我只需要掌握好一样就好.</p><p>那些时候,过去了,不会再回来,也不需要再回来.</p><p>现在面对的是更多的知识和技术,有时候总是还想重拾以前的东西,
发现真的很难了.那些东西或多或少已经过时了,但是在成长的过程中曾
扮演过十分重要的角色.</p><p>那么多年过去了,BBK 也没开放过什么(或许我不知道),
社区感觉上也越来越小了吧,真的不喜欢这样,虽然现在论坛更漂亮了,
界面更好了,产品更新了,但是吸引力却越来越小了.没有自己能用力的地方,
即便是再忠诚的用户,也无能为力,永远形成不了像开源的那种社区效应.</p><p>一个产品的进化更多的是受到社区和用户的影响,只立足于商业和自己的利益,
这样做的产品永远都是自己的,用户又有什么发言权呢?最后也只能是人走茶凉了.
一批人走了,另一批不明所以的人又进来,然后又离开.</p><p>所以离开了,剩下的或许都是你们的世界.</p><p>这里包含了我当初在 bbk 论坛发表的部分内容,</p><ul><li><a href="https://wener.me/story/bbk-bbimg-js">js 解析 lib 图片文件列表</a></li><li><a href="https://wener.me/story/bbk-libs">四个函数和 bb 编辑器</a></li><li><a href="https://wener.me/story/bbk-quick-screenshot">BB 急速截图</a></li><li><a href="https://wener.me/story/bbk-bda-calc">还原的 Bda 计算器</a></li><li><a href="https://wener.me/story/bbk-game-prisoner-dilemma">囚徒困境</a></li><li><a href="https://wener.me/story/bbk-first-game">平生第一个游戏 - 趣味拼图</a></li></ul><p>没有转存的内容,下面会列举一些.</p><blockquote><p>以下链接均 404</p></blockquote><ul><li><a href="http://club.eebbk.com/bbkbbs/showtopic/250018/1">DLX&amp;LIB&amp;RLB&amp;BMP 文件数据结构和算法，深入研究 ，附带文件读取模板，源码，大富翁素材和一些 dlx 导出的结果</a></li><li><a href="http://club.eebbk.com/bbkbbs/showtopic/250082/1">用户词典数据结构，模板和 lcc 文件模板，可直接读写数据</a></li><li><a href="http://club.eebbk.com/bbkbbs/showtopic/249402/1">名片文件（LCC）结构，生成自己的名片</a></li><li><a href="http://club.eebbk.com/bbkbbs/showtopic/246851/1">强大函数 制作 bb 的动态链接库(dll)，实现数据库,用汇编的</a></li><li><a href="http://club.eebbk.com/bbkbbs/showtopic/245477/1">这样做 ARPG(动作类角色扮演游戏)</a></li><li><a href="http://club.eebbk.com/bbkbbs/showtopic/244376/1">p 类函数库的实际运用，由浅入深，深入浅出的实例讲解</a></li><li><a href="http://club.eebbk.com/bbkbbs/showtopic/245464/1">BB 学习必备手册</a></li><li><a href="http://club.eebbk.com/bbkbbs/showtopic/243308/1">物理的简单运用《PLAYBALL》（玩蛋）</a></li><li><a href="http://club.eebbk.com/bbkbbs/showtopic/243000/1">贝塞尔曲线运用，8 个实例。</a></li><li><a href="http://club.eebbk.com/bbkbbs/showtopic/243168/1">二次贝塞尔曲线辅助的工具，让你计算点的位置，可视化。exe 格式</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[软件设计师考试笔记]]></title>
            <link>https://wener.me/story/rk-software-designer</link>
            <guid>rk-software-designer</guid>
            <pubDate>Fri, 08 Nov 2013 00:00:00 GMT</pubDate>
            <description><![CDATA[考试软考的时候,整理的一些笔记]]></description>
            <content:encoded><![CDATA[<blockquote><p>考试软考的时候,整理的一些笔记</p></blockquote><h1>内容</h1><h2>系统开发和运行</h2><h3>软件生存周期</h3><p>可行性分析, 项目开发计划, 需求分析, 设计(概要设计和详细设计), 编码, 测试, 维护</p><h3>软件开发模型</h3><p>瀑布模型
: 提供了有效的管理模式, 文档驱动
: 主要用于结构化的软件开发
: 缺乏灵活性, 无法通过开发活动来明确需求</p><p>演化模型
: 构建原型
: 对软件需求缺乏准确认识</p><p>螺旋模型
: 综合了瀑布模型和演化模型的优点
: 增加了风险分析
: 适合大型复杂系统</p><p>喷泉模型
: <em>面向对象开发过程</em>
: 具有迭代和无间隙特性</p><p>V模型
: 强调软件开发的协作和速度
: 实现和验证结合
: 保证质量缩短周期</p><h3>软件开发方法</h3><h4>结构化方法</h4><p>由结构化分析,结构化设计,结构化程序设计构成
是一种面向<strong>数据流</strong>的开发方法.
使用DFD图来建立系统的功能模型.
指导思想是 自顶向下,逐层分解.基本原则是功能的分解与抽象.
适用于数据处理领域,不适合解决大规模的,特别复杂的项目,且难以适应需求的变化</p><h4>Jackson 方法</h4><p>是一种面向<strong>数据流</strong>的开发方法.
JSP(Jaskon Structure Programming) 方法 以数据结构为驱动,适合于小规模项目.
JSD 是 JSP 的扩充.</p><h4>原型化方法</h4><p>开发原型,征求意见,修改原型.
适用于用户需求不清,业务不确定,需求经常变化的情况.也可用于不复杂的小规模项目.</p><h4>面向对象开发方法</h4><p>包括面向对象分析,面向对象设计和面向对象实现.</p><p>面向对象开发方法: Booch,Coad,OMT.
UML 是面向对象标准建模语言.</p><h3>风险分析</h3><p>包括 风险识别, 风险预测, 风险评估, 风险控制</p><p>风险识别
: 建立风险条目检查表</p><p>风险预测
: 风险发生的可能性或概率,风险发生所产生的后果</p><p>风险评估
: $(r_i,l_i,x_i)$,r为风险,l为概率,x为影响
: 建立参照</p><p>风险控制
: 风险避免,风险监控, 风险管理及意外事件计划</p><h3>进度管理</h3><h4>Gantt 图</h4><p>可以反映并行关系
不能反映依赖关系,难以确定项目的关键所在,不能反映计划中有潜力部分</p><h4>PERT 图</h4><p>可以反映依赖关系,确定关键,反映潜力
不能反映并行</p><p>关键路径是松弛时间为 0 的任务完成过程所经历的路径.没有松弛时间则是耗时最长路径.</p><h3>软件配置管理</h3><p>标识变更,控制变更,确保变更,版本控制</p><h3>软件过程管理</h3><p>软件过程能力评估的意义
: 是改进软件过程和降低软件风险的需要</p><h3>软件能力成熟度模型 / CMM</h3><p>初始级
: 无序的,混乱的,对过程没有定义,成功取决于个人</p><p>可重复级
: 有基本的项目管理过程来跟踪费用,进度,功能特性.有过程纪律,能重复早先类似的成功</p><p>已定义级
: 将软件管理和工程的过程文档化,标准化,综合成该组织的标准软件过程.项目使用经批准,裁剪的标准软件过程来开发和维护软件.</p><p>已管理级
: 收集对软件过程和产品质量的详细度量,对软件过程和产品都有定量的理解和控制</p><p>优化级
: 过程的量化反馈和先进的新思想,新技术促使过程不断改进.</p><h3>统一过程</h3><p>统一过程(UP)模型是一种 &quot;用例和风险驱动,以构架为中心,迭代并且增量&quot;的开发过程.</p><p>分为五个阶段:</p><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>初始阶段</td><td>生命周期目标</td></tr><tr><td>精化阶段</td><td>生命周期构架</td></tr><tr><td>构建阶段</td><td>初始运作功能(Beta 版产品)</td></tr><tr><td>移交阶段</td><td>产品发布</td></tr></tbody></table><h4>RUP</h4><p>RUP(Rational Unified Process) 是 UP 的商业扩展.</p><p>角色
: 描述个人或小组的行为职责</p><p>活动
: 有明确目的的工作单元</p><p>工件
: 是活动生成,创建或修改的一段信息.</p><h3>敏捷方法</h3><p>是 &quot;尽可能早的,持续的对有价值的软件的交付&quot;使客户满意</p><p>典型方法: 极限编程,水晶法,并列征求法,自适应软件开发</p><h4>极限编程</h4><p>4个价值观
: 沟通,简单性,反馈和勇气</p><p>5个原则
: 快速反馈, 简单性假设, 逐步修改, 提倡更改和优质工作</p><p>12个最佳实践
: 计划游戏,小型发布,隐喻, 简单设计, 测试先行, 重构, 结对编程, 集体代码所有制,
持续集成, 每周工作40个小时,现场客户和编码标准.</p><h3>软件质量特性</h3><p>ISO/IEC 9126 软件质量模型由三个层次构成: 质量特性,质量子特性, 度量指标</p><ul><li>功能性<ul><li>适合性</li><li>准确性</li><li>互用性</li><li>依从性</li><li>安全性</li></ul></li><li>可靠性<ul><li>成熟性</li><li>容错性</li><li>易恢复性</li></ul></li><li>易用性<ul><li>易理解性</li><li>易学性</li><li>易操作性</li></ul></li><li>效率<ul><li>时间特性</li><li>资源特性</li></ul></li><li>可维护性<ul><li>易分析性</li><li>易修改性</li><li>稳定性</li><li>易测试性</li></ul></li><li>可移植性<ul><li>适应性</li><li>易安装性</li><li>一致性</li><li>易替换性</li></ul></li></ul><h4>软件质量保证</h4><p>包括7个主要活动相关的各种任务:</p><ul><li>应用技术方法</li><li>进行正式的技术评审</li><li>测试软件</li><li>标准的实施</li><li>控制变更</li><li>度量</li><li>记录保存和报告</li></ul><h3>代码复杂性</h3><ul><li>代码行度量法</li><li>McCabe 度量法
又称为环度量法,认为复杂性主要取决于控制复杂性.</li></ul><h3>系统设计的基本原理</h3><p>抽象, 模块化, 信息隐蔽, 模块独立</p><h3>软件测试策略</h3><p>单元测试
: 也称为模块测试.
: 特征: 模块结构,局部数据结构, 重要的执行路径,出错处理,边界条件</p><p>组装测试
: 也称为集成测试
: 方法:
1.分别测试各模块,在组装起来整体测试,即非增量测试.
2.模块组合到已测试好的模块中,完成后组合下一个模块,即增量测试</p><p>确认测试
: 确认功能和性能是否和用户要求的一样.
: 先进行有效性测试及软件配置审查,然后进行验收测试和安装测试,完成后交付给用户</p><p>系统测试
: 将软件放入到实际环境中,进行各种组装测试和确认测试.
: 常见的系统测试 恢复测试,安全性测试,强度测试, 性能测试,安装测试,可靠性测试</p><h3>测试方法</h3><p>分为静态测试和动态测试</p><p>静态测试分为 人工检测和计算机辅助静态分析</p><p>动态测试分为 黑盒测试和白盒测试</p><h4>黑盒测试用例</h4><p>也称为功能测试.不考虑内部结构和特性的情况下进行外部特性测试.</p><p>常用的测试技术:</p><ul><li>等价类划分</li><li>边界值分析</li><li>错误推断</li><li>因果图</li></ul><h4>白盒测试用例</h4><p>也称为结构测试</p><p>测试方法:</p><ul><li>逻辑覆盖</li><li>循环覆盖</li><li>基本路径测试</li></ul><h3>调试</h3><p>常用的调试方法: 试探法,回溯法, 对分查找法,归纳法,演绎法</p><h3>系统文档</h3><table><thead><tr><th>人员</th><th>文档</th></tr></thead><tbody><tr><td>用户-系统分析人员 规划分析</td><td>可行性研究报告,总体规划报告,系统开发合同,系统方案说明书</td></tr><tr><td>系统开发人员-项目管理人员</td><td>系统开发计划,系统开发月报,系统开发总结</td></tr><tr><td>系统测试人员-系统开发人员</td><td>系统方案说明书,系统开发合同,系统设计说明书,测试计划</td></tr><tr><td>系统开发人员-用户 运行期间</td><td>用户通过开发人员撰写的文档运行系统</td></tr><tr><td>系统开发人员-系统维护人员</td><td>系统设计说明书,系统开发总结报告</td></tr><tr><td>用户-维护人员 运行维护期间</td><td>用户记载运行问题,形成运行报告和修改建议.维护人员依次进行维护</td></tr></tbody></table><h3>系统维护</h3><p>可维护性
: 维护人员理解,改正,改动和改进这个软件的难易度.</p><p>系统的可维护性指标
: 可理解性,可测试性,可修改性</p><p>维护与文档
: 文档是软件可维护性的决定因素.分为用户文档和系统文档</p><h4>系统维护的内容及类型</h4><p>维护的费用是生存周期全部费用的 60% ~ 80%</p><ul><li>硬件维护</li><li>软件维护</li><li>数据维护</li></ul><p>软件维护的分类</p><ul><li>正确性/改正性 维护. 17%~21%
交付后,运行时,诊断和改正错误</li><li>适应性维护. 18%~25%</li><li>完善性维护. 50%~60%
扩充功能和改善性能.</li><li>预防性维护. 4%
改进以适应未来的软硬件环境,增加新的功能,使其不被淘汰.</li></ul><h1>算法</h1><p>原码
: +0=00000000
: -0=10000000</p><p>反码
: +0=00000000
: -0=11111111</p><p>补码
: +0=-0=00000000</p><p>移码
: =$n^{ n-1 }+X\quad X 为纯整数,且 (-2^{ n-1 }\le\quad X\quad&lt;\quad 2^{n-1})$
: =$1+X \quad X为纯小数,且(-1 \le X &lt; 1)$
: 移码主要用于表示浮点数的阶码, 在浮点数运算中有优势.</p><p>浮点数
: 表示 $N=M \cdot R^{E}$
: M 尾数 R 基数 E 阶码
: IEEE754 表示 $(-1)^{S}2^{E}(b<em>0b_1\cdots b</em>{P-1})$</p><h2>cache性能分析</h2><p>$$
t_a\quad = \quad Ht_c + (1 - H ) t_m
$$</p><p>$$
r=t_m/t_a
$$</p><p>H 为 cache 命中率,
$t_c $为cache 存取时间,
$t_m$为主存访问时间,
$t_a$ cache等效访问时间,
r 为使用 cache 提高的速度倍数</p><h2>磁盘容量</h2><p>$$
非格式化容量 = 面数 \times (磁道数/面)\times 内圆周长\times 最大位密度
$$</p><p>$$
格式化容量 = 面数 \times (磁道数/面)\times (扇区数\times 道)\times (字节数/扇区)
$$</p><hr/><p>吞吐率</p><hr/><h2>可靠性</h2><p>$$
R(t) = e^{-\lambda t}
$$</p><p>$\lambda$ 失效率
t 时间
R(t) t这段时间能正常运行的概率</p><p>$$
MTBF= 1/\lambda
$$</p><p>$$
A = \frac{MTBF}{MTBF + MTRF}
$$</p><p>MTBF 平均无故障时间
MTRF 平均故障修复时间</p><h2>可靠性模型</h2><p>串联系统
: $R=R_1R_2\cdots R_N$
: $\lambda = \lambda_1 + \lambda_2 + \cdots +\lambda_N$</p><p>并联系统
: $R = 1 - (1-R<em>1)\times(1-R_2)\times\cdots\times(1-R_N)$
: $\mu =\frac { 1 }{ \frac { 1 }{ \lambda  } \sum </em>{ j=1 }^{ N }{ \frac{1}{j} }  } $</p><p>N模冗余系统
: $ R=\sum _{ i=n+1 }^{ N } \begin{pmatrix} j  <!-- -->\<!-- --> N  \end{pmatrix} \times R_0^j(1-R_0)^{N-1} $</p><h2>计算机性能</h2><p>$$
T = \sum_{i=1}^{n} \times (\omega_i \times t_i)
$$</p><p>T 等效指令时间
i 某类指令
n 指令种类数
$\omega_i$ 指令i在程序中占的比例
$t_i$ 指令i 执行时间</p><h2>McCabe 度量法</h2><p>$$
V(G) = m - n + 2p
$$</p><p>V(G) 为有向图 G 中的环路数
m 为图 G 中弧的个数
n 为节点个数
p 为 G 中的强连通分量个数</p><h2>完全二叉树叶子节点数量</h2><p>除最外层,其余层上的节点数目都达到最大值,而第 h 层上的节点集中存放在左侧树</p><pre><code>n0 度为0的节点数
n1 度为1的节点数
n2 度为2的节点数

n0 = n2 + 1
n = n0 + n1 + n2
n0 = (n+1)/2 或 n0 = n/2
</code></pre><h2>Misc</h2><p>$$
平均作业周转时间 = (\sum<em>{i=1}^{n}{\sum</em>{j=1}^{i}} t_j)/n
$$</p><p>n 为作业的数量
ti 为作业 i 的时间</p><hr/><p>$$
ASL/平均查找长度 = \sum<em>{i=1}^nP_iC_i
$$
n 记录个数
Pi 对表中第 i 个记录进行查找的概率 且 $\sum</em>{i=1}^nP_i = 1$</p><hr/><hr/><pre><code>芯片数 = 总容量/芯片容量
地址线数 = 片选地址数 + 片内地址数 = log(芯片数) + log(芯片容量)
注意: 地址是按字节编址的


</code></pre><h1>Cheat Sheet</h1><h2>耦合类型</h2><table><thead><tr><th>耦合类型</th><th>描述</th></tr></thead><tbody><tr><td>非直接耦合</td><td>两个模块之间没有直接关系</td></tr><tr><td>数据耦合</td><td>彼此之间通过数据参数来交换输入,输出信息</td></tr><tr><td>标记耦合</td><td>一组模块通过参数表传递记录信息</td></tr><tr><td>控制耦合</td><td>一个模块通过传送开关,标志,名字等控制信息,明显地控制选择了一个模块的功能</td></tr><tr><td>外部耦合</td><td>一组模块都访问同一全局简单变量而不是同一全局数据结构,<br/>而且不是通过参数表传递该全局变量的信息</td></tr><tr><td>公共耦合</td><td>都访问同一公共数据环境</td></tr><tr><td>内容耦合</td><td>一个模块直接访问另一个模块的内部数据<br/>一个模块不通过正常入口转到另一个模块内部<br/>两个模块有一部分程序代码重叠<br/>一个模块有多个入口</td></tr></tbody></table><h2>UML</h2><table><thead><tr><th>域</th><th>视图</th><th>图</th><th>主要概念</th></tr></thead><tbody><tr><td>结构</td><td>静态视图</td><td>类图</td><td>类,关联,泛化依赖关系,实现,接口</td></tr><tr><td></td><td>用例视图</td><td>用例图</td><td>用例,参与者,关联,扩展,包括,用例泛化</td></tr><tr><td></td><td>实现视图</td><td>构件图</td><td>构件,接口,依赖关系,实现</td></tr><tr><td></td><td>部署视图</td><td>部署图</td><td>节点,构件,依赖关系,实现</td></tr><tr><td>动态</td><td>状态机视图</td><td>状态机图</td><td>状态,事件,转换,动作</td></tr><tr><td></td><td>活动视图</td><td>活动图</td><td>状态,活动,完成转换,分叉,结合</td></tr><tr><td></td><td>交互视图</td><td>顺序图</td><td>交互,对象,消息,激活</td></tr><tr><td></td><td></td><td>协作图</td><td>协作,交互,写作角色.消息</td></tr><tr><td>模型管理</td><td>模型管理视图</td><td>类图</td><td>包,子系统,模型</td></tr><tr><td>可扩展性,所有</td><td>所有</td><td>约束,构造性,标记值</td><td></td></tr></tbody></table><p>依赖
: 两个事物之间的语义关系,一个事物的变化会影响另一个</p><p>关联
: 一种结构关系, 描述了一组链式对象之间的连接.</p><p>聚集
: 是一种特殊的关联,描述了整体和部分之间的结构关系.</p><p>泛化
: 是一种 特殊/一般 关系</p><p>实现
: 是类元之间的语义关系</p><p>包含
: 把几个用例的公共步骤分离成一个单独的被包含用例.</p><p>扩展
: 把新行为插入到已有的用例中的方法.</p><p>边界类
: 描述的是系统外部环境和系统内部的交互,工作在外部环境和系统之间,边界对象表示一个窗口.</p><p>实体类
: 存储和管理系统内部信息,可以有行为,但必须和他所表示的对象密切相关
: 实体类是独立于系统外部环境的</p><p>控制类
: 主要描述特点的 UseCase 的控制行为,与特定的 UseCase, 实现密切相关
: 可以有效的降低边界类和实体类的耦合, 使系统对于外部环境的变化,能更好适应.</p><h2>哈夫曼树的定义</h2><p>哈夫曼树又称最优二叉树, 是一种带权路径长度最短的二叉树.</p><p>带权路径长度 = 权值 * 该节点到根节点的长度</p><h2>FTR 指导原则</h2><ol><li>软件评审是评审软件产品,不要涉及对软件生产者能力的评价</li><li>评审前要制定严格的评审计划,并严格遵守预计的日程安排</li><li>对评审中出现的问题要记录在案,不要过多的讨论解决问题,把问题解决留给生产者</li><li>要限制参与人数,并要求参加评审的人员在评审会之前仔细阅读文档,做好充分准备</li></ol><h2>数据库范式</h2><p>1NF
: 每一个分量是不可再分的数据项
: 问题</p><pre><code>1. 冗余度大
2. 引起修改操作不一致
3. 插入异常
4. 删除异常
</code></pre><p>2NF
: 每一个非主属性完全依赖于码
: 即 消除了非主属性对码的部分函数依赖</p><p>3NF
: 消除非主属性对码的传递函数依赖</p><p>BCNF
: 消除主属性对码的部分和传递函数依赖
: 即:
: 所有非主属性对每一个码都是完全依赖
: 所有非主属性对每一个不包含它的码,也是完全函数依赖
: 没有任何属性完全函数依赖于非码的任何一组属性</p><p>ACID/Atomicity, Consistency, Isolation, Durability
: 事务的特性: 原子性 一致性 隔离性 持久性</p><p>分解应具有的特性
: 分解具有无损连接性
: 分解要保持函数依赖
: 分解既要有无损连接性,又要保持函数依赖</p><blockquote><p>设 $R(U)$ 是一个属性集 $U$ 上的关系模式, $X$ 和 $Y$ 是 $U$ 的子集.</p></blockquote><p>函数依赖
: 若对 $R(U)$ 的任意可能关系 $r$
: $r$ 中不存在两个或以上元组在 $X$ 上的属性相等 而在 $Y$ 上不等
: 则称 $X$ 函数决定 $Y$ 或 $Y$ 函数依赖于 $X$, 记做 $X \rightarrow Y$</p><blockquote><p>如果 $X \rightarrow Y$</p></blockquote><p>非平凡函数依赖
: 且$X \not\subset Y$</p><p>平凡函数依赖
: 且$X \subset Y$</p><p>完全函数依赖
: $\forall X&#x27; \subsetneq X$,都有 $X \not\rightarrow Y$
: 记做 $X \xrightarrow{\quad _f \quad } Y$</p><p>部分函数依赖
: $\exists  X&#x27; \subsetneq X$,有 $X \not\rightarrow Y$
: 记做 $X \xrightarrow{\quad _p \quad } Y$</p><h2>数据库的键</h2><p>候选键/Candidate Key
: 关系中能唯一的标识一个元组的某一属性或属性组</p><p>主码/Primary Key
: 如果关系中有多个候选码,则选定一个作为主码</p><p>主属性/Primary Attribute
: 在候选码中的属性</p><p>外码/Foreign Key
: 属性是其他关系的码</p><p>全码/All-Key
: 关系中所有属性组是该关系的候选码</p><p>超键/Super Key
: 能唯一标识元组的属性集</p><h2>设计模式 概括</h2><p>桥接模式/Bridge
: 将抽象部分和它的实现部分分离, 使他们都可以独立的变化
: 对一个抽象的实现部分的修改应该对使用它不产生影响</p><p>中介模式/Mediator
: 可以使各个对象间的耦合松散,只需关心和Mediator的关系
: 使多对多的关系变成了一对多的关系,降低系统的复杂性,提高可修改性和扩展性</p><h2>OOA 的步骤</h2><ol><li>分析问题域,建立用例模型</li><li>发现和定义对象和类</li><li>识别对象的内部特征</li><li>识别对象的外部特征</li><li>识别对象之间的交互</li></ol><p>5个活动
: 认定对象,组织对象,描述对象间的相互作用,定义对象的操作,定义对象的内部信息</p><h2>OMT 概述</h2><p>OMT/Object Modeling Technique/ 对象建模技术
: 三种模型: 对象模型, 动态模型, 功能模型
: 四个步骤: 分析, 系统设计, 对象设计和实现</p><p>对象模型
: 描述系统对象的 静态结构,对象之间的关系,对象的属性,操作
: 表示静态的,结构上的,系统的 <em>数据</em> 特征</p><p>动态模型
: 描述与时间和操作顺序有关的系统特征----激发事件,事件序列,确定事件先后关系
以及事件和状态的组织
: 表示瞬时的,行为上的, 系统的 <em>控制</em> 特征</p><p>功能模型
: 描述与值的变换有关的系统特征----功能,映射,约束和函数依赖
: 使用数据流图来表示</p><h2>排序算法的适用性</h2><ul><li>待排序的记录数据 n 较小时, 可采用插入排序和选择排序</li><li>待排序基本有序, 选择直接插入排序或冒泡排序</li><li>当 n 很大且关键字位数少,选择链式基数排序</li><li>当 n 很大, 则采用时间复杂度为 O(nlogn)的排序方法----快速排序,堆排序,归并排序</li></ul><h2>排序算法的分类</h2><table><thead><tr><th>分类</th><th>包含</th></tr></thead><tbody><tr><td>交换排序</td><td>冒泡排序 快速排序</td></tr><tr><td>插入排序</td><td>插入排序 希尔排序 二叉查找树排序</td></tr><tr><td>选择排序</td><td>选择排序 堆排序</td></tr><tr><td>归并排序</td><td>归并排序</td></tr><tr><td>分布排序</td><td>基数排序</td></tr></tbody></table><h2>设计模式分类</h2><table><thead><tr><th>分类</th><th>包含</th></tr></thead><tbody><tr><td>创建</td><td>抽象工厂 构造器 工厂方法 原型 单例模式</td></tr><tr><td>结构</td><td>适配器 桥接 组合 装饰 外观 享元 代理</td></tr><tr><td>行为</td><td>职责链 命令 翻译器 迭代器 仲裁器(Mediator) 回忆(Memento) 观察者 状态机 策略 模板方法 参观者(Visitor)</td></tr></tbody></table><h2>乔姆斯基文法类型</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>0型</td><td>相当于图灵机,任何 0型 语言都是递归可枚举的</td></tr><tr><td>1型</td><td>上下文有关文法,相当于线形界限自动机,对非终结符替换时不考虑上下文,不允许替换为空串</td></tr><tr><td>2型</td><td>上下文无关文法, 相当于非确定的下推自动机</td></tr><tr><td>3型</td><td>右线性文法,等价于正规式, 也称为正规文法</td></tr></tbody></table><p>文法描述语言的能
: 0型文法最强 3型最弱</p><p>3型文法必是2型文法</p><h2>Tips</h2><pre><code>正规式只能表示给定结构的固定次数的重复或者没有指定次数的重复
对于每个非确定的有限自动机,都有一个与其等价的正规式
上下文无关文法可以表示次数不固定的重复


</code></pre><p>中断响应有两种方式
: 精确断点法 和 不精确断点法</p><p>精确断点法
: 立即响应中断
: 不影响中断反应时间,影响程序的正确执行</p><p>不精确断点法
: 流水线中指令执行完后再响应中断
: 影响中断反应时间,影响程序的正确执行</p><p>广义表
: 由零个或多个单元素或子表组成的有限序列
: 长度值元素个数,深度指展开后所含括号的最大层数
: 非空广义表表尾必定是一个表</p><p>CCIR/无线电咨询委员会
: 制定了广播级质量数字电视编码标准, CCIR601</p><p>算法的特征
: 有穷性: 在有穷步和有限时间内完成
: 确定性: 无二义,唯一的执行路径,同样测输入产生同样的输出
: 可执行性: 算法中描述的操作是通过已经实现的基本操作通过有限次执行实现的
: 正确性: 满足具体需求
: 可读性
: 健壮性: 能处理错误数据
: 效率与低存储需求</p><p>SIMD 中
: I 是指指令流 D 是指数据流</p><p>三类常用的空闲块管理方法
: 位图向量法, 空闲块链表链接法 和 索引法</p><p>死锁的四个必要条件</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不剥夺条件</li><li>环路等待条件</li></ul><h2>标准</h2><table><thead><tr><th>标准名</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://en.wikipedia.org/wiki/ISO/IEC_9126">ISO/IEC 9126</a></td><td>Software engineering — Product quality/软件工程 质量管理</td></tr><tr><td>ISO/TC 176</td><td>Quality management and quality assurance</td></tr><tr><td>GB904-91</td><td>商品条码结构</td></tr><tr><td>GB7590-87</td><td>第四辅助集</td></tr></tbody></table><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>国际标准</td><td>ISO,IEC</td></tr><tr><td>行业标准</td><td>IEEE</td></tr><tr><td>区域标准</td><td>CEN(欧洲标准化委员会)</td></tr><tr><td>已公布的行业代号</td><td>QJ(航天), SJ(电子), JB(机械), JR(金融系统)</td></tr><tr><td>企业标准的编号</td><td>行业标准代号+<!-- -->[/T]<!-- -->+标准发布顺序号(5位)+/+标准发布年代号(4位)</td></tr></tbody></table><h2>排序算法时间复杂度</h2><table><thead><tr><th>排序方法</th><th align="center">最优时间复杂度</th><th align="center">平均时间复杂度</th><th align="center">最差时间复杂度</th><th align="center">最差空间</th><th>辅助</th><th>稳定</th></tr></thead><tbody><tr><td>插入排序</td><td align="center">O(n)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n)</td><td>O(1)</td><td>Yes</td></tr><tr><td>选择排序</td><td align="center">-</td><td align="center">O(n<sup>2</sup>)</td><td align="center">-</td><td align="center">O(n)</td><td>~</td><td>No</td></tr><tr><td>冒泡排序</td><td align="center">O(n)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n)</td><td>~</td><td>Yes</td></tr><tr><td>希尔排序</td><td align="center">-</td><td align="center">O(nlog<sup>2</sup>n)</td><td align="center">-</td><td align="center">O(n)</td><td>~</td><td>No</td></tr><tr><td>快速排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">-</td><td>O(nlogn)</td><td>No</td></tr><tr><td>堆排序</td><td align="center">-</td><td align="center">O(nlogn)</td><td align="center">-</td><td align="center">O(n)</td><td>O(1)</td><td>Yes</td></tr><tr><td>归并排序</td><td align="center">(wiki:O(n))</td><td align="center">O(nlogn)</td><td align="center">-</td><td align="center">O(n)</td><td>O(n)</td><td>Yes</td></tr><tr><td>基数排序</td><td align="center">-</td><td align="center">O(d(n+rd))</td><td align="center">-</td><td align="center">-</td><td>O(rd)</td><td>Yes</td></tr><tr><td>基数排序<sup>1</sup></td><td align="center">-</td><td align="center">O(kN)</td><td align="center">-</td><td align="center">O(k+N)</td><td></td><td></td></tr><tr><td>二叉查找树</td><td align="center">-</td><td align="center">O(logn)</td><td align="center">-</td><td align="center">O(n)</td><td></td><td></td></tr></tbody></table><p>注
: 1 : 指维基上的结果
: ~  : 和上一个值相同</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Regex 速记]]></title>
            <link>https://wener.me/story/regex-note</link>
            <guid>regex-note</guid>
            <pubDate>Sun, 13 Oct 2013 00:00:00 GMT</pubDate>
            <description><![CDATA[需要注意的是, 由于正则在不同的流派中表示有所不同,只能整理一些几乎雷同的.]]></description>
            <content:encoded><![CDATA[<blockquote><p>需要注意的是, 由于正则在不同的流派中表示有所不同,只能整理一些几乎雷同的.
不同流派之间的差异,很多在是否需要转义上,例如 在有些流派里 <code>()</code> 要写成 <code>\(\)</code>
这里整理的主要是 PCRE 流派的正则语法</p></blockquote><h2>字符表示</h2><p>字符缩进表示
: <code>\n,\t,\a,\b,\e,\f,\r,\v</code></p><p>八进制转义
: <code>\num</code></p><p>十六进制转义/Unicode 转义
: <code>\xnum,\x{num},\unum,\Unum</code></p><p>控制字符
: <code>\cchar</code></p><h2>字符及相关结构</h2><p>普通字符组
: <code>[a-z].[^a-z]</code></p><p>几乎能匹配任何字符的元字符
: <code>.</code></p><p>单个字节
: &#x27;\C&#x27;</p><p>Unicode 组合字符序列
: <code>\X</code></p><p>字符组简记(大写为排除)
: <code>\w,\W,\s,\S,\d,\D</code></p><p>Unicode 属性区域和分类
: <code>\p{prop},\P{prop}</code></p><p>POSIX &quot;字符组&quot;方括号表示
: <code>[[:alpha:]]</code></p><p>POSIX &quot;Collating 序列&quot; 方括号表示
: <code>[[.span.-11.]]</code></p><p>POSIX &quot;字符等价类&quot; 方括号表示
: <code>[[=n=]]</code></p><h2>锚点及其他 &quot;零长度断言&quot;</h2><p>行/字符串起点
: <code>^, \A</code></p><p>行/字符串终点
: &#x27;$. \Z, \z&#x27;</p><p>本次匹配的开始位置/上次匹配的结束位置
: <code>\G</code></p><p>单词分界符
: <code>\b,\B,\&lt;,\&gt;</code></p><p>顺序环视
: <code>(?=...), (?!...)</code></p><p>逆序环视
: <code>(?&lt;=...),(?&lt;!...)</code></p><h2>注释和模式修饰词</h2><p>模式修饰词
: <code>(?modifier),(-?modifier)</code>
: eg:<code>(?i)...(?-i)</code></p><p>模式作用范围
: <code>(?modifier:...)</code>
: eg:<code>(?i:....)</code></p><p>注释
: <code>(?#...),#...</code></p><p>文本范围
: <code>\Q,\E</code></p><h2>分组,捕获,条件判断和控制</h2><p>捕获/分组
: <code>(...),\1,\2</code></p><p>仅用于分组
: <code>(?:...)</code></p><p>命名捕获
: <code>(?&lt;name&gt;...)</code></p><p>固化分组
: <code>(?&gt;...)</code></p><p>多选
: <code>...|...|...</code></p><p>条件判断
: <code>(?if then|else)</code></p><p>匹配优先量词
: <code>*,+,?,{m,n}</code></p><p>忽略优先量词
: <code>*?,+?,??,{m,n}?</code></p><p>占有优先量词
: <code>*?,++,?+,{m,n}+</code></p><h2>命名字符组</h2><p>关于这些字符组的命名,可以参考<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/ctype.h.html">susv-ctype</a>.需要注意的是,在 unicode 里,这些字符组的定义要根据 unicode 的定义来判断.会包含额外的同义的字符.</p><table><thead><tr><th align="right">组</th><th align="left">描述</th></tr></thead><tbody><tr><td align="right">[:alnum:]</td><td align="left"></td></tr><tr><td align="right">[:alpha:]</td><td align="left">字母</td></tr><tr><td align="right">[:blank:]</td><td align="left">空白</td></tr><tr><td align="right">[:cntrl:]</td><td align="left">控制符</td></tr><tr><td align="right">[:digit:]</td><td align="left"></td></tr><tr><td align="right">[:graph:]</td><td align="left">可显示</td></tr><tr><td align="right">[:lower:]</td><td align="left">小写</td></tr><tr><td align="right">[:upper:]</td><td align="left">大写</td></tr><tr><td align="right">[:space:]</td><td align="left">包括 <!-- -->[:blank:]<!-- -->, 换行, 回车及其他</td></tr></tbody></table><h2>测试引擎类型</h2><p><code>nfa|nfa.not</code> 匹配 <code>nfa.not</code></p><table><thead><tr><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>nfa</td><td>传统 NFA</td></tr><tr><td>nfa.not</td><td>POSIX / DFA</td></tr></tbody></table><p>DFA 不支持捕获型括号和回溯</p><p><code>x(.+)+x</code> 匹配 <code>=xx============================================================</code></p><table><thead><tr><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>时间长</td><td>NFA</td></tr><tr><td>时间短</td><td>DFA, 但也有可能是混合的或优化的</td></tr></tbody></table><table><thead><tr><th>引擎</th><th>工具</th></tr></thead><tbody><tr><td>DFA</td><td>awk, egrep, flex, lex, MySQL, Procmail</td></tr><tr><td>Tranditional NFA</td><td>GNU Emacs, Java, grep, less, more, .NET, PCRE, Perl, PHP, Python, Vi, Ruby, sed</td></tr><tr><td>POSIX NFA</td><td>mawk, Mortricekern System;s utiles, GNU Emacs</td></tr><tr><td>DFA/NFA</td><td>GNU awk, GNU grep, Tcl</td></tr></tbody></table><h2>匹配基础</h2><p>规则 1
: 优先选择最左端的匹配结果</p><p>规则 2
: 标准量词是匹配优先的</p><p>NFA
: 表达式主导</p><p>DFA
: 文本主导,不关心表达式的形式
: 即 <code>x*=x?x?...=(x(x(x...)?)?)?</code></p><p>匹配优先量词和忽略优先量词控制,对回溯状态选择,是跳过还是进行.</p><p>环视模拟固化分组
: <code>(?&gt;...) =&gt; (?=(...))\1</code></p><p>多选结构即非匹配优先,也非忽略优先,而是顺序优先
: eg: <code>(to|tow) =~ &quot;tow&quot; = &quot;to&quot;</code></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[简单的文字气泡框 for Swing]]></title>
            <link>https://wener.me/story/java-siwng-textbubble</link>
            <guid>java-siwng-textbubble</guid>
            <pubDate>Sat, 12 Oct 2013 00:00:00 GMT</pubDate>
            <description><![CDATA[TextBubbleBorderDemo screenschot]]></description>
            <content:encoded><![CDATA[<p><img src="https://git.oschina.net/wenerme/wener/raw/master/screenshot/TextBubbleBorderDemo.png" alt="TextBubbleBorderDemo screenschot" title="TextBubbleBorderDemo"/></p><p><a href="http://resources.wener.me/java/TextBubbleBorderDemo.java">代码下载</a></p><p><a href="http://resources.wener.me/java/TextBubbleBorderDemo.jar">程序下载</a></p><p><a href="http://resources.wener.me/java/TextBubbleBorderDemo.jnlp">运行程序</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[数据库原理 for NCRE 4]]></title>
            <link>https://wener.me/story/ncre-4-database-note</link>
            <guid>ncre-4-database-note</guid>
            <pubDate>Tue, 24 Sep 2013 00:00:00 GMT</pubDate>
            <description><![CDATA[记录自 全国高等教育制定教材 数据库原理]]></description>
            <content:encoded><![CDATA[<blockquote><p>记录自 <strong>全国高等教育制定教材 数据库原理</strong>
和 部分自己的整理</p></blockquote><hr/><h2>1. 数据库系统的基本概念</h2><h3>1.2 数据描述</h3><h4>1.2.1 概念设计中的数据描述</h4><p>实体(Entity):
: 客观存在,可以相互区别的事物成为实体</p><p>实体集(Entity Set)
: 性质相同的同类实体的集合</p><p>属性(Attribute)
: 实体的特性称为属性</p><p>实体标识符(Indentify)
: 能唯一标识实体的属性或属性集</p><h4>1.2.2 逻辑设计中的数据描述</h4><p>记录(Record)
: 字段的有序集合</p><p>字段(Field)
: 标记实体属性的命名单位称为字段或数据项</p><p>文件(File)
: 同一类记录的集合</p><p>关键码(Key)
: 能唯一便是文件中某个记录的字段或字段集</p><h4>术语的对应关系</h4><table><thead><tr><th>概念设计</th><th>逻辑设计</th></tr></thead><tbody><tr><td>实体</td><td>记录</td></tr><tr><td>属性</td><td>字段</td></tr><tr><td>实体集</td><td>文件</td></tr><tr><td>实体标识符</td><td>关键码</td></tr></tbody></table><h4>1.2.4 数据联系的描述</h4><p>联系 (Relationship)
: 实体之间的相互关系,与一个联系相关的实体个数称为联系的元数</p><p>联系的类型
: 一对一,一对多,多对多 1:1, 1:N, N:M</p><h3>1.3 数据的抽象级别</h3><h4>1.3.1 数据抽象过程</h4><p>模型(Model)
: 对现实世界的抽象</p><p>数据模型(Date Model)
: 数据库的结构和语义,对现实世界的数据进行抽象</p><p>: &gt; <strong><a href="http://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">wiki-数据模型</a></strong> 数据模型是定义数据如何输入和与输出的一种模型。
其主要作用是为信息系统提供数据的定义和格式。数据模型是数据库系统的核心和基础，
现有的数据库系统都是基于某种数据模型而建立起来的。</p><h4>1.3.2 概念模型</h4><ol><li>表达数据的整体逻辑结构，是系统用户对整个应用项目设计的数据的全面描述</li><li>从用户的观点出发，对数据建模</li><li>独立于硬件和软件</li><li>是数据库设计人员与用户之间进行交流的工具</li></ol><h4>1.3.3 逻辑模型</h4><ol><li>表达了DB的整体逻辑结构,设计人员对整个应用项目数据库的全面描述</li><li>从数据库的实现观点出发,对数据建模</li><li>独立于硬件,依赖于软件</li><li>数据库设计人员与应用程序员之间进行交流的工具<blockquote><p>逻辑模型的类型: 层次,网状,关系</p></blockquote></li></ol><h4>1.3.4 外部模型</h4><ol><li>是逻辑模型的子集</li><li>独立于硬件,依赖于软件</li><li>反应用户使用数据库的观点</li></ol><h5>外部模型的优点</h5><ol><li>简化用户的观点</li><li>有助于数据的安全性保护</li><li>外部模型是对概念模型的支持</li></ol><h4>1.3.5 内部模型</h4><p>内部模型也叫做物理模型,是数据库最底层的抽象,它描述数据在磁盘或磁带上的存储方式,存取设备和存取方法</p><blockquote><p>现今的内部细节大多由操作系统实现</p></blockquote><h4>1.3.6 三层模型和两级映象</h4><ul><li>三层模型即上述的: 外部,逻辑,内部</li><li>两层映象为: 内部 &lt;-&gt; 逻辑, 逻辑 &lt;-&gt; 内部</li><li>优点: 增强了独立性,不同模式层次之间的操作由映射完成</li></ul><h3>1.4 数据库管理系统(DBMS)</h3><h4>1.4.1 DBMS的工作模式</h4><p>数据库操作系统(DBMS)
: 是指数据库系统中对数据进行管理的软件系统。它是数据库系统的核心组成部分.对DB的一切操作,
包括定义,查询,更新及各种控制,都是通过DBMS进行的.</p><h5>DBMS的工作模式</h5><ol><li>接受应用程序的数据请求和处理请求</li><li>将用户的数据请求(高级指令)转换(编译)成复杂的机器码(低级指令)</li><li>实现对数据库的操作</li><li>从对数据库的操作中接受查询结果</li><li>对查询结果进行处理(格式转换)</li><li>将处理结果返回给用户</li></ol><h5>DBMS的主要功能</h5><ol><li>定义(DDL)</li><li>操纵(DML)</li><li>数据库的保护功能<ol><li>数据库的恢复</li><li>并发控制</li><li>完整性控制</li><li>安全性控制</li></ol></li><li>数据库的维护功能
包括数据的载入,转换,转储,数据库的改组以及性能监控等</li><li>数据字典
数据库系统中存放三级结构定义的数据库成为数据字典(DD)</li></ol><blockquote></blockquote><h3>1.5 数据库系统(DBS)</h3><h4>1.5.1 DBS的组成</h4><p>DBS 是采用了数据库技术的计算机系统.它是数据库,硬件,软件和数据库管理员的集合体.</p><p>数据库(DB)
: 是各项应用有关的全部数据的集合.分为两类,一类是应用数据的集合,成为物理数据库,
是数据库的主题;另一类是各级数据结构的描述,称为描述数据库,由DD系统管理.</p><h5>数据库管理员(DBA)</h5><p>DBA需要具备的素质</p><ul><li>熟悉企业全部数据的性质和用途</li><li>对所有用户的需求有</li></ul><h4>1.5.2 DBS的全局结构</h4><p>常见书上的图 1.21</p><h4>1.5.3 DBS的笑意</h4><ol><li>灵活性</li><li>简易性</li><li>面向用户</li><li>有效的数据控制</li><li>加快应用系统的开发速度</li><li>维护方便</li><li>标准化</li></ol><hr/><h2>2. 数据库设计和 ER 模型</h2><h3>2.1 数据库系统生存期</h3><p>数据库生存期一般分为七个阶段: 规划,需求分析,概念设计,逻辑设计,实现,运行维护</p><h4>2.1.1 规划阶段</h4><p>对于数据库系统,特别是大型数据库系统或大型信息系统中的数据库群,规划阶段是十分必要的.
规划的好坏将直接影响到整个系统的成功与否,对应用单位的信息化进程将产生深远影响.</p><p>规划阶段的具体步骤:</p><ol><li><p>系统调查
对应用单位做全面的调查.发现其存在的主要问题,并画出组织层次图,以了解企业的组织结构</p></li><li><p>可行性分析
从技术,经济,效益,法律等诸方面对建立数据库的可行性进行分析,然后写出可行性分析报告;组织专家进行讨论其可行性</p></li><li><p>确定数据库系统的总目标, 并对应用单位的工作流程进行优化和制定项目开发计划.
在得到决策部门批准后,就正式进入数据库系统的开发工作</p></li></ol><h4>2.1.2 需求分析阶段</h4><p>这一阶段是计算机人员(系统分析员)和用户双方共同收集数据库所需的信息内容和用户对处理的需求,
并以需求说明书的形式确定下来,作为以后开系统开发的指南和系统验证的依据</p><p>需求分析阶段的具体步骤:</p><ol><li>分析用户活动,产生业务流程图</li><li>确定系统范围,产生系统关系图</li><li>分析用户活动涉及的数据,产生数据流图(DFD)</li><li>分析系统数据,产生数据字典</li></ol><blockquote><p>数据字典中通常包括数据项,数据结构,数据流,数据存储和处理5个部分</p></blockquote><h4>2.1.3 概念设计阶段</h4><p>概念设计的目标是产生反应用户单位信息需求的数据概念结构,即概念结构,概念模型独立于计
算机硬件结构,独立于支持数据的DBMS.</p><p>概念设计的主要步骤:</p><ol><li><p>进行数据抽象,设计局部概念模型</p><blockquote><p>设计概念结构时,常用的数据抽象方法是&quot;聚集&quot;和&quot;概括&quot;</p></blockquote></li><li><p>将局部概念综合成全局概念模型</p></li><li><p>评审
确认全局结构是否完整,各种划分是否合理,是否存在不一致性,各种文档是否齐全</p></li></ol><h4>2.1.4 逻辑设计阶段</h4><p>概念设计的结果是得到一个与DBMS无关的概念模型.而逻辑设计的目的是把概念设计阶段设计好的
概念模型转换成具体的逻辑模型.</p><p>逻辑设计的主要步骤:</p><ol><li>把概念模型转换成逻辑模型
ER模型转换成关系模型</li><li>设计外模型</li><li>设计应用程序与数据库的接口</li><li>评价模型</li><li>修正模型</li></ol><h4>2.1.5 物理设计阶段</h4><p>具体步骤:</p><ol><li>存储记录结构设计</li><li>确定数据存放位置</li><li>存取方法的设计</li><li>完整性和安全性考虑</li><li>程序设计</li></ol><h4>2.1.6 数据库的实现</h4><p>主要包括</p><ol><li>用DDL定义数据库结构</li><li>数据装载/组织数据入库
具体步骤: 筛选数据, 输入数据, 转换数据格式, 校验数据, 综合数据</li><li>编制与调试应用程序
该步骤使用模拟数据进行调试</li><li>数据库试运行
功能调试,性能测试</li></ol><h4>2.1.7 数据库的运行与维护</h4><p>在数据库运行阶段,对数据库经常性的维护工作主要由DBA完成,它包括以下内容:</p><ol><li>数据库的转储和恢复</li><li>数据库安全性,完整性控制</li><li>数据库性能的监督,分析和改进</li><li>数据库的重组织和重构造</li></ol><hr/><h2>3. 关系模式设计理论</h2><p>关系模式设计理论主要包括三个方面的内容: 数据依赖,范式和模式设计方法</p><h3>3.1 关系模式的设计准则</h3><h4>3.1.1 关系模式的冗余和异常问题</h4><p> <strong>分解</strong>是解决冗余的主要方法,也是规范化的一条原则:&quot;关系模式有冗余,就分解它&quot;</p><h4>3.1.2 关系模式的非形式化设计准则</h4><p>准则 3.1
: <small>关系模式的设计尽可能</small>只包含有直接联系的属性,不要包含有间接联系的属性.
也就是,每个关系关系模式应只对应于一个实体类型或一个联系类型.</p><p>准则 3.2
: <small>关系模式的设计尽可能使得相应关系中</small>不出现插入,删除和修改等操作异常现象.
如果出现任何异常,则要清楚的加以说明,并确保更新数据库的程序正确操作.</p><p>准则 3.3
: <small>关系模式的设计尽可能使得相应关系中</small>避免放置经常为空的属性.</p><p>准则 3.4
: <small>关系模式的设计应尽可能使得</small>关系的等值连接在主键和外键的属性上进行,
并且保证连接以后不会产生额外的元组.</p><pre><code>&gt; 如果两个连接匹配的不是外键或主键,那么这种连接很可能会产生额外元组
</code></pre><h3>3.2 函数依赖</h3><h4>3.2.1 函数依赖的定义</h4><p>定义 3.1
: 设有关系模式 R(U), X 和 Y 是属性集 U 的子集,
<strong>函数依赖(FUnctional Dependency, 简记为 FD)</strong>
是形成 $x\rightarrow y$ 的一个命题, 只要r是R的当前关系,
对r中任意两个元组 t 和 s,都有 t<!-- -->[X]<!-- --> = s<!-- -->[X]<!-- --> 蕴含 t<!-- -->[Y]<!-- --> = s<!-- -->[Y]<!-- -->,
那么称 $FD\quad x\rightarrow y$ 在关系模式 R(U)中成立.</p><p>这里 t<!-- -->[X]<!-- --> 表示元组 t 在属性集 X 上的值,其余类同. $X \rightarrow Y$ 读作 X 函数决定 Y,
或 Y 函数依赖于 X. FD 是对关系模式 R 的一切可能的关系 r 定义的. 对于当前关系 r 的任意两个元组,
如果 X 相同,则要求 Y 值也相同.即有一个 X 值就有一个 Y 值与之对应, 或者说 Y 值由 X 值决定.
因而这种依赖称为函数依赖.</p><p>当关系模式上存在函数依赖时,对其关系中的值将有严格的限制.</p><p>定义 3.2
: 如果 $X \rightarrow Y$ 和 $Y \rightarrow X$ 同时成立,则可记为 $X \leftrightarrow Y$.
也就是在关系中, X 值和 Y 值具有一一对应的关系.</p><h4>3.2.2 FD 的逻辑蕴含</h4><p>定义 3.3
: 设 F 是在关系模式 R 上成立的函数依赖的集合, $X \rightarrow Y$ 是一个函数依赖.
如果对于 R 的每个满足 F 的关系 r 也满足 $X \rightarrow Y$, 那么 F 逻辑蕴含
$X \rightarrow Y$,记为 $F \models X\rightarrow Y$.</p><p>定义 3.4
: 设 F 是函数依赖集, 被 F 逻辑蕴含的函数依赖全体构成的集合,称为函数依赖集 F 的
<strong>闭包(Closure)</strong>, 记为${ F }^{ + }$ . 即
$$
{ F }^{ + }=<!-- -->{<!-- --> \quad X\rightarrow Y\quad |\quad F \models X\rightarrow Y\quad <!-- -->}<!-- -->
$$</p><h4>3.2.3 FD 的推理规则</h4><p>设 U 是关系模式 R 的属性集. F 是 R 上成立的只涉及到 U 中舒心的函数依赖集. FD 的推理规则有以下三条:</p><p>自反性(Reflexivity)
: A1
: 若 $Y \subseteq X \subseteq U$, 则 $X \rightarrow Y$ 在 R 上成立.</p><p>增广性(Augmentation)
: A2
: 若 $X \rightarrow Y$在 R 上成立,且 $Z \subseteq U$, 则 $XZ \rightarrow YZ$在 R 上成立.</p><p>传递性(Transitivity)
: A3
: 若 $X \rightarrow Y$ 和 $Y \rightarrow Z$ 在 R 上成立,
则 $X \rightarrow Z$在 R 上成立.</p><p>定理 3.1
: FD 推理规则 A1, A2 和 A3. 也就是, 如果 $X \rightarrow Y$
是从 F 用推理规则导出, 那么 $X \rightarrow Y$在$F^+$中</p><p><strong>定理 3.2</strong> FD 的其他五条推理规则</p><p>合并性(Union)
: A4
: $ <!-- -->{<!-- --> X \rightarrow Y, Y \rightarrow Z <!-- -->}<!-- --> \models X \rightarrow YZ$</p><p>分解性(Decomposition)
: A5
: $<!-- -->{<!-- --> X \rightarrow Y, Z \subseteq Y <!-- -->}<!-- --> \models X \rightarrow Z$</p><p>伪传递性
: A6
: $ <!-- -->{<!-- --> X \rightarrow Y, WY \rightarrow Z <!-- -->}<!-- --> \models WX \rightarrow Z$</p><p>复合性(Composition)
: A7
: $<!-- -->{<!-- --> X \rightarrow Y, W \rightarrow Z <!-- -->}<!-- --> \models XW \rightarrow YZ$</p><p>通用一致性定理(Genernal Unification Theorem)
: $<!-- -->{<!-- --> X \rightarrow Y, W \rightarrow Z <!-- -->}<!-- --> \models X \cup (W - Y) \rightarrow YZ$</p><p>定义 3.5
: 对于 $FD X \rightarrow Y$, 如果 $Y \subseteq X$, 那么称 $X \rightarrow Y$
是一个 <strong>平凡的 FD</strong>, 否则称为 <strong>非平凡的 FD</strong></p><p>正如名称所示,平凡的 FD 并没有实际意义,根据规则 A1 就可以退出. 人们感兴趣的是非平凡的 FD.
只有非平凡的 FD 才和 <em>真正的</em> 完整性约束条件相关.</p><p>从规则 A4 和 A5. 立即可得到下面的定理</p><p>定理 3.3
: 如果 $A_1 \cdots A_n$ 是关系模式 R 的属性集, 那么 $X \rightarrow A_1 \cdots A_n$
成立的充分必要条件是 $X \rightarrow A_i (i = 1, \cdots, n)$ 成立</p><h4>3.2.4 FD 和关键码的联系</h4><p>函数依赖是关键码概念的推广.</p><p>定义 3.6
: 设关系模式 R 的属性集是 U, X 是 U 的一个子集.如果 $X \rightarrow U$ 在 R 上成立,
那么称 X 是 R 的一个超键. 如果 $X \rightarrow U$子 R 上成立,但对于 X 的任一真子集
$X_1$ 都有 $X_1 \rightarrow U$ 不成立,那么称 X 是 R 上的一个候选键(没有多余属性).</p><p>一般键都是指候选键.</p><h4>3.2.5 属性集的闭包</h4><p>定义 3.7
: 设 F 是属性集 U 上的 FD 集, X 是 U 的子集. 那么(相对于 F)属性集 X 的闭包用 $X^+$
表示, 它是一个从 F 集使用 FD 推理规则推出的满足所有 $X \rightarrow A$的属性A的集合:
$$
X^+ = <!-- -->{<!-- -->\quad 属性 A \quad |\quad  F \models X \rightarrow A \quad <!-- -->}<!-- -->
$$</p><p>从属性集闭包的定义,立即可得出下面的定理</p><p>定理 3.4
: $X \rightarrow Y$ 能用 FD 推理规则推出的充分必要条件是 $Y \subseteq X^+$</p><p>算法 3.1
: 求属性集 X 相对于 FD 集 F 的闭包 $X^+$
: 设属性集 X 的闭包为 $X^+$, 其计算算法如下:
$$
\qquad X^+ = X; \qquad<!-- -->\<!-- -->
do  <!-- -->{<!-- --> \qquad\qquad\qquad\qquad <!-- -->\<!-- -->
oldX^+ := X^+; <!-- -->\<!-- -->
\qquad\qquad\qquad\qquad
for\quad {FD}\quad Y \rightarrow Z\quad in\quad F\quad do <!-- -->\<!-- -->
\qquad\qquad\qquad\qquad\qquad\qquad
if\quad Y \subseteq X^+ then\quad X^+ := X^+\cup Z; <!-- -->\<!-- -->
<!-- -->}<!-- --> while(X^+ != oldX^+);
$$</p><h4>3.2.6 FD 集的最小依赖集</h4><p>定义 3.8
: 如果关系模式 R(U) 上的两个函数依赖集 F 和 G, 有 $F^+ = G^+ $,则称 F 和 G
是等价的函数依赖集</p><p>F 和 G 等价,意味着 F 中每一个 FD 都可以从 G 推导出来, 并且 G 中每一个 FD也都可以从F推导出来</p><p>函数依赖集 F 中的 FD 很多,我们应该从 F 中去掉平凡的 FD, 无关的 FD, FD 中无关的属性,
以求得与 F 等价的最小依赖集 G.</p><p><strong>定义 3.9</strong>
如果函数依赖集 G 满足下列三个条件,则称 G 是最小依赖集</p><ol><li>G 中每个 FD 的右边都是单属性</li><li>G 中没有冗余的 F, 即 G 中不存在这样的函数依赖 $X \rightarrow Y$,
使得 $G - <!-- -->{<!-- --> X \rightarrow Y <!-- -->}<!-- -->$ 与 G 等价</li><li>G 中每个 FD 的左边没有冗余的属性, 即 G 中不存在这样的函数依赖 $X \rightarrow Y$,
X 有真子集 W 使得 $G - <!-- -->{<!-- -->X \rightarrow Y <!-- -->}<!-- --> \cup <!-- -->{<!-- --> W \rightarrow Y <!-- -->}<!-- -->$
与 G 等价.</li></ol><blockquote><p>显然, 每个函数依赖集至少存在一个等价的最小依赖集,但并不一定唯一</p></blockquote><p><strong>算法 3.2</strong>
: 计算函数依赖集 F 的最小依赖集 G</p><pre><code>1. 根据推理规则的分解特性(A5),得到一个与 F 等价的 FD 集 G,
G中每个FD的左右均为单属性
2. 在 G 的每个 FD 中消除左边冗余的属性
3. 在 G 中消除冗余的 FD
</code></pre><h3>3.3 关系模式的分解特性</h3><h4>3.3.1 关系模式的分解</h4><p>定义 3.10
: 设有关系模式 R(U), 属性集为 U, 而 $R_1,\cdots,R_k$都是 U 的子集,
并且有$R_1 \cup R_2 \cup \cdots \cup R_k = U$. 关系模式 $R_1,\cdots,R_k$
的集合用 $\rho$ 表示, $\rho = <!-- -->{<!-- --> R_1,\cdots,R_k <!-- -->}<!-- -->$. 用$\rho$代替 R 的过程
称为关系模式的分解.这里$\rho$称为 R 的一个分解.也称为<strong>数据库模式</strong>.</p><h4>3.3.2 无损分解</h4><p>定义 3.11
: 在泛关系模式 R 分解陈数据库模式 $\rho = R_1,\cdots,R_k$时,
泛关系 r 在 $\rho$ 的每一模式 $R_i (1 \le i \le n)$上投影后
再连接起来,比原来r中多出来的元组,称为 <strong>寄生元组(Spurious Tuple)</strong>.</p><p>定义 3.12
: 设 R 是一个关系模式, F 是 R 上的一个 FD 集. R 分解成数据库模式
$\rho = R<em>1,\cdots,R_k$.如果对 R 中满足 F 的每一个关系 r, 都有
$$
r \quad=
\quad\pi</em>{R<em>2}\quad(r)
\quad\rhd\lhd \quad \pi</em>(R<em>2)(r)
\quad\rhd\lhd \quad \cdots \pi</em>(R_k)(r)
$$</p><p>那么称分解 $\rho$ 相对于 F 是<strong>无损连接分解(Lossless Join Decomposition)</strong>,
简称为 <em>无损分解</em>,否则称为 <strong>损失分解(Lossy Decomposition)</strong></p><p><em>损</em>是指信息的丢失,而不是元组的丢失.如果一个分解不具有<em>无损</em>性质,
那么泛关系在投影连接以后就可能产生寄生元组.寄生元组表示的是错误信息.</p><p>其中符号 $\pi<em>{R_i}(r)$ 表示关系 r 在模式 $R_i$属性上的投影.
r 的投影连接表达式 $\pi</em>{R<em>1}(r) \quad \rhd\lhd \quad \cdots \pi</em>{R<em>k}(r)$
用符号$m</em>{\rho}(r)$表示, 即
$$
m<em>{\rho}(r) = \overset {k}{\underset { i=1 }{ \rhd \lhd }}\pi</em>{R_i}(r)
$$</p><p>需要注意的是,上述定义有一个先决条件,即 r 是 R 的一个关系. 也就是先存在 r(泛关系)
的情况下,再去谈论分解,这是关系数据库理论中著名的<strong>泛关系假设(Universal Relation Assumption)</strong></p><p>定义 3.13
: 在无泛关系假设时,对两个关系进行自然连接中被丢失的元组称为悬挂元组.</p><blockquote><p>悬挂元组是造成两个关系不存在泛关系的原因.</p></blockquote><h4>3.3.3 模式分解的优缺点</h4><p>优点:</p><ol><li>模式分解能消除数据冗余和操作异常现象</li><li>在分解了的数据库中可以存储悬挂元组,存储泛关系中无法存储的信息</li></ol><p>缺点:</p><ol><li>分解以后,检索操作需要做笛卡尔积或连接操作,这将付出时间代价</li><li>在有泛关系假设时,对数据库中关系进行自然连接时,可能产生寄生元组,
即损失了信息.在无泛关系假设时,由于数据库可能存在悬挂元组,就有可能
不存在泛关系</li></ol><h4>3.3.4 无损分解的测试方法</h4><p>略</p><h4>3.3.5 保持 FD 的分解</h4><p>分解的另一个特性是在分解的过程中能否保持函数依赖集,如果不能保持 FD, 那么数据的
寓意就会出现混乱.</p><p>定义 3.14
: 设 F 是属性集 U 上的 FD 集, Z 是 U 的子集, F 在 Z 上的投影用$\pi_Z(F)$
表示,定义为
$$
\pi_Z(F) = <!-- -->{<!-- -->\quad
X \rightarrow Y | X \rightarrow Y \in F^+, 且 XY \subseteq Z
\quad <!-- -->}<!-- -->
$$</p><p>定义 3.15
: 设 $\rho = <!-- -->{<!-- --> R<em>i, \cdots, R_k<!-- -->}<!-- -->$ 是 R 的一个分解, F 是R 上的 FD 集, 如果有
$\overset {k}{\underset { i=1 }{ \cup }}\pi</em>{R_i}(F) \models F$,
那么称分解 $\rho$ 保持函数依赖集 F.</p><h3>3.4 范式</h3><p>关系模式的好与坏,用什么标准来衡量? 这个标准就是模式的<strong>范式(Normal Forms, 简记为 FN)</strong>.</p><h4>3.4.1 第一范式(1NF)</h4><p>定义 3.16
: 如果关系模式 R 的每个关系 r 的属性值都是不可分的原子值,那么称 R 是
<strong>第一范式(First Normal Forms, 简记为 1NF)</strong>的模式.</p><p>满足 1NF 的关系称为规范化的关系,否则称为非规范化的关系.关系数据库研究的关系都是规
范化的关系.</p><h4>3.4.2 第二范式(2NF)</h4><p>定义 3.17
: 对于 $FD\quad W\rightarrow A$,如果存在 $X \subset W$ 有 $X \rightarrow A$
成立, 那么称 $W \rightarrow A$ 是局部依赖(A 局部依赖于 W);否则称$W\rightarrow A$
是完全依赖.</p><p>完全依赖也称为<strong>左部不可约依赖</strong>.</p><p>定义 3.18
: 如果 A 是关系模式 R 的候选键的属性,那么称 A 是 R 的主属性; 否则称 A 是 R 的非主属性</p><p>定义 3.19
: 如果关系模式 R 是 1NF, 且每个非主属性完全函数依赖于候选键,那么称 R 是第二范式(2NF)的
模式.如果数据库模式中每个关系模式都是 2NF,则称数据库模式为 2NF 的数据库模式.</p><blockquote><p>不满足 2NF的关系模式中必定存在有非主属性对关键码的局部依赖.</p></blockquote><h4>3.4.3 第三范式(3NF)</h4><p>定义 3.20
: 如果 $X \rightarrow Y , Y \rightarrow A, 且 Y \nrightarrow X 和 A \notin Y
,那么称 X \rightarrow A $是传递依赖(A 传递依赖于 X).</p><p>定义 3.21
: 如果关系模式 R 是 1NF, 且每个非主属性都不传递依赖于 R 的候选键,那么称 R 是第三范式
(3NF)的模式.如果数据库模式中每个关系模式都是 3NF,则称其为 3NF 的数据库模式.</p><p>定义 3.22
: 设 F 是关系模式 R 的 FD 集, 如果对 F 中每个非平凡的 $FD\quad X\rightarrow Y$,
都有X是R的超键,或者 Y 的每个属性都是主属性, 那么称 R 是3NF 的模式.</p><p>定理 3.5
: 如果 R 是 3NF 模式,那么 R 也是2NF 模式.</p><p>局部依赖和传递依赖是模式产生冗余和异常的两个重要原因. 由于 3NF 模式中不存在非主属性
对候选键的局部依赖和传递依赖,因此消除了很大一部分存储异常.
将 1NF, 2NF 转换为 3NF 的过程称为 关系的规范化处理.</p><h4>3.4.4 BCNF(Boyoce-Codd NF)</h4><p>定义 3.33
: 如果关系模式 R 是 1NF, 且每个属性都不传递依赖于 R 的候选键,那么称 R 是 BCNF 模式.
如果数据库中的所有关系模式都是 BCNF, 则称为 BCNF 的数据库模式.</p><p>定义 3.34
: 设 F 设计关系模式 R 的FD 集, 如果对 F 中每个非平凡$FD \quad X \rightarrow Y$
都有 X 是 R 的超键,那么称 R 是 BCNF 模式.</p><p>这个定义表明,如果非平凡的 $FD\quad X\rightarrow Y$中 X 不包含超键,那么 Y 必定
传递依赖于候选键, 因此 R 不是 BCNF 模式.</p><p>定理
: 3.6 如果 R 是 BCNF 模式,那么 R 也是 3NF 模式</p><h3>3.5 多值依赖和第四范式</h3><p>略</p><hr/><h2>Appendix.A ER 模型</h2><h3>1. ER 模型的基本元素</h3><h4>1.1. 实体</h4><p>实体(Entity)
: 是一个数据对象,指应用中可以区别的客观存在的事物</p><p>实体集(Entity Set)
: 是指同一类</p><p>实体类型(Entity Type)
: 是对实体集中实体的定义</p><h4>1.2. 联系</h4><p>联系(Relationship)
: 表示一个或多个实体之间的关联关系</p><p>联系集(Relationship Set)
: 是指同一类联系构成的集合</p><p>联系类型(Relationship Type)
: 是对联系集中联系的定义</p><h4>1.3 属性</h4><p>实体的某一特性称为属性(Attribute).在一个实体中,能够唯一标识实体的属性或属性
集称为&quot;实体标识符&quot;.</p><h3>2. 属性的分类</h3><h4>2.1 简单属性和复合属性</h4><p>简单属性(Simple Attribute)
: 简单属性是不可再分割的属性.例如: 年龄,性别</p><p>复合属性(Composite Attribute)
: 复合属性是可以再分解为其他属性的属性.例如: 地址可分为省,市,区,街道等子属性</p><h4>2.2 单值属性和多值属性</h4><p>单值属性(Single-Valued Attribute)
: 是指同一个实体的属性只能取一个值.例如: 年龄,性别</p><p>多值属性(Mulyi-Valued Attribute)
: 实体属性可取多个值.例如: 一个文章的标签,可能会有多个标签</p><h5>分解多值属性的方法</h5><ol><li>将原来的多值属性用几个新的单值属性表示</li><li>将多值属性用一个新的实体类型表示</li></ol><h4>2.3 存储属性和派生属性</h4><p>派生属性(Derived Attribute)
: 两个(或两个以上)属性是相关的.可以从其他属性推导该属性的值</p><pre><code>&gt; 派生属性的值不必存储在数据库内
</code></pre><p>存储属性(Stored Attribute)
: 反之,除了能推导出值的派生属性,其他都是存储属性.</p><h4>2.4 可空属性</h4><p>可空属性(Null Value)
: 当实体在某个属性上没有值时,可以使用空值(Null Value)的属性
: 例如: 配偶,当未婚是该值无意义,即可为空,但也可以理解为已婚但配偶未知,或尚不知是否婚
: 否.在数据库中,空值是很难处理的一种值.</p><h3>3. 联系的设计</h3><h4>3.1 联系的元数</h4><p>元数/度数(Degree)
: 一个联系涉及到的实体集的个数
: 简单的可称之为 一元联系,二元联系,三元联系</p><h4>3.2 联系类型的约束</h4><h5>3.2.1 基数约束</h5><p>映射基数(Mapping Cardinalities)
: 实体集 E1 和 E2 之间有二元联系,则参与一个联系中的实体数目成为映射基数
: 对于二元联系类型,可能的映射基数有 1:1, 1:N, N:M,</p><h5>3.2.2 参与约束</h5><p>完全参与
: 如果实体集 E 中的内阁实体都参与联系集 R 的至少一个联系中,则称实体集 E 完全参与 联系集 R</p><h4>3.3 ER模型的操作</h4><p>ER 模型的操作包括实体类型,联系类型和属性的分裂,合并,增删 等</p><blockquote><p>分裂方式有水平分裂和垂直分裂两种
合并是分裂的逆操作过程,合并的联系类型必须是定义在相同的实体类型组合中</p></blockquote><h4>3.4 采用ER模型的数据库概念设计步骤</h4><p>采用 ER 模型进行数据库的概念设计,可以分成三步进行: 设计局部 ER 模型,然后把各局部 ER 模型综合成一个全局 ER 模型,最后对全局 ER 模型进行优化,得到最终的 ER 模型,即概念模型.</p><h5>3.4.1 设计局部 ER 模型</h5><ol><li><p>确定局部结构范围
一个数据结构是为多个不同用户服务的.各个用户使用数据的方法不同,需求不同.固先为各种用户确定局部的使用方法,并以 ER 模型来表示.
需要考虑的因素</p><pre><code>1. 范围划分要自然,易于管理
2. 范围之间的界面要清晰,相互影响要小
3. 范围的大小要适度
</code></pre></li><li><p>定义实体
每一个局部结构都包含一些实体类型,实体定义的任务就是从信息需求和局部范围定义出发,确定每一个实体类型的属性和键.
划分的依据通常有:</p><ol><li>采用人们习惯的划分</li><li>避免冗余</li><li>依据用户的信息处理需求</li></ol></li><li><p>定义联系</p></li><li><p>分配属性
分配属性分为两个步骤: 一是确定属性,二是把属性分配到
确定属性的原则:</p><ol><li>属性应该是不可再分解的寓意范围.不可分解是为了使模型结构简单化,不出现嵌套结构.</li><li>实体与属性之间的关系只能是 1:N 的</li><li>不同实体类型的属性之间应无直接关系</li></ol></li></ol><h5>3.4.2 设计全局 ER 模型</h5><ol><li><p>确定公共实体类型
一般把同名实体类型作为公共实体类型的一类候选,把具有相同键的实体类型作为公共实体类型的另一类候选.</p></li><li><p>合并局部 ER 模型
合并原则: 首先进行两两合并; 先合并那些现实世界中有联系的局部结构;合并从公共实体类型开始,最后加入独立的局部结构.
进行二元合并是为了减少合并工作的复杂性.后两项则是为了使合并结果的规模尽可能小.</p></li><li><p>消除冲突</p><ul><li>属性冲突</li><li>结构冲突</li><li>命名冲突</li></ul></li></ol><h5>3.4.3 全局 ER 模型的优化</h5><p>一个好的全局 ER 模型,除能准确,全面地反映用户功能需求外,还应满足下列条件(优化目标):</p><ol><li>实体类型的个数尽可能少</li><li>实体类型所含属性个数尽可能少</li><li>实体类型间联系无冗余</li></ol><p>优化规则:</p><ol><li>合并实体类型
可以把 1:1 联系的两个实体类型合并</li><li>消除冗余属性</li><li>消除冗余联系</li></ol><h3>4. ER 模型到关系模型的转换</h3><h4>4.1 ER 图转换成关系模式集的算法</h4><ol><li><p>实体类型的转换</p><pre><code>实体 | 关系模式
</code></pre><p>:---:|:------:
实体 | 关系模式
实体属性 | 关系模式属性
实体标识符 | 关系模式的键</p></li><li><p>联系类型的转换</p><ol><li><p>二元联系的转换</p><ol><li>1:1 在任意一个关系模式中加入另一个关系模式的键作为外键</li><li>1:N 在N端实体转换成的关系模式中加入1端关系模式的键作为外键</li><li>N:M 将联系类型转换为关系模式,将两段的键作为外键加入到该关系模式,
并将联系类型的属性加入到该模式中,而键为两段实体键的组合</li></ol></li><li><p>一元联系的转换
和二元转换类似</p></li><li><p>三元联系类型的转换</p><ol><li>1:1:1 在任意一个关系模式中加入另外两个的键作为外键,加入联系类型的属性</li><li>1:1:N 同上,将键加入到 N 端实体转换成的关系模型中</li><li>1:M:N 将联系类型转换为关系模型,将 N 端和 M 端的键作为外键和联系类型的
属性加入到该关系模型中, 键为 N 端和 M 端实体键组合</li><li>M:N:P 同上,将三端的键(作为外键)和联系属性加入到该关系模型,
键为三端实体键的组合</li></ol></li></ol></li></ol><h4>4.2 采用 ER 模型的逻辑设计步骤</h4><ol><li><p>导出初始关系模式集
即把概念设计的结果(全局 ER 模型)转换为初始关系模式集</p></li><li><p>规范化处理
规范化的目的是减少乃至消除关系模式中存在的各种异常,改善完整性,一致性和存储效率</p></li><li><p>模式评价
主要包括功能和性能两方面</p></li><li><p>模式修正</p></li><li><p>设计子模式(外部模式
)</p></li></ol><h3>5.增强的 ER 模型</h3><p>为了更准确的模拟现实世界,需要扩展基本 ER 模型的概念,从而产生了增强的 ER 模型(Enhanced-ER model, 简称 EER)</p><h4>5.1 弱实体与强实体</h4><p>若实体
: 一个实体的存在必须依赖于其他实体</p><blockquote><p>若实体参与联系时是完全参与,强实体与弱实体的联系只能是 1:N或N:M</p></blockquote><p>强实体
: 可不必依赖于其他实体</p><h4>5.2 子类实体与超类实体</h4><p>单较低层上实体类型表到了与之联系的较高层上的实体类型的特殊情况时,就称较高层上实体类型为<strong>超类型(Supertype)</strong>,较低层上实体类型为子<strong>类型(Subtype)</strong></p><p>在数据库设计中,子类到超类的抽象化过程称为<strong>概化</strong>,则是自底向上的概念<strong>综合(Synthesis)</strong>;从超类具化到之类的过程称为<strong>特化</strong>,则是自顶向下的概念<strong>发挥(Refinement)</strong>.</p><p>之类与超类有两个特点:</p><ol><li>之类与超类之间具有继承性特点</li><li>这种继承性是通过之类实体和超类实体具有相同的实体标识符实现的</li></ol><p>此外,有两种约束适用于特化过程.</p><p>不相交约束(Disjointness Constraint)
: 约束之类特化是是否相交,分为不相交和重叠两种情况</p><p>不相交(Disjoint)
: 约束规定了在特化过程中,之类必须是不想交的.</p><p>重叠(Overlap)
: 在特化过程中,子类可以相交</p><p>完备性约束(Complete Constraint):
: 分类整体特化和部分特化</p><p>整体特化(Total Specialization)
: 约束指定超类中的每个实体必须是特化中的某个子类的一个成员</p><p>部分特化(Partial Specialization)
: 超类中的实体可以不属于任何一个子类</p><p>在 ER 图中,所有的子类和超类组成了<strong>层次(Hierarchy)</strong>或 <strong>格(Lattice)</strong>的结构</p><h3>6. ER模型的基本表示</h3><table><thead><tr><th align="center">定义</th><th align="center">表示</th></tr></thead><tbody><tr><td align="center">实体</td><td align="center">矩形</td></tr><tr><td align="center">联系</td><td align="center">菱形</td></tr><tr><td align="center">属性</td><td align="center">椭圆</td></tr><tr><td align="center">多值属性</td><td align="center">双线椭圆</td></tr><tr><td align="center">派生属性</td><td align="center">虚线椭圆</td></tr><tr><td align="center">实体标识符</td><td align="center">下划线</td></tr><tr><td align="center">实体与属性</td><td align="center">直线连接</td></tr><tr><td align="center">联系与属性</td><td align="center">直线连接</td></tr><tr><td align="center">联系的基数约束</td><td align="center">在连线上以(m,n)的形式表面</td></tr><tr><td align="center">联系的完全参与</td><td align="center">用双线连接</td></tr><tr><td align="center">联系的类型</td><td align="center">在直线两端指明(1:1,1:N,N:M)</td></tr><tr><td align="center">弱实体</td><td align="center">双线矩形框</td></tr><tr><td align="center">不相交</td><td align="center">小圆圈里为 <strong>d</strong></td></tr><tr><td align="center">重叠</td><td align="center">小圆圈里为 <strong>o</strong></td></tr><tr><td align="center">整体特化</td><td align="center">超类实体与圆圈之间用<strong>双线条</strong>连接</td></tr><tr><td align="center">部分特化</td><td align="center">超类实体与圆圈之间用<strong>单线条</strong>连接</td></tr></tbody></table><hr/><h2>Appendix.B 关系模型</h2><h3>1. 关系模型的基本术语</h3><p>关系模型(Relation Model)
: 用二维表格表示实体集,用关键码表示实体之间联系的数据模型称为关系模型.</p><p>在关系模型中,字段称为属性,字段值称为属性值,记录类型称为关系模式,记录称为
<strong>元组(Tuple)</strong>,元组的集合称为<strong>关系(Relation)</strong> 或 <strong>实例(Instance)</strong>.</p><p>在关系中属性的个数称为<strong>元数(Arity)</strong>, 元素个数称为 <strong>基数(Cardinality)</strong></p><p><strong>关键码(Key,简称键)</strong>由一个或多个属性组成,一般有以下几种:</p><p>超键(Super Key)
: 在关系中能唯一标识元组的属性集称为关系模式的超键</p><p>候选键(Candidate Key)
: 不含有多余属性的超键称为候选键</p><p>主键(Primary Key)
: 用户选作元组标识的候选键称为主键</p><p>外键(Foreign Key)
: 如果模式R中,属性K是其他模式的主键,那么K在模式R中称为外键</p><p>关系中每一个属性都有一个取值范围,称为属性的<strong>值域(Domain)</strong>.属性A的取值范围用 DOM(A) 表示.每一个属性对应一个值域,不同的属性可对应于同一值域.</p><h3>2. 关系的定义和性质</h3><p>关系是一个属性数目相同的元组的集合.</p><p>如果一个关系的元组数目是无限的,则称为<strong>无限关系</strong>,否则称为<strong>有限关系</strong>.由于计算机存储系统限制,只限于研究有限关系.</p><p>在关系模型中,对关系有下列规范性限制:</p><ol><li>关系中每一个属性值都是不可分解的</li><li>关系中不允许出现重复元组</li><li>由于关系是一个集合,因此不考虑元组间的顺序,即没有行序</li><li>元组中的属性在理论上也是无序的,但使用时按习惯考虑列的顺序</li></ol><h3>3. 三类完整性规则</h3><ol><li><p>实体完整性规则(Entity Integrity Rule)
这条规则要求关系中元组在组成主键的属性上不能有空值.</p></li><li><p>参照完整性规则(Reference Integrity Rule)
即不允许引用不存在的实体.
这点规则有以下变通:</p><ol><li>外键和相应的主键可以不同名,只要定义在相同的值域上即可</li><li>外键可以是引用同一组关系模式, 此时表示了同一个关系中不同元组之间的联系</li><li>外键值是否允许空,应视具体情况而定</li></ol></li><li><p>用户定义的完整性规则</p></li></ol><h2>Appendix.X 额外的笔记</h2><h3>名词定义</h3><p>完全非平凡函数依赖
: 仅当其右边集合的属性都不在左边的集合中时成立</p><p>完全还原模型
: 支持四种备份模式, 1.完全备份, 2.差异备份, 3.事务日志备份, 4.文件组备份</p><p>锁的类型
: 互斥锁,共享锁</p><p>分类
: 分类的目的是学会一个分类函数或分类魔心,该模型能把数据库中的数据项映射到给定
类别中的某一个.</p><p>聚类
: 聚类是把一组个体按照相似性归成若干类别,目的是使属于同一类别的个体之间距离尽
可能小,而不同类别上个体间距离尽可能大.</p><p>数据库恢复顺序
: 首先恢复完全备份,其次恢复差异备份,然后恢复日志备份</p><p>功能需求
: 是详细描述总体结构及功能,系统覆盖的功能范,各功能子系统的划分,功能描述及
子系统之间的关系等</p><p>信息需求/数据需求
: 是完整描述系统所涉及的信息范围, 数据的属性特征,数据之间的关系和约束.</p><p>性能需求
: 描述对系统的性能要求,包括响应时间,存储容量,系统适应性,数据库安全性,
一致性和可靠性.</p><p>元数据
: 是描述数据属性的信息,用来支持如指示存储位置,历史数据,资源查找,文件记录等功能.
元数据算是一种电子式目录,为了达到编制目录的目的,必须描述并收藏数据的内容
或特色,进而达到协助数据检索的目的.</p><p>需求分析
: 是指对即将要开发的系统要做什么以及完成什么功能的全面描述,它关注的是这个系统     必须要做什么.</p><p><strong>日常维护的相关工作</strong></p><ol><li>数据库的备份和恢复</li><li>完整性维护</li><li>安全性维护</li><li>存储空间管理</li><li>冰法控制及死锁处理</li></ol><p>可串行化调度
: 对n个事务组成的事务集 $TS=<!-- -->{<!-- -->\quad T_1,T_2,\cdots, T_k,\cdots,T_n\quad<!-- -->}<!-- -->$,
如果并发调度 S 等价于某一在 TS 上的串行调度,那么 S 称为可串行化调度,
否则 S 是不可串行化调度.</p><p>冲突串行化
: 如果定义早事务集 TS 上的并发调度 S 冲突等价于事务集 TS 上的某个串行调度 S&#x27;,
则称 S 是冲突可串行的.冲突可串行的并发调度的执行结果与串行调度一致,是正确的,
同时又具有较高的执行效率.</p><p>触发器
: 通常用于保证业务规则和数据完整性, 其主要优点是用户可以用编程的方法来实现复杂的
处理逻辑和业务规则,增强了数据完整性约束的功能.</p><p>技术可行性
: 是根据用户提出的系统功能,性能及实现系统的各项约束条件,对系统软件,系统硬件,技术
方案作出评估和选择建议,它属于规划与分析阶段的可行性分析.</p><p>数据库应用系统的需求
: 数据需求分析, 数据处理需求分析, 业务需求分析以及在性能, 存储, 安全, 备份和恢复
等方面的要求. 数据操作相应时间, 系统吞吐量, 最大并发用户数都是性能需求分析的
重要指标.</p><p>数据库概念设计阶段的工作目标</p><ol><li>定义和描述应用领域设计的数据范围</li><li>获取应用领域或问题域的信息模型</li><li>描述清楚数据的属性特征</li><li>描述清楚数据之间的关系</li><li>定义和描述数据的约束</li><li>说明数据的安全性要求</li><li>支持用户的各种数据处理需求</li><li>保证信息模型方便地转换成数据库的逻辑结构(数据库模式),同时也便于用户理解.</li></ol><p>数据仓库的定义
: 是一个面向主题的,集成的,非易失的,且随时间变化的数据集合,用来支持管理人员的决策</p><p>数据仓库的特性
: 主题与面向主题,集成,不可更新,随时间变化.</p><p>聚集索引和非聚集索引
: 对数据文件和它的一个特定的索引文件,如果数据文件中数据记录的排列顺序与索引文件中
索引项的排列顺序一致,或者说,索引文件按其查找码指定的顺序与数据文件中数据记录
顺序一致,则该索引文件称为聚集索引,否则成为非聚集索引.</p><p>稠密索引和稀疏索引
: 如果数据文件的每个查找码值在索引文件中都对应一个所以记录,则该索引称为稠密索引.
如果只是一部分查找码对应一个索引记录,则该索引码称为稀疏索引.</p><p>主索引和辅索引
: 在数据文件包含的属性集上建立的索引称为主索引.在数据文件的非主属性上建立的索引
称为辅索引.</p><p>软件总体设计的依据包括 需求分析阶段得到的数据流图, 事务描述和业务规则等需求分析结果.
总体设计得到的系统总体结构和分层模块结构可以用模块结构图表示,模块结构图主要关心模块
的外部特性,即上下级模块以及同级模块间的数据传递和电泳关系,与内部处理流程无关.</p><p>数据模型
: 数据模型是数据库系统的形式框架,是用来描述数据的一组概念和定义.它是包括描述数据,数据
联系,数据操作,数据语义以及数据一致性的概念工具,是数据库系统的核心和基础.按照数据
模型在数据建模和数据管理中的不同作用,可以将其分为概念数据模型,数据结构模型和物理数
据模型.概念数据模型简称概念模型,是按用户的观点对数据和信息进行建模,是现实世界到
信息世界的第一层抽象.数据结构模型也称为表示型或实现型的数据模型,是机器世界中与具体
DBMS 相关的数据模型.物理数据模型属于底层数据模型,通过诸如记录格式,记录顺序和存取路
径等表示信息,描述数据在数据库系统中的实际存储方式/概念模式是对数据库中全体数据的
逻辑结构和特征的描述,是所有用户的公共数据视图,一个数据库只有一个模式.</p><p>数据库应用系统包括概念设计,逻辑设计,物理设计三个步骤.每个步骤按照数据组织与存储,数据
访问与处理,应用设计等几个方面进行.在概念设计阶段,采用自下而上的 E-R 设计.
将关系模式转换为具体 DBMS 平台支持的关系表是数据库物理设计阶段的工作.设计视图和关系
模式的完整性约束是数据逻辑设计阶段的工作.</p><p>OLTP 中的数据一般按面向应用的方式组织,数据仓库系统中的数据一般按面向分析主题的方式组织.</p><h4>日志文件的作用</h4><ol><li>用于事务故障恢复和系统故障恢复</li><li>动态转储中必须建立日志文件</li><li>静态转储中也可以建立日志文件</li></ol><p>为保证数据库是可恢复的,必须遵循两条规则</p><ol><li>登记的次序严格按并行事务执行的时间次序</li><li>必须先写入日志文件,后写入数据库.</li></ol><h4>人机界面设计原则</h4><ol><li>用户应当感觉系统的运行始终在自己的控制之下,保持用户与人机界面的双向交流</li><li>当系统发生错误或程序运行时间较长时,用户界面应该提供有意义的反馈信息,并有上下文感知的
帮助系统</li><li>用户界面能容忍用户在操作过程中发生的各种操作错误,并能方便的从错误中恢复,保证系统不受
用户错误操作的影响</li><li>界面遵循一定的标准和常规</li><li>界面应采取灵活多样的数据输入方式,尽量减少用户的输入负担.</li></ol><h4>性能需求分析</h4><ol><li>数据操作响应时间,或数据访问响应时间
指用户向数据库系统提交数据操作请求到操作返回用户的时间.</li><li>系统吞吐量
系统在单位时间内可以完成的数据库事务或数据查询的数量.
吞吐量可以表示为 每秒事务数(TPS).</li><li>允许并发访问的最大用户数
在保证单个用户查询响应时间的前提下,系统最多允许多少用户同时访问数据库.</li><li>TPS 代价值
用于衡量系统性价比的指标.</li></ol><h4>视图的作用</h4><ol><li>简化数据查询语句</li><li>使用户能从多角度看待同一数据</li><li>提高数据的安全性</li><li>提供了一定程度的逻辑独立性</li></ol><h4>结构化分析及建模方法的主要优点</h4><ol><li>不过早陷入具体的细节</li><li>从整体或宏观入手分析问题</li><li>通过图形化的模型对象直观的表示系统要做什么,完成什么功能</li><li>图形化建模方法方便系统分析员理解和描述系统</li><li>模型对象不涉及太多技术术语,便于用户理解模型</li></ol><h4>UML</h4><p>每一种 UML 的视图都是由一个或多个图组成的, UML 提供了9种不同的图,分为两类.</p><ol><li>静态图
用例图, 类图, 对象图, 组件图, 部署图</li><li>动态图
顺序图, 交互图, 状态图, 和 活动图</li></ol><p>可以根据不同的视图应用进行分类:</p><ol><li>用例视图: 用例图</li><li>结构视图: 类图, 对象图</li><li>行为视图: 顺序图, 交互图, 状态图, 活动图</li><li>实现视图: 组件图</li><li>环境视图: 部署图</li></ol><h4>分布式数据库</h4><p>目的是: 本地自治, 非集中式管理,高可用性,位置独立性,分布式查询处理,分布式事务管理等.</p><ol><li><p>分布式数据库系统概念
是物理上分散,逻辑上统一的数据库系统.</p></li><li><p>分布式数据的概念
分布式数据库则是分布式数据库系统中个场地上数据库的逻辑合.</p></li><li><p>分布式数据库的结构</p><ul><li>共享内存结构</li><li>共享磁盘结构</li><li>无共享结构
最好的并行结构</li><li>次结构
以上体系结构的结合.</li></ul></li></ol><h4>分布式数据库的分布策略</h4><p>数据分片
: 对某一个关系进行分片是将关系划分为多个片段, 这些片段中包含足够的信息可以使关系重构.</p><p>数据分片有四种基本方法:</p><ol><li>水平分片
在关系中从行的角度(元组)依据一定条件划分为不同的片段,关系中的每一行必须至少属于
一个片段,以便在需要时可以重构关系</li><li>垂直分片
在关系中从列的角度(属性)依据一定的条件分为不同的片段,各片段中应该包含关系的主码
属性,一边通过连接方法恢复关系.</li><li>导出分片
是导出水平分片,分片的依据不是本关系的条件,而是其他关系属性的条件.</li><li>混合分片
以上三种方法的混合</li></ol><h4>范式的简述</h4><ul><li>第一范式
指关系必须满足每一个属性值都是不可分解的数据项</li><li>第二范式
在第一范式的基础上,使关系中的每一个属性必须只依赖主码(非主属性完全依赖于候选键)</li><li>第三范式
在第二范式的基础上,每一个非主属性必须只依赖于主码
(非主属性都不传递依赖于候选键)</li></ul><p>一般关系模式规范化工作仅做到 3NF 就可以把关系中不合理的属性基本消除.</p><h3>关于性能/优化</h3><ul><li>将表的数据和索引放置在同一磁盘上不利于提高系统查询的效率</li><li>物理设计的目标是得到存储空间占用少,数据访问效率高和维护代价低的数据库物理模式.
设计一个好的索引和索引字段,可以提高数据查询的速度和效率.</li><li>尽可能先执行查询条件,把表连接放到最后执行</li><li>可以使用 FIFS 来避免活锁的产生</li><li>使用内连接替代左右连接</li></ul><h4>查询优化</h4><ol><li>合理使用索引</li><li>避免或简化排序</li><li>消除对大型表进行数据的顺序存取</li><li>避免相关子查询</li><li>避免困难的正则表达式</li><li>使用临时表加速查询</li><li>用排序来取代非顺序磁盘存取</li><li>不充分的连接条件(避免左右连接)</li><li>使用存储过程</li><li>不要随意使用游标</li><li>使用事务处理</li></ol><h3>分类/方法</h3><h4>SQL Server 2000 数据库备份方式</h4><ol><li>先创建备份设备,然后将数据库备份到备份设备上(这种设备称为永久备份设备)</li><li>直接将数据库备份到物理文件上(这种设备称为临时备份设备)</li></ol><p>在执行备份过程中, 可以同时向多个备份设备写备份内容,也称为并行备份.</p><h4>死锁的预防方法</h4><ol><li>一次加锁
要求每个事务在开始执行时必须将需要访问的数据项全部枷锁,否则不允许执行下去,
也就是要求事务必须能一次性的获得对需要访问的全部数据项的访问权.</li><li>顺序加锁
该方法对数据库中事务访问的所有数据项规定一个加锁顺序,每个事务在执行过程中
必须按此顺序对所需数据项加锁.</li></ol><h4>数据库管理员执行的工作</h4><ol><li>数据库的转储和恢复</li><li>数据库的安全和完整性控制</li><li>数据库的性能监控和分析</li><li>数据库的重组和重构</li></ol><h4>系统故障/软故障 的处理方法</h4><p>对于未完成的事务,可能已经写入数据库的内容,回滚所有未完成的事务写入的结果,以保证
数据库中数据的一致性.
对于已完成的事务可能部分或全部留在缓冲区的结果,需要重做所有已提交的事务,以将数据
库恢复到一致状态
即,撤销(Undo)所有未提交的事务,重做(Redo)所有已提交的事务.</p><h4>数据仓库中数据的维护策略</h4><ul><li>实时维护</li><li>延时维护
查询时触发维护,减少了对数据源的更新时间,但视图查询时间较长.</li><li>快照维护
定期对数据库进行维护,维护操作的触发条件是时间.</li></ul><h4>数据库物理设计步骤</h4><ol><li>数据库逻辑模式调整</li><li>文件组织与存取设计</li><li>数据分布设计</li><li>安全模式设计</li><li>确定系统配置</li><li>物理模式评估</li></ol><h4>DBAS 总体设计</h4><ol><li>确定 DBAS 体系结构</li><li>系统硬件平台和操作系统,数据库管理系统等系统软件的选型和配置</li><li>应用软件结构设计</li><li>对需求分析阶段识别出的业务规则进行初步设计,细化业务规则流程,分析所处理的业务数据
和处理方式,明确采用的关键技术和算法等.</li><li>对系统采用的关键技术进行方案选型和初步设计.</li></ol><h4>RAID 分级</h4><table><thead><tr><th>RAID等级</th><th>n</th><th>最小容错硬盘数</th><th>可用容量</th><th>性能</th><th>安全性</th><th>目的</th><th>应用产业</th></tr></thead><tbody><tr><td>JBOD</td><td>≧1</td><td>0</td><td>n</td><td>不变</td><td>无(同RAID 0)</td><td>追求最大容量</td><td></td></tr><tr><td>0</td><td>≧2</td><td>0</td><td>n</td><td>最高</td><td>一个硬盘异常，全部硬盘即跟着异常</td><td>追求最大容量、速度</td><td>3D产业实时渲染、视频剪接高速缓存用途</td></tr><tr><td>1</td><td>≧2</td><td>总数的一半</td><td>总容量的一半</td><td>稍有提升</td><td>最高</td><td>追求最大安全性</td><td>个人、企业备份</td></tr><tr><td>5</td><td>≧3</td><td>1</td><td>n-1</td><td>高</td><td>高</td><td>追求最大容量、最小预算</td><td>个人、企业备份</td></tr><tr><td>6</td><td>≧4</td><td>2</td><td>n-2</td><td>比RAID 5稍慢</td><td>安全性较RAID 5高</td><td>同RAID 5，但较安全</td><td>个人、企业备份</td></tr><tr><td>10</td><td>≧4</td><td>总数的一半</td><td>总容量的一半</td><td>高</td><td>安全性最高</td><td>综合RAID 0/1优点，理论速度较快</td><td>大型数据库、服务器</td></tr></tbody></table>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[个人作品展示页面]]></title>
            <link>https://wener.me/story/personal-project-page</link>
            <guid>personal-project-page</guid>
            <pubDate>Fri, 23 Aug 2013 00:00:00 GMT</pubDate>
            <description><![CDATA[个人作品展示截图]]></description>
            <content:encoded><![CDATA[<p><img src="https://git.oschina.net/wenerme/wener/raw/master/screenshot/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E7%BD%91%E7%AB%99.png" alt="个人作品展示截图" title="个人作品展示"/></p><p>一个简简单单干干净净的作品展示页面</p><h2>特性</h2><ul><li>数据均使用yaml编写,易于修改添加</li><li>数据驱动,修改简单</li><li>个人比较喜欢这样的界面,淡雅</li></ul><p>还有什么要说的呢? 恩~以后如果有了新的作品应该都会尽量更新在哪里吧.</p><p>;-)</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[俄罗斯方块]]></title>
            <link>https://wener.me/story/gtetris</link>
            <guid>gtetris</guid>
            <pubDate>Mon, 12 Aug 2013 00:00:00 GMT</pubDate>
            <description><![CDATA[俄罗斯方块/GTetris]]></description>
            <content:encoded><![CDATA[<h1>俄罗斯方块/GTetris</h1><p>简单的俄罗斯方块, java swing 实现</p><ul><li><a href="https://github.com/WenerLove/GTetris">项目地址</a></li><li><a href="http://resources.wener.me/java/GTetris.jar">程序下载</a></li><li><a href="http://resources.wener.me/java/GTetris.jnlp">运行程序</a></li><li><a href="https://github.com/WenerLove/GTetris/archive/master.zip">源代码打包下载</a></li></ul><h2>截图/Screenshot</h2><p><img src="https://raw.github.com/WenerLove/GTetris/master/screenshot-main.png" alt="GTetris screenschot" title="GTetris"/></p><p><img src="https://raw.github.com/WenerLove/GTetris/master/screenshot.png" alt="GTetris screenschot" title="GTetris"/></p><h2>游戏特色/Features</h2><ul><li>可操控,当前最多可三个玩家同时操作</li><li>可保存</li></ul><h2>按键/Shortcuts</h2><p>Esc: 暂停</p><p>1: 保存</p><p>2: 加载</p><p>4: 加入玩家</p><p>第一个玩家
w,a,s,d</p><p>第二个玩家
i,j,k,l</p><p>第三个玩家
上下左右</p><h2>Thanks</h2><p>字体 <a href="http://www.dafont.com/christian-munk.d3941?fpp=50&amp;text=Wener">Slice</a></p><p>字体 <a href="http://www.dafont.com/font-comment.php?file=visitor&amp;fpp=50&amp;text=Wener">Visitor</a></p><p><a href="http://projectlombok.org">lombok</a></p><p><a href="http://commons.apache.org/proper/commons-io/">commons-io</a></p><h2>TODO</h2><ul><li>添加声音</li><li>实现播放功能</li></ul><h2>作者/Author</h2><p>作者: <a href="http://wener.me">wener</a></p><p>微博: <a href="http://weibo.com/u/2705020605">@小小文小小爱</a></p><p>博客: <a href="http://blog.wener.me">http://blog.wener.me</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[贪吃蛇-控制台版]]></title>
            <link>https://wener.me/story/greedy_snake</link>
            <guid>greedy_snake</guid>
            <pubDate>Tue, 14 May 2013 00:00:00 GMT</pubDate>
            <description><![CDATA[贪吃蛇 v1.0]]></description>
            <content:encoded><![CDATA[<h1>贪吃蛇 v1.0</h1><h2>作者:</h2><p>Author: <em>Wener</em></p><p>E-mail: <em>wenermail(at)gmail.com</em></p><p>Site: <a href="http://blog.wener.me">Blog.wener.me</a></p><p><img src="https://raw.github.com/WenerLove/greedy_snake/master/screenshot.png" alt="贪吃蛇" title="贪吃蛇 v1.0"/></p><h2>描述:</h2><ul><li>一个windows 在控制台下的小游戏</li></ul><h2>按键:</h2><ul><li>上-下-左-右 控制方向/菜单选择</li><li><kbd>ESC</kbd>       退出游戏</li><li><kbd>R</kbd>         重新开始</li><li><kbd>S</kbd>         游戏保存</li><li><kbd>L</kbd>         游戏读取</li><li><kbd>SPACE</kbd>     暂停</li><li><kbd>M</kbd>         声音开关切换</li></ul><h2>胜利条件:</h2><ul><li>当蛇的长度达到<!-- -->[ 30 ]<!-- -->时即获得游戏胜利</li></ul><h2><em>Tips</em>:</h2><ul><li>按键如果和蛇头的方向一样,可加速</li><li>使用的我自己写的conlib库</li><li>玩的愉快!</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[VB.NET 对对碰游戏]]></title>
            <link>https://wener.me/story/vb-pong-game</link>
            <guid>vb-pong-game</guid>
            <pubDate>Tue, 28 Feb 2012 00:00:00 GMT</pubDate>
            <description><![CDATA[作者:Wener]]></description>
            <content:encoded><![CDATA[<p>作者:<a href="http://blog.wener.me">Wener</a></p><p>版本:1.0</p><p>平台:.Net 4.0</p><p>VS:2010</p><p><a href="http://download.csdn.net/detail/a3160586/4178509">点此</a>下载</p><p><img src="https://git.oschina.net/wenerme/wener/raw/master/screenshot/%E5%AF%B9%E5%AF%B9%E7%A2%B0%E6%B8%B8%E6%88%8F.jpg" alt="对对碰游戏截屏" title="对对碰游戏"/></p><h2>简介</h2><p>这个游戏类似于连连看,点击中间菜单上的开始按钮,开始游戏.
游戏在开始后,球的数量逐渐增加,速度逐渐加快,种类逐渐增多.</p><p>在球的最大量达到100时不再增加.数量在面板上有显示.</p><p>数量:(当前数量)/(最大量)</p><p>在总量达到100时,开始倒计时,120秒.在倒计时内把所有的球都</p><p>消掉,便胜利,否则失败.</p><p>操作说明
: 每个泡泡都可以抛扔,当前选中的球上会有一个黑圈.</p><h3>模式说明</h3><p>重力模式
: 模拟出重力效果,使小球自动往下掉.</p><p>背景可选
: 当打开的时候,能够点击到背景后的内容.</p><p>欢乐模式
: 在该模式下,当两个相同的球碰撞时,自动消失.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[我的第一个VB.Net程序]]></title>
            <link>https://wener.me/story/first-vb-prog</link>
            <guid>first-vb-prog</guid>
            <pubDate>Sat, 25 Feb 2012 00:00:00 GMT</pubDate>
            <description><![CDATA[我学VB.Net的第一个程序。包含了VB基本的使用方法，对我来说具有相当的纪念意义。]]></description>
            <content:encoded><![CDATA[<p>我学VB.Net的第一个程序。包含了VB基本的使用方法，对我来说具有相当的纪念意义。</p><p><img src="https://git.oschina.net/wenerme/wener/raw/master/screenshot/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAVB.Net%E7%A8%8B%E5%BA%8F-%E7%95%8C%E9%9D%A2.png" alt="WinForm" title="WinForm"/></p><p>程序个个组件上有tooltip，鼠标挪上去就知道什么意思了。觉得还是挺有趣的。</p><p><a href="http://download.csdn.net/detail/a3160586/5972007">程序和代码下载</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[概述 getopt.h 的使用]]></title>
            <link>https://wener.me/story/getopt-h-tips</link>
            <guid>getopt-h-tips</guid>
            <pubDate>Thu, 23 Feb 2012 00:00:00 GMT</pubDate>
            <description><![CDATA[概述]]></description>
            <content:encoded><![CDATA[<h2>概述</h2><p>c语言控制台编程时，经常都要接受命令行传递来的选项，而getopt是专门用来解析命令行选项的一套函数。</p><p>简单的说一下getopt，她已经有相当长的历史了，早期是在Unix中使用，现在已经移植到了个个不同的语言（Shell,Java,Php,.NET...），为接受命令行选项提供了很大的便利。同时也指定了一套传递选项和参数的标准。</p><h2>参数传递标准</h2><p>如今的选项有两种模式，短选项和长选项，选项又分为带参数和不带参数。</p><p>比如：</p><p>gcc -V 是短选项，且不带参数</p><p>gcc --version 是长选项，不带参数。与gcc -V相同</p><p>gcc -o exc 是短选项 带参数，与gcc --output exc相同</p><p>而多个短选项可直接连接，例如gcc -so FILE 与 gcc -s -o FILE相同</p><p>短选项的参数可直接紧接在其后,例如gcc -oFILE = gcc -oFILE</p><p>长选项的参数可以以空格分隔或者=分隔，例如 gcc --output FILE = gcc --output=FILE</p><h1>实现</h1> getopt中的内容： <p>具体讲解在实例中。</p><pre><code class="language-c">/* 已定义的变量 */

int opterr
int optopt
int optind
char *optarg

/* 已定义的函数 */
/*  */
int getopt (int argc, char **argv, const char *options)
int getopt_long (int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *indexptr)

int getopt_long_only (int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *indexptr)

/* 数据类型 */
struct option&lt;/code&gt;

实例1.实现短参数

&lt;code lang=&quot;c[lines]&quot;&gt;
#include &lt;ctype .h&gt;
#include &lt;stdio .h&gt;
#include &lt;stdlib .h&gt;
/* getopt时必须包含 unistd头文件 */
#include &lt;unistd .h&gt;

int main (int argc, char **argv)
{
    int index;
    int c;

    opterr = 0;
 /* getopt 用来解析短选项，第一二个参数基本都是相同的 */
 /* 第三个选项传入能接受的参数,&#x27;:&#x27;代表需要值 &#x27;::&#x27;代表值为可选*/
 /* 如果传入了值，其值保存在optarg当中，当其值为必须是，若没有传入值则会报错 缺少值 */
 /* getopt返回匹配的选项&amp;nbsp;例如a/b/c */
 /* 未匹配值时返回？ 解析完时，会返回-1 跳出 */
    while ((c = getopt (argc, argv, &quot;abc:&quot;)) != -1)
        switch (c)
        {
        case &#x27;a&#x27;:
            printf(&quot;检测到-a选项\n&quot;);
            break;
        case &#x27;b&#x27;:
            printf(&quot;检测到-b选项\n&quot;);
            break;
        case &#x27;c&#x27;:
            printf(&quot;检测到-c选项，其参数为：%s\n&quot;, optarg);
            break;
        /* 用来检测其他意外的值 */
        case &#x27;?&#x27;:
         /* optopt为在没有匹配任何选项时，保存的选项值 */
         /* 例如-n，没有与上面匹配，则此时optopt=c */
            if (optopt == &#x27;c&#x27;)
                fprintf (stderr, &quot;选项 -%c 需要一个参数.\n&quot;, optopt);
            else if (isprint (optopt))
                fprintf (stderr, &quot;`-%c&#x27;未定义\n&quot;, optopt);
            else
                fprintf (stderr,
                         &quot; `\\x%x&#x27; 未定义\n&quot;,
                         optopt);
            return 1;
        default:
            abort ();
        }
 /*
 最后检测命令行给的选项是否已经解析完
  optind是当前解析到选项的索引
  判断依据是如果解析的个数小于argc，那么就是没有解析完
 */
    for (index = optind; index &lt; argc; index++)
        printf (&quot;未定义的参数： %s\n&quot;, argv[index]);
    return 0;
}
</code></pre><p>实例2.实现长选项</p><pre><code class="language-c">#include &lt;stdio .h&gt;
#include &lt;stdlib .h&gt;
/* 使用getopt_long时不需要unistd*/
#include &lt;getopt .h&gt;

/* 用来作为一个标志的值. */
static int verbose_flag;

int
main (argc, argv)
int argc;
char **argv;
{
    int c;

    while (1)
    {
     /*
 结构说明
  struct option {
 const char *name; //匹配的长选项名
 int  has_arg; //指定参数选项no_argument required_argument optional_argument
  &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 无值 值必须 值可选
 int *flag; //标志位,数据类型为 int*
 int val; //值，标志位不为0时，如果该选项指定，那么flag=val 此时val不可作为case值
 //否则val可以作为短选项 也就相当于case
 };
 */
        static struct option long_options[] =
        {
            /* 如果指定了-verbose 那么verbose_flag = 1*/
            {&quot;verbose&quot;, no_argument,       &amp;verbose_flag, 1},
            /* 如果指定了-brief 那么verbose_flag = 0*/
            {&quot;brief&quot;,   no_argument,       &amp;verbose_flag, 0},
            /* --add = -a 不带参数*/
            {&quot;add&quot;,     no_argument,       0, &#x27;a&#x27;},
            {&quot;append&quot;,  no_argument,       0, &#x27;b&#x27;},
            /* --delete=XX = -dXX 带参数*/
            {&quot;delete&quot;,  required_argument, 0, &#x27;d&#x27;},
            {&quot;create&quot;,  required_argument, 0, &#x27;c&#x27;},
            {&quot;file&quot;,    required_argument, 0, &#x27;f&#x27;},
            /* 很明显5438不可能用一个ANSCI表示出来，那么这个可以直接用case就可以*/
            {&quot;a_very_long_arg&quot;,    no_argument, 0, 5438},
            /* 最后为空值，来标识结束 */
            {0, 0, 0, 0}
        };
        /* 因为没有了optind，那么就要用一个值来存储当前索引 */
        int option_index = 0;

 /* 前三个参数与getopt相同，第四个为option，第五个为存索引int的指针*/
        c = getopt_long (argc, argv, &quot;abc:d:f:&quot;,
                         long_options, &amp;option_index);

        /* 当解析完返回-1 跳出循环 */
        if (c == -1)
            break;

        switch (c)
        {
        case 0:
            /* 当 flag不为0时，遇到那些选项 getopt_long返回0*/
            if (long_options[option_index].flag != 0)
                break;
            printf (&quot;选项 %s&quot;, long_options[option_index].name);
            if (optarg)
                printf (&quot; 值 %s&quot;, optarg);
            printf (&quot;\n&quot;);
            break;

        case &#x27;a&#x27;:
            puts (&quot;选项 -a\n&quot;);
            break;

        case &#x27;b&#x27;:
            puts (&quot;选项 -b\n&quot;);
            break;
        //长选项
        case 5438:
            puts (&quot;选项 --a_very_long_arg\n&quot;);
            break;
            break;
        case &#x27;c&#x27;:
            printf (&quot;选项 -c 值为 `%s&#x27;\n&quot;, optarg);
            break;

        case &#x27;d&#x27;:
            printf (&quot;选项 -d 值为 `%s&#x27;\n&quot;, optarg);
            break;

        case &#x27;f&#x27;:
            printf (&quot;选项 -f 值为 `%s&#x27;\n&quot;, optarg);
            break;

        case &#x27;?&#x27;:
            /* getopt_long 会自动输出错误，不像getopt需要自己检测 */
            break;

        default:
            abort ();
        }
    }

    /* 检测是否设置了标志位 */
    if (verbose_flag)
        puts (&quot;verbose 标志已被设置&quot;);

    /* 输入未解析完的选项. */
    if (optind &lt; argc)
    {
        printf (&quot;无效选项： &quot;);
        while (optind &lt; argc)
            printf (&quot;%s &quot;, argv[optind++]);
        putchar (&#x27;\n&#x27;);
    }

    exit (0);
}
</code></pre><p>实例3.<strong>getopt_long_only</strong></p><p>这个函数的参数和getopt_long相同，只是接受长参数时，可以只用一个&#x27;-&#x27;来替代&#x27;--&#x27;。当-xx没有检测到xx的长参数时会检测-x短参数。</p><p>同时&#x27;--&#x27;也能够使用,也就是说-xx=--xx</p><h1>结尾</h1> 不得不说，getopt是一个很实用的工具，对于编程能提供很多的便利。gnu也有开源的实现在gnulib和libc中。 <p>参考：</p><p>GNU Libc手册：<a href="http://www.gnu.org/software/libc/manual/html_node/Getopt.html#Getopt"><a href="http://www.gnu.org/software/libc/manual/html_node/Getopt.html#Getopt">http://www.gnu.org/software/libc/manual/html_node/Getopt.html#Getopt</a></a></p><p>Getopt英文维基页面：<a href="http://en.wikipedia.org/wiki/Getopt"><a href="http://en.wikipedia.org/wiki/Getopt">http://en.wikipedia.org/wiki/Getopt</a></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[梦幻西游版个人简介 PPT]]></title>
            <link>https://wener.me/story/fwj-resume</link>
            <guid>fwj-resume</guid>
            <pubDate>Wed, 07 Dec 2011 00:00:00 GMT</pubDate>
            <description><![CDATA[梦幻西游版个人简介-中得一个PPT系统]]></description>
            <content:encoded><![CDATA[<p><img src="https://git.oschina.net/wenerme/wener/raw/master/screenshot/%E6%A2%A6%E5%B9%BB%E8%A5%BF%E6%B8%B8%E7%89%88%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B-%E4%B8%AD%E5%BE%97%E4%B8%80%E4%B8%AAPPT%E7%B3%BB%E7%BB%9F.jpg" alt="梦幻西游版个人简介-中得一个PPT系统"/></p><p><img src="https://git.oschina.net/wenerme/wener/raw/master/screenshot/%E6%A2%A6%E5%B9%BB%E8%A5%BF%E6%B8%B8%E7%89%88%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B-%E6%8C%87%E5%AF%BC.jpg" alt="梦幻西游版个人简介-中得一个PPT系统"/></p><p>下载(zip)：<a href="http://download.csdn.net/detail/a3160586/6706453">梦幻西游版个人简历</a></p><p>老师叫做的作业，一时心血来潮就做了个这个。最后感觉还不错。</p><p>以前还从未做过ppt，做了这个之后，觉得ppt还是蛮强大的。不过就是很繁琐，特别是在自定义动画多了之后，图层对象多了之后，管理起来很麻烦。wps也有些不给力，本来是好好地2012的，不得不又还回了2010，打开这个文件的时候还会很卡。</p><p>ms office还不错，很顺畅，不过这个是用wps做的，没有外部文件的依赖。但是对office 2007好像看不到背景，我在2003上能看到背景。这点很无奈。</p><p>在做自定义动作的时候。还是有些技巧的，比如说一次加入多个文件，选择多个文件添加同样的动作然后群体移动。这个文件本来还可以加入声音的，但是没有去找声音文件在哪里。</p><p>要是喜欢，可任意修改哦。</p><p>下载(zip)：<a href="http://download.csdn.net/detail/a3160586/6706453">梦幻西游版个人简历</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《非遗失》]]></title>
            <link>https://wener.me/story/not-lost</link>
            <guid>not-lost</guid>
            <pubDate>Wed, 16 Nov 2011 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<pre><code>我不是你的什么

只是因为你我遗失了很多

找不回来的是再也无法得到的

留下的 永恒的 遗失的

的你

即便是在梦中也抓不住一缕发丝

你只是走了，只是不再回来
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《我把我的矜持都给了她》：序]]></title>
            <link>https://wener.me/story/here-my-love-prolog</link>
            <guid>here-my-love-prolog</guid>
            <pubDate>Wed, 16 Nov 2011 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<pre><code>生活中，总有那么个她，陪你度过困难，陪你开怀大笑，陪你畅谈理想，陪你走过一段路，陪你唱过一首歌，陪你做过一个梦。梦中有你有她还有梦。也总有那么个她，让你自信，让你快乐，让你伤痛，让你心碎，让你流泪，疲惫，憔悴，心灵没有防备……到最后才发现，只是让你在改变。
生活中，总会有那么多得情爱。她们给的或给不了的，我能做的或做不了的总是太多。像是戴在食指的戒期待爱却不能爱，含羞草般不容染指的美丽。就让我静静地等，静静地看。

    生活中，总会有太多的人，太多的事，太多的悲欢离合。没有永恒，或许连明天也没有，一直都活在今天，但是在想着明天，甚至还念念不忘昨天。当哭泣着说自己孤单，却看不见身边陪伴的人。
    有时候目光太短，看不见整片天空，甚至看不见我，看不见自己。
    梦还是在延续着，只是“有些事你现在不必问，有些人你永远不必等”。
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《我把我的矜持都给了她》：篇外 「风的故事」]]></title>
            <link>https://wener.me/story/here-my-love-wind-story</link>
            <guid>here-my-love-wind-story</guid>
            <pubDate>Wed, 16 Nov 2011 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<pre><code>我喜欢在起风的时候想你，风能把我的思念带到远方。

我喜欢在微风中哭泣，风会悄然的帮我拭去眼泪
我喜欢把爱放在风中，风把爱带给我思念的你。
风从不停留，他警戒自己不能够去眷恋。
风说，如果她喜欢我，那她一定还会来到这里。
你永远在风的心里，或许你未曾听过他的呼声，但他却一直陪伴着你。
因为
你不知道的是，他是真的喜欢你
你不知道的是，他想你却不能告诉你
你不知道的是，他总会在夜里看望你
你不知道的是，他在每个忧伤的雨季里都和你在一起
他不舍得离去
他拨撩着你的发丝，倾视他暮恋的容颜
听那酒窝叙述着的故事
看那眼眸凝视着的风景
感受那纤细指尖轻触的花
但却下起了雨来
他呼啸着过来，他想抱着你，为你抵挡那刺骨的雨。
雨淋湿了你身，却刺痛了他的心
最后
你走了，不曾回望
只是风依然停留
我漫步在雨后的路，那滴雨拨弄着湖面
听着风给我讲述着他的故事
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[js解析lib图片文件列表]]></title>
            <link>https://wener.me/story/bbk-bbimg-js</link>
            <guid>bbk-bbimg-js</guid>
            <pubDate>Thu, 15 Sep 2011 21:51:00 GMT</pubDate>
            <description><![CDATA[原帖链接]]></description>
            <content:encoded><![CDATA[<p>原帖<strong><a href="http://club.eebbk.com/bbkbbs/showtopic/269578/1">链接</a></strong></p><p>代码全部为纯原创，类那些也都是自己写的.
ui写的很差，觉得随便。
需要把打开的文件放在src文件夹下！
请用非ie内核打开，因为需要canvas标签的支持，也没有对ie进行兼容</p><p>在网页中打开BBImg.html就ok了！
必须要求有服务器,也就是链接的形式必须是 <code>http://</code>xxxx,而不是<code>file://</code>.
因为使用个ajax.</p><p>作者：小文儿</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[四个函数和bb编辑器]]></title>
            <link>https://wener.me/story/bbk-libs</link>
            <guid>bbk-libs</guid>
            <pubDate>Sun, 24 Apr 2011 01:34:00 GMT</pubDate>
            <description><![CDATA[Lib图片选择]]></description>
            <content:encoded><![CDATA[<p><img src="https://github.com/wenerme/wener/raw/master/story/%E6%88%91%E9%82%A3%E4%BA%9B%E6%AD%A5%E6%AD%A5%E9%AB%98%E7%9A%84%E6%95%85%E4%BA%8B/%E5%9B%9B%E4%B8%AA%E5%87%BD%E6%95%B0/Lib%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9.gif" alt="Lib图片选择"/>
<img src="https://github.com/wenerme/wener/raw/master/story/%E6%88%91%E9%82%A3%E4%BA%9B%E6%AD%A5%E6%AD%A5%E9%AB%98%E7%9A%84%E6%95%85%E4%BA%8B/%E5%9B%9B%E4%B8%AA%E5%87%BD%E6%95%B0/%E8%8F%9C%E5%8D%95%E5%BC%8F%E9%80%89%E6%8B%A9.jpg" alt="菜单式选择"/>
<img src="https://github.com/wenerme/wener/raw/master/story/%E6%88%91%E9%82%A3%E4%BA%9B%E6%AD%A5%E6%AD%A5%E9%AB%98%E7%9A%84%E6%95%85%E4%BA%8B/%E5%9B%9B%E4%B8%AA%E5%87%BD%E6%95%B0/%E9%A1%B5%E9%9D%A2%E8%B0%83%E6%95%B4-%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91.gif" alt="图片调整函数"/></p><p>原帖<strong><a href="http://club.eebbk.com/bbkbbs/showtopic/257169/1">链接</a></strong></p><pre><code>&#x27;//=========ShowPic_Alpha==========//
&#x27;//=========带Alpha显示图片==========//
&#x27;作者 Wener
&#x27;论坛Id a3160586 (club.eebbk.com   编程区)
&#x27;QQ 514403150

说明:
showpic_alpha( srcPage, srcPic, alPic, DisX, DisY, Wid, Hgt, srcX, srcY, showMODE)
相比showpic函数，只多了一个alPic参数 其他都是一样的
这个是alpha的通道图 由于bb的显示颜色数目有限，不会在电脑上看起来一样平滑的

&#x27;//=========LibSel==========//
&#x27;//=========Lib图片选择函数==========//
&#x27;作者 Wener
&#x27;论坛Id a3160586 (club.eebbk.com   编程区)
&#x27;QQ 514403150

说明：这个函数就是选择Lib中的某一张图片，然后返回图片句柄
这个函数具有比较好的UI，用起来感觉还是比较好的
这个函数要依赖于getLibCount ， getInput 这两个函数
LibSel( Lib_Name$)
这个函数只需要LIB文件名这个参数



&#x27;//=========Selector==========//
&#x27;//=========菜单式选择==========//
&#x27;作者 Wener
&#x27;论坛Id a3160586 (club.eebbk.com   编程区)
&#x27;QQ 514403150

说明：这个函数就像手机的菜单那种样，就是选择的
Selector_Str$这个为一个数组，调用前请为其赋值字符串
Selector_StrCount 是总的选项个数
调用 Selector( MustChoiceOne)
MustChoiceOne参数是是否必须选择一个 1 为是 也就是是说不能退出
MustChoiceOne为0的时候  退出返回1 确认返回选项在Selector_Str中的位置
也就是Selector_Str$( i)
具体请看 eg.Selector.bas

&#x27;//=========PageAdjust==========//
&#x27;//=========页面调整函数==========//
&#x27;作者 Wener
&#x27;论坛Id a3160586 (club.eebbk.com   编程区)
&#x27;QQ 514403150

说明：这个函数就像photoshop的一些功能样
平衡颜色，调整rbg通道，调整明暗，使页面黑白化
可镜像，旋转180°图像等，更多请在使用的时候发现吧
这个函数生成的bin文件较大，300多k，因为有留了大部分空白


额外说明：
除了PageAdjust外，其他三个函数都需要SYS_Fe$ 这个全局变量
这个感觉这个是应该都要有的一个变量，所以就都放在了全局
IF GetEnv!() = Env_SIM Then
    SYS_Fe$ = &quot;.rlb&quot;
Else
    SYS_Fe$ = &quot;.lib&quot;
End IF
也就是判断中载入什么格式的
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[BB急速截图]]></title>
            <link>https://wener.me/story/bbk-quick-screenshot</link>
            <guid>bbk-quick-screenshot</guid>
            <pubDate>Tue, 22 Mar 2011 01:56:00 GMT</pubDate>
            <description><![CDATA[运行截图]]></description>
            <content:encoded><![CDATA[<p><img src="https://github.com/wenerme/wener/raw/master/story/%E6%88%91%E9%82%A3%E4%BA%9B%E6%AD%A5%E6%AD%A5%E9%AB%98%E7%9A%84%E6%95%85%E4%BA%8B/BB%E6%80%A5%E9%80%9F%E6%88%AA%E5%9B%BE/%E6%88%AA%E5%9B%BE.gif" alt="运行截图"/></p><p>原帖<a href="http://club.eebbk.com/bbkbbs/showtopic/255787/1">链接</a></p><pre><code>&#x27;//=========截图类函数v1.0==========//
&#x27;作者 Wener
&#x27;论坛Id a3160586 (club.eebbk.com   编程区)
&#x27;QQ 514403150
&#x27;date: 1:56 AM 2011-3-22
特色：
截图函数极其的快  1.5s &gt; 平均
可保存为lib和bmp
supper可由用户自由选择设置，带有较好的ui
源代码公开，可任意使用到你们自己的作品中

使用请保留原作者信息，谢谢 ^o^
；==========================================
函数说明：
截图类函数，故名思议。
共有三个函数
默认全屏截图
ScreenPrint_ALL( ScrP_p_page, ScrP_p_BMP_FileName$)
ScrP_p_page 截图页面
ScrP_p_BMP_FileName$ 保存为的bmp文件名。若保为lib则参数为 &quot;&quot; 空字符
矩形框截图
ScreenPrint_Rect( ScrP_p_PAGE, ScrP_p_x, ScrP_p_y, ScrP_p_Wid, ScrP_p_Hgt, ScrP_p_BMP_FileName$)
两个参数同上
ScrP_p_x, ScrP_p_y 截图起点
ScrP_p_Wid, ScrP_p_Hgt 截图宽高
用户自定义裁剪截图
ScreenPrint_Supper( ScrP_p_page)
ScrP_p_page 截图页面

；==========================================
详细说明：
此类函数都需要一个文件句柄，可在const中自定义
const ScreenPrint_Use_File_ID = ？？


ScreenPrint_ALL和ScreenPrint_Rect函数要求较低，代码也不是很多，因此若要求不高，则可以仅仅使用这两个函数就可以了

ScreenPrint_Supper要求较高，带ui，共需要4个页面句柄，ui界面是自动判别使用环境的，也就是说自动选择读取lib或者是rlb。
supper函数中包含了大量计算，难以避免的有点点卡，在淡出的时候有点卡。

压缩包中的 PT_res.lib 和 PT_res.rlb 都是测试时使用的 ，与Super_example.bas 有关

源代码中的变量命名有些有点混乱。
有 Scrp_（screenPrint）开头的,有screenPrint_开头的，有screenCapture开头的 三个函数.bas这个文件中已经修正
其实我那样命名也是为了在区别汇编和bb  bb中是scrp 汇编中是 screenPrint.  screenCapture只有两次

在使用的时候请将ScreenPrint.lib一起复制，这个文件只是个空文件，只是为了为lib的存储“占地盘”，存放索引。转换为lib的结果都在这个文件当中。
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[还原的Bda计算器]]></title>
            <link>https://wener.me/story/bbk-bda-calc</link>
            <guid>bbk-bda-calc</guid>
            <pubDate>Fri, 11 Mar 2011 13:44:00 GMT</pubDate>
            <description><![CDATA[黑色主题截图]]></description>
            <content:encoded><![CDATA[<p><img src="https://github.com/wenerme/wener/raw/master/story/%E6%88%91%E9%82%A3%E4%BA%9B%E6%AD%A5%E6%AD%A5%E9%AB%98%E7%9A%84%E6%95%85%E4%BA%8B/%E8%AE%A1%E7%AE%97%E5%99%A8/Cal.gif" alt="黑色主题截图"/>
<img src="https://github.com/wenerme/wener/raw/master/story/%E6%88%91%E9%82%A3%E4%BA%9B%E6%AD%A5%E6%AD%A5%E9%AB%98%E7%9A%84%E6%95%85%E4%BA%8B/%E8%AE%A1%E7%AE%97%E5%99%A8/B_Cal.gif" alt="蓝色主题截图"/></p><p>原帖<a href="http://club.eebbk.com/bbkbbs/showtopic/255060/1">链接</a></p><pre><code>刚开始看到图片的时候会不会觉得是Bda呢？

 &#x27;//////////////////////////
&#x27;////////还原de计算器//////
&#x27;////////作者id:a3160586///
&#x27;////////作者:Wener////////
&#x27;////////=================/
&#x27;////////欢迎访问//////////
&#x27;////////club.eebbk.com////
&#x27;//////////////////////////

图片都是用的和小机上一样的图片
展示的效果也和小机上基本相同，好像只是没有出来error的情况
还是有一点点缺点，就是处理小数的时候不是很有力，有时会出现误差

你可以直接把全部代码复制到自己的代码中进行调用 Cal_Calculator( the)
the为假的时候是黑色主题，为真的时候是蓝色主题
变量的命名都是用Cal_开头的，只有几个公用的函数才没那样处理

declare function str2float!( str2float_p_fstr$) 把字符串转换为浮点数
declare function float2str$( float2str_p_flo!) 把浮点数转换为字符串  这里有时候会产生误差
declare function ShowFloat( ShowFloat_p_hPage, ShowFloat_p_hImg, ShowFloat_p_x, ShowFloat_p_y, ShowFloat_p_Float$) 用图片来显示浮点数的字符串

这几个函数是相互独立的，可以任意调用，但是这个计算器必须依赖这三个函数

谢谢大家参考学习~
有意学习的可以看看下面

原先我在想着写这个的时候，想的是多么的简单~~~当做起来的时候才发现，原来~不只是想的那么简单~
instr，在电脑上，没查找到的时候是返回0的，而在最新的bda上是返回-1
所以 还是用 &lt; 1 或者 &gt; 0 来判断是否查找到要方便些
我不知道小机上的left能用不，所以全部是用mid代替的

s! = 0.0202
print s! * 100000
你猜结果是多少~？


2019.999878
这就是我之所以不能保证精确的原因，在程序中我略加处理过了，但是还是免不了有出错情况的
特别是处理很多小数的时候。。。。
要是出错了也只能按c取消了从来~

在处理键盘按键的时候，觉得我的那个想法是 很不错的，大家可以借鉴借鉴，就是~~~~~~
看代码吧，嘿嘿  保证超越前人，正在做的ime也是用的这样的思路。申请个专利哦

这里对热衷于汇编的人说几句话，其实机器并没有你们想的那么不堪~
我觉得速度对我来说还是很不错的，特别是我在屏幕上乱按的时候，因为太快，导致很多键还没恢复的时候都又按下了，恢复是40ms延时的，可想，其实速度还是够了啊~
汇编作为辅助，是最佳的选择，我就是这样用的，把一些要重复用到的子过程放开，用call来调用的，这样可看性要高一点点~本来过程也不长，没必要用一个函数。

好了就到这里吧

预知更多，请看代码
本人qq：514403150
欢迎讨论交流
^.^
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[囚徒困境]]></title>
            <link>https://wener.me/story/bbk-game-prisoner-dilemma</link>
            <guid>bbk-game-prisoner-dilemma</guid>
            <pubDate>Sat, 05 Mar 2011 21:31:00 GMT</pubDate>
            <description><![CDATA[游戏截图]]></description>
            <content:encoded><![CDATA[<p><img src="https://github.com/wenerme/wener/raw/master/story/%E6%88%91%E9%82%A3%E4%BA%9B%E6%AD%A5%E6%AD%A5%E9%AB%98%E7%9A%84%E6%95%85%E4%BA%8B/%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83/QT.gif" alt="游戏截图" title="运行效果"/></p><p>原帖<strong><a href="http://club.eebbk.com/bbkbbs/showtopic/254672/1">连接</a></strong></p><p>此游戏由著名的心理测试“囚徒困境”启发制作。</p><p>游戏规则极其简单。
初始分数为0分，由玩家与文（电脑）对战</p><p>得分规则：</p><ul><li>双方都合作 各得3分</li><li>双方都背叛 各得1分</li><li>一方合作一方背叛 背叛的5分 合作的0分</li></ul><p>游戏控制：</p><ul><li>点击局次上限设置次数，游戏时可以设置</li><li>点击帮助查看帮助</li><li>点击关于查看关于</li><li>点击开始即开始游戏</li><li>当游戏中时点击开始游戏将会询问是否重新开始游戏</li></ul><p>原本的游戏图片是更好看的（在电脑上），但是为了在机器上看起来能看，就都调暗了。</p><p>作者
: Wener</p><p>论坛Id
: 小文儿</p><p>欢迎访问  club.eebbk.com</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[平生第一个游戏 - 趣味拼图]]></title>
            <link>https://wener.me/story/bbk-first-game</link>
            <guid>bbk-first-game</guid>
            <pubDate>Fri, 04 Feb 2011 02:21:00 GMT</pubDate>
            <description><![CDATA[原帖子链接]]></description>
            <content:encoded><![CDATA[<p>原帖子<a href="http://club.eebbk.com/bbkbbs/showtopic/252670/1">链接</a></p><p><img src="https://github.com/wenerme/wener/raw/master/story/%E6%88%91%E9%82%A3%E4%BA%9B%E6%AD%A5%E6%AD%A5%E9%AB%98%E7%9A%84%E6%95%85%E4%BA%8B/%E8%B6%A3%E5%91%B3%E6%8B%BC%E5%9B%BE/%E8%B6%A3%E5%91%B3%E6%8B%BC%E5%9B%BE.gif" alt="游戏截图" title="运行效果"/></p><p>玩法和手机上的那种拼图相差无几</p><p>不同的是：每次的缺少位置是随机的，不像手机上的那么死板</p><p>可自定义关卡，自己修改游戏脚本，制作特定关卡。
详细的请看我在论坛的发帖</p><p>游戏控制：</p><ul><li>在主菜单时 当没有存档时不会继续游戏</li><li>在主菜单时，退出键是退出</li><li>在游戏中时 退出键（左软件）是返回上一步</li><li>点击缩略图科查看全图</li><li>键盘和屏幕触摸控制移动</li><li>游戏时右下角有个菜单条，点击即展开 有退出和保存选项</li></ul><p>作者
: Wener</p><p>论坛Id
: 小文儿</p><p>欢迎访问  club.eebbk.com</p><h2>如何制作关卡</h2><p>存放图片的文件是 PT_res.lib</p><p><img src="http://upload.eebbk.net/UploadFile/2011-2/2011242274888328.jpg" alt="命名格式"/>
以“_s”结尾的都是缩略图，也就是第 2n张是拼图的图，而 第2n+1张是第2n长的缩略图</p><p>就是这么简单。</p><p>关于一些特殊设置,在函数 specialGate 里面,比如像这样的图</p><p><img src="http://upload.eebbk.net/UploadFile/2011-2/2011242305561677.jpg" alt="特殊设置类型"/></p><p>我需要规定用户缺失的的是哪一块才能玩的正常，所以只需要这样设置：</p><pre><code>if G_User_Gate = 6 then
    specialGate_var = 8
end if
</code></pre><p>也就是说，如果关卡是第六关，也就是上图那一关，那么我想用户缺失的是第8块
注意的是，这个小图片是从0开始的，第8块也就是最右下角的那一块。</p><p>如果我想第3关玩家缺失的是第 4块 那个代码就是</p><pre><code>if G_User_Gate = 3 then
    specialGate_var = 4
end if
</code></pre><p>当然是可以写很多个这样的。</p><p>如果是小男生，其实可以有意的弄点什么示爱的。。。。不说了</p><h2>结尾</h2><p>这个游戏还不是很完美的，储存还不够完美，结构还不够完美，过关的动画没写还有些遗漏的地方。
但是至少能玩的，而且界面还是 pretty good 的。很多地方都是用的缓动，本来图片的移动还是想用缓动的，但是我觉得那是没事找事~~</p><p>要是还有啥需求可以尽量提出，修改就是了</p>]]></content:encoded>
        </item>
    </channel>
</rss>