<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/story/rss.xml" title="Wener Live & Life Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/story/atom.xml" title="Wener Live & Life Blog Atom Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-30404720-1","auto"),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-30404720-1"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-30404720-1",{})</script>
<link rel="search" type="application/opensearchdescription+xml" title="Wener Live & Life" href="/opensearch.xml"><title data-react-helmet="true">数据库原理 for NCRE 4 | Wener Live &amp; Life</title><meta data-react-helmet="true" property="og:title" content="数据库原理 for NCRE 4 | Wener Live &amp; Life"><meta data-react-helmet="true" name="description" content="数据库原理笔记"><meta data-react-helmet="true" property="og:description" content="数据库原理笔记"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="default"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/styles.f53ced8f.css">
<link rel="preload" href="/styles.57f5dddf.js" as="script">
<link rel="preload" href="/runtime~main.7902e8e5.js" as="script">
<link rel="preload" href="/main.f820e005.js" as="script">
<link rel="preload" href="/1.2eb87496.js" as="script">
<link rel="preload" href="/2.77b0d6b5.js" as="script">
<link rel="preload" href="/3.3b0f69d3.js" as="script">
<link rel="preload" href="/ccc49370.097418e0.js" as="script">
<link rel="preload" href="/65eaf7fb.29a51009.js" as="script">
<link rel="preload" href="/e6b7e9c9.9ca64f84.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/wener-logo-head.svg" alt="Wener Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/wener-logo-head.svg" alt="Wener Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Wener</strong></a><a class="navbar__item navbar__link" href="/notes/java/java">笔记</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/story">故事</a><a class="navbar__item navbar__link" href="/notes/howto/network/dns-prevent-spoofing">指南</a><a class="navbar__item navbar__link" href="/notes/tool/network/ip-lookup">工具</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/wenerme/wener" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span></button></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/wener-logo-head.svg" alt="Wener Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/wener-logo-head.svg" alt="Wener Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Wener</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/notes/java/java">笔记</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/story">故事</a></li><li class="menu__list-item"><a href="https://github.com/wenerme/wener" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a class="menu__link" href="/notes/howto/network/dns-prevent-spoofing">指南</a></li><li class="menu__list-item"><a class="menu__link" href="/notes/tool/network/ip-lookup">工具</a></li></ul></div></div></div></nav><div class="main-wrapper blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--2"><div class="sidebar_SWld thin-scrollbar"><h3 class="sidebarItemTitle_Km2m">Recent posts</h3><ul class="sidebarItemList_3UpA"><li class="sidebarItem_2T0D"><a class="sidebarItemLink_v5H9" href="/story/agi-vs-ami-vs-ari">如何选择 Asterisk 接口</a></li><li class="sidebarItem_2T0D"><a class="sidebarItemLink_v5H9" href="/story/openvox-gw-inside">OpenVox VoxStack 网关分析</a></li><li class="sidebarItem_2T0D"><a class="sidebarItemLink_v5H9" href="/story/fix-init-script">记录一次修复 init 脚本的经历</a></li><li class="sidebarItem_2T0D"><a class="sidebarItemLink_v5H9" href="/story/alpinelinux-setup-xfce">AlpineLinux 安装 Xfce 桌面</a></li><li class="sidebarItem_2T0D"><a class="sidebarItemLink_v5H9" href="/story/why-need-graphql">为什么需要 GraphQL</a></li></ul></div></div><main class="col col--8"><article><header><h1 class="margin-bottom--sm blogPostTitle_3-lP">数据库原理 for NCRE 4</h1><div class="margin-vert--md"><time datetime="2013-09-24T00:00:00.000Z" class="blogPostDate_Ta7i">September 24, 2013  · 14 min read</time></div><div class="avatar margin-vert--md"><div class="avatar__intro"></div></div></header><section class="markdown"><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="数据库原理笔记"></a>数据库原理笔记<a class="hash-link" href="#数据库原理笔记" title="Direct link to heading">#</a></h1><blockquote><p>记录自 <strong>全国高等教育制定教材 数据库原理</strong>
和 部分自己的整理</p></blockquote><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="1-数据库系统的基本概念"></a>1. 数据库系统的基本概念<a class="hash-link" href="#1-数据库系统的基本概念" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="12-数据描述"></a>1.2 数据描述<a class="hash-link" href="#12-数据描述" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="121-概念设计中的数据描述"></a>1.2.1 概念设计中的数据描述<a class="hash-link" href="#121-概念设计中的数据描述" title="Direct link to heading">#</a></h4><p>实体(Entity):
: 客观存在,可以相互区别的事物成为实体</p><p>实体集(Entity Set)
: 性质相同的同类实体的集合</p><p>属性(Attribute)
: 实体的特性称为属性</p><p>实体标识符(Indentify)
: 能唯一标识实体的属性或属性集</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="122-逻辑设计中的数据描述"></a>1.2.2 逻辑设计中的数据描述<a class="hash-link" href="#122-逻辑设计中的数据描述" title="Direct link to heading">#</a></h4><p>记录(Record)
: 字段的有序集合</p><p>字段(Field)
: 标记实体属性的命名单位称为字段或数据项</p><p>文件(File)
: 同一类记录的集合</p><p>关键码(Key)
: 能唯一便是文件中某个记录的字段或字段集</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="术语的对应关系"></a>术语的对应关系<a class="hash-link" href="#术语的对应关系" title="Direct link to heading">#</a></h4><table><thead><tr><th>概念设计</th><th>逻辑设计</th></tr></thead><tbody><tr><td>实体</td><td>记录</td></tr><tr><td>属性</td><td>字段</td></tr><tr><td>实体集</td><td>文件</td></tr><tr><td>实体标识符</td><td>关键码</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="124-数据联系的描述"></a>1.2.4 数据联系的描述<a class="hash-link" href="#124-数据联系的描述" title="Direct link to heading">#</a></h4><p>联系 (Relationship)
: 实体之间的相互关系,与一个联系相关的实体个数称为联系的元数</p><p>联系的类型
: 一对一,一对多,多对多 1:1, 1:N, N:M</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="13-数据的抽象级别"></a>1.3 数据的抽象级别<a class="hash-link" href="#13-数据的抽象级别" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="131-数据抽象过程"></a>1.3.1 数据抽象过程<a class="hash-link" href="#131-数据抽象过程" title="Direct link to heading">#</a></h4><p>模型(Model)
: 对现实世界的抽象</p><p>数据模型(Date Model)
: 数据库的结构和语义,对现实世界的数据进行抽象</p><p>: &gt; <strong><a href="http://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener noreferrer">wiki-数据模型</a></strong> 数据模型是定义数据如何输入和与输出的一种模型。
其主要作用是为信息系统提供数据的定义和格式。数据模型是数据库系统的核心和基础，
现有的数据库系统都是基于某种数据模型而建立起来的。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="132-概念模型"></a>1.3.2 概念模型<a class="hash-link" href="#132-概念模型" title="Direct link to heading">#</a></h4><ol><li>表达数据的整体逻辑结构，是系统用户对整个应用项目设计的数据的全面描述</li><li>从用户的观点出发，对数据建模</li><li>独立于硬件和软件</li><li>是数据库设计人员与用户之间进行交流的工具</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="133-逻辑模型"></a>1.3.3 逻辑模型<a class="hash-link" href="#133-逻辑模型" title="Direct link to heading">#</a></h4><ol><li>表达了DB的整体逻辑结构,设计人员对整个应用项目数据库的全面描述</li><li>从数据库的实现观点出发,对数据建模</li><li>独立于硬件,依赖于软件</li><li>数据库设计人员与应用程序员之间进行交流的工具<blockquote><p>逻辑模型的类型: 层次,网状,关系</p></blockquote></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="134-外部模型"></a>1.3.4 外部模型<a class="hash-link" href="#134-外部模型" title="Direct link to heading">#</a></h4><ol><li>是逻辑模型的子集</li><li>独立于硬件,依赖于软件</li><li>反应用户使用数据库的观点</li></ol><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="外部模型的优点"></a>外部模型的优点<a class="hash-link" href="#外部模型的优点" title="Direct link to heading">#</a></h5><ol><li>简化用户的观点</li><li>有助于数据的安全性保护</li><li>外部模型是对概念模型的支持</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="135-内部模型"></a>1.3.5 内部模型<a class="hash-link" href="#135-内部模型" title="Direct link to heading">#</a></h4><p>内部模型也叫做物理模型,是数据库最底层的抽象,它描述数据在磁盘或磁带上的存储方式,存取设备和存取方法</p><blockquote><p>现今的内部细节大多由操作系统实现</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="136-三层模型和两级映象"></a>1.3.6 三层模型和两级映象<a class="hash-link" href="#136-三层模型和两级映象" title="Direct link to heading">#</a></h4><ul><li>三层模型即上述的: 外部,逻辑,内部</li><li>两层映象为: 内部 &lt;-&gt; 逻辑, 逻辑 &lt;-&gt; 内部</li><li>优点: 增强了独立性,不同模式层次之间的操作由映射完成</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="14-数据库管理系统dbms"></a>1.4 数据库管理系统(DBMS)<a class="hash-link" href="#14-数据库管理系统dbms" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="141-dbms的工作模式"></a>1.4.1 DBMS的工作模式<a class="hash-link" href="#141-dbms的工作模式" title="Direct link to heading">#</a></h4><p>数据库操作系统(DBMS)
: 是指数据库系统中对数据进行管理的软件系统。它是数据库系统的核心组成部分.对DB的一切操作,
包括定义,查询,更新及各种控制,都是通过DBMS进行的.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="dbms的工作模式"></a>DBMS的工作模式<a class="hash-link" href="#dbms的工作模式" title="Direct link to heading">#</a></h5><ol><li>接受应用程序的数据请求和处理请求</li><li>将用户的数据请求(高级指令)转换(编译)成复杂的机器码(低级指令)</li><li>实现对数据库的操作</li><li>从对数据库的操作中接受查询结果</li><li>对查询结果进行处理(格式转换)</li><li>将处理结果返回给用户</li></ol><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="dbms的主要功能"></a>DBMS的主要功能<a class="hash-link" href="#dbms的主要功能" title="Direct link to heading">#</a></h5><ol><li>定义(DDL)</li><li>操纵(DML)</li><li>数据库的保护功能<ol><li>数据库的恢复</li><li>并发控制</li><li>完整性控制</li><li>安全性控制</li></ol></li><li>数据库的维护功能
包括数据的载入,转换,转储,数据库的改组以及性能监控等</li><li>数据字典
数据库系统中存放三级结构定义的数据库成为数据字典(DD)</li></ol><blockquote></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="15-数据库系统dbs"></a>1.5 数据库系统(DBS)<a class="hash-link" href="#15-数据库系统dbs" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="151-dbs的组成"></a>1.5.1 DBS的组成<a class="hash-link" href="#151-dbs的组成" title="Direct link to heading">#</a></h4><p>DBS 是采用了数据库技术的计算机系统.它是数据库,硬件,软件和数据库管理员的集合体.</p><p>数据库(DB)
: 是各项应用有关的全部数据的集合.分为两类,一类是应用数据的集合,成为物理数据库,
是数据库的主题;另一类是各级数据结构的描述,称为描述数据库,由DD系统管理.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="数据库管理员dba"></a>数据库管理员(DBA)<a class="hash-link" href="#数据库管理员dba" title="Direct link to heading">#</a></h5><p>DBA需要具备的素质</p><ul><li>熟悉企业全部数据的性质和用途</li><li>对所有用户的需求有</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="152-dbs的全局结构"></a>1.5.2 DBS的全局结构<a class="hash-link" href="#152-dbs的全局结构" title="Direct link to heading">#</a></h4><p>常见书上的图 1.21</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="153-dbs的笑意"></a>1.5.3 DBS的笑意<a class="hash-link" href="#153-dbs的笑意" title="Direct link to heading">#</a></h4><ol><li>灵活性</li><li>简易性</li><li>面向用户</li><li>有效的数据控制</li><li>加快应用系统的开发速度</li><li>维护方便</li><li>标准化</li></ol><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-数据库设计和-er-模型"></a>2. 数据库设计和 ER 模型<a class="hash-link" href="#2-数据库设计和-er-模型" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="21-数据库系统生存期"></a>2.1 数据库系统生存期<a class="hash-link" href="#21-数据库系统生存期" title="Direct link to heading">#</a></h3><p>数据库生存期一般分为七个阶段: 规划,需求分析,概念设计,逻辑设计,实现,运行维护</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="211-规划阶段"></a>2.1.1 规划阶段<a class="hash-link" href="#211-规划阶段" title="Direct link to heading">#</a></h4><p>对于数据库系统,特别是大型数据库系统或大型信息系统中的数据库群,规划阶段是十分必要的.
规划的好坏将直接影响到整个系统的成功与否,对应用单位的信息化进程将产生深远影响.</p><p>规划阶段的具体步骤:</p><ol><li><p>系统调查
对应用单位做全面的调查.发现其存在的主要问题,并画出组织层次图,以了解企业的组织结构</p></li><li><p>可行性分析
从技术,经济,效益,法律等诸方面对建立数据库的可行性进行分析,然后写出可行性分析报告;组织专家进行讨论其可行性</p></li><li><p>确定数据库系统的总目标, 并对应用单位的工作流程进行优化和制定项目开发计划.
在得到决策部门批准后,就正式进入数据库系统的开发工作</p></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="212-需求分析阶段"></a>2.1.2 需求分析阶段<a class="hash-link" href="#212-需求分析阶段" title="Direct link to heading">#</a></h4><p>这一阶段是计算机人员(系统分析员)和用户双方共同收集数据库所需的信息内容和用户对处理的需求,
并以需求说明书的形式确定下来,作为以后开系统开发的指南和系统验证的依据</p><p>需求分析阶段的具体步骤:</p><ol><li>分析用户活动,产生业务流程图</li><li>确定系统范围,产生系统关系图</li><li>分析用户活动涉及的数据,产生数据流图(DFD)</li><li>分析系统数据,产生数据字典</li></ol><blockquote><p>数据字典中通常包括数据项,数据结构,数据流,数据存储和处理5个部分</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="213-概念设计阶段"></a>2.1.3 概念设计阶段<a class="hash-link" href="#213-概念设计阶段" title="Direct link to heading">#</a></h4><p>概念设计的目标是产生反应用户单位信息需求的数据概念结构,即概念结构,概念模型独立于计
算机硬件结构,独立于支持数据的DBMS.</p><p>概念设计的主要步骤:</p><ol><li><p>进行数据抽象,设计局部概念模型</p><blockquote><p>设计概念结构时,常用的数据抽象方法是&quot;聚集&quot;和&quot;概括&quot;</p></blockquote></li><li><p>将局部概念综合成全局概念模型</p></li><li><p>评审
确认全局结构是否完整,各种划分是否合理,是否存在不一致性,各种文档是否齐全</p></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="214-逻辑设计阶段"></a>2.1.4 逻辑设计阶段<a class="hash-link" href="#214-逻辑设计阶段" title="Direct link to heading">#</a></h4><p>概念设计的结果是得到一个与DBMS无关的概念模型.而逻辑设计的目的是把概念设计阶段设计好的
概念模型转换成具体的逻辑模型.</p><p>逻辑设计的主要步骤:</p><ol><li>把概念模型转换成逻辑模型
ER模型转换成关系模型</li><li>设计外模型</li><li>设计应用程序与数据库的接口</li><li>评价模型</li><li>修正模型</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="215-物理设计阶段"></a>2.1.5 物理设计阶段<a class="hash-link" href="#215-物理设计阶段" title="Direct link to heading">#</a></h4><p>具体步骤:</p><ol><li>存储记录结构设计</li><li>确定数据存放位置</li><li>存取方法的设计</li><li>完整性和安全性考虑</li><li>程序设计</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="216-数据库的实现"></a>2.1.6 数据库的实现<a class="hash-link" href="#216-数据库的实现" title="Direct link to heading">#</a></h4><p>主要包括</p><ol><li>用DDL定义数据库结构</li><li>数据装载/组织数据入库
具体步骤: 筛选数据, 输入数据, 转换数据格式, 校验数据, 综合数据</li><li>编制与调试应用程序
该步骤使用模拟数据进行调试</li><li>数据库试运行
功能调试,性能测试</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="217-数据库的运行与维护"></a>2.1.7 数据库的运行与维护<a class="hash-link" href="#217-数据库的运行与维护" title="Direct link to heading">#</a></h4><p>在数据库运行阶段,对数据库经常性的维护工作主要由DBA完成,它包括以下内容:</p><ol><li>数据库的转储和恢复</li><li>数据库安全性,完整性控制</li><li>数据库性能的监督,分析和改进</li><li>数据库的重组织和重构造</li></ol><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-关系模式设计理论"></a>3. 关系模式设计理论<a class="hash-link" href="#3-关系模式设计理论" title="Direct link to heading">#</a></h2><p>关系模式设计理论主要包括三个方面的内容: 数据依赖,范式和模式设计方法</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="31-关系模式的设计准则"></a>3.1 关系模式的设计准则<a class="hash-link" href="#31-关系模式的设计准则" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="311-关系模式的冗余和异常问题"></a>3.1.1 关系模式的冗余和异常问题<a class="hash-link" href="#311-关系模式的冗余和异常问题" title="Direct link to heading">#</a></h4><p> <strong>分解</strong>是解决冗余的主要方法,也是规范化的一条原则:&quot;关系模式有冗余,就分解它&quot;</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="312-关系模式的非形式化设计准则"></a>3.1.2 关系模式的非形式化设计准则<a class="hash-link" href="#312-关系模式的非形式化设计准则" title="Direct link to heading">#</a></h4><p>准则 3.1
: <small>关系模式的设计尽可能</small>只包含有直接联系的属性,不要包含有间接联系的属性.
也就是,每个关系关系模式应只对应于一个实体类型或一个联系类型.</p><p>准则 3.2
: <small>关系模式的设计尽可能使得相应关系中</small>不出现插入,删除和修改等操作异常现象.
如果出现任何异常,则要清楚的加以说明,并确保更新数据库的程序正确操作.</p><p>准则 3.3
: <small>关系模式的设计尽可能使得相应关系中</small>避免放置经常为空的属性.</p><p>准则 3.4
: <small>关系模式的设计应尽可能使得</small>关系的等值连接在主键和外键的属性上进行,
并且保证连接以后不会产生额外的元组.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&gt; 如果两个连接匹配的不是外键或主键,那么这种连接很可能会产生额外元组</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="32-函数依赖"></a>3.2 函数依赖<a class="hash-link" href="#32-函数依赖" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="321-函数依赖的定义"></a>3.2.1 函数依赖的定义<a class="hash-link" href="#321-函数依赖的定义" title="Direct link to heading">#</a></h4><p>定义 3.1
: 设有关系模式 R(U), X 和 Y 是属性集 U 的子集,
<strong>函数依赖(FUnctional Dependency, 简记为 FD)</strong>
是形成 $x\rightarrow y$ 的一个命题, 只要r是R的当前关系,
对r中任意两个元组 t 和 s,都有 t[X] = s[X] 蕴含 t[Y] = s[Y],
那么称 $FD\quad x\rightarrow y$ 在关系模式 R(U)中成立.</p><p>这里 t[X] 表示元组 t 在属性集 X 上的值,其余类同. $X \rightarrow Y$ 读作 X 函数决定 Y,
或 Y 函数依赖于 X. FD 是对关系模式 R 的一切可能的关系 r 定义的. 对于当前关系 r 的任意两个元组,
如果 X 相同,则要求 Y 值也相同.即有一个 X 值就有一个 Y 值与之对应, 或者说 Y 值由 X 值决定.
因而这种依赖称为函数依赖.</p><p>当关系模式上存在函数依赖时,对其关系中的值将有严格的限制.</p><p>定义 3.2
: 如果 $X \rightarrow Y$ 和 $Y \rightarrow X$ 同时成立,则可记为 $X \leftrightarrow Y$.
也就是在关系中, X 值和 Y 值具有一一对应的关系.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="322-fd-的逻辑蕴含"></a>3.2.2 FD 的逻辑蕴含<a class="hash-link" href="#322-fd-的逻辑蕴含" title="Direct link to heading">#</a></h4><p>定义 3.3
: 设 F 是在关系模式 R 上成立的函数依赖的集合, $X \rightarrow Y$ 是一个函数依赖.
如果对于 R 的每个满足 F 的关系 r 也满足 $X \rightarrow Y$, 那么 F 逻辑蕴含
$X \rightarrow Y$,记为 $F \models X\rightarrow Y$.</p><p>定义 3.4
: 设 F 是函数依赖集, 被 F 逻辑蕴含的函数依赖全体构成的集合,称为函数依赖集 F 的
<strong>闭包(Closure)</strong>, 记为${ F }^{ + }$ . 即
$$
{ F }^{ + }={ \quad X\rightarrow Y\quad |\quad F \models X\rightarrow Y\quad }
$$</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="323-fd-的推理规则"></a>3.2.3 FD 的推理规则<a class="hash-link" href="#323-fd-的推理规则" title="Direct link to heading">#</a></h4><p>设 U 是关系模式 R 的属性集. F 是 R 上成立的只涉及到 U 中舒心的函数依赖集. FD 的推理规则有以下三条:</p><p>自反性(Reflexivity)
: A1
: 若 $Y \subseteq X \subseteq U$, 则 $X \rightarrow Y$ 在 R 上成立.</p><p>增广性(Augmentation)
: A2
: 若 $X \rightarrow Y$在 R 上成立,且 $Z \subseteq U$, 则 $XZ \rightarrow YZ$在 R 上成立.</p><p>传递性(Transitivity)
: A3
: 若 $X \rightarrow Y$ 和 $Y \rightarrow Z$ 在 R 上成立,
则 $X \rightarrow Z$在 R 上成立.</p><p>定理 3.1
: FD 推理规则 A1, A2 和 A3. 也就是, 如果 $X \rightarrow Y$
是从 F 用推理规则导出, 那么 $X \rightarrow Y$在$F^+$中</p><p><strong>定理 3.2</strong> FD 的其他五条推理规则</p><p>合并性(Union)
: A4
: $ { X \rightarrow Y, Y \rightarrow Z } \models X \rightarrow YZ$</p><p>分解性(Decomposition)
: A5
: ${ X \rightarrow Y, Z \subseteq Y } \models X \rightarrow Z$</p><p>伪传递性
: A6
: $ { X \rightarrow Y, WY \rightarrow Z } \models WX \rightarrow Z$</p><p>复合性(Composition)
: A7
: ${ X \rightarrow Y, W \rightarrow Z } \models XW \rightarrow YZ$</p><p>通用一致性定理(Genernal Unification Theorem)
: ${ X \rightarrow Y, W \rightarrow Z } \models X \cup (W - Y) \rightarrow YZ$</p><p>定义 3.5
: 对于 $FD X \rightarrow Y$, 如果 $Y \subseteq X$, 那么称 $X \rightarrow Y$
是一个 <strong>平凡的 FD</strong>, 否则称为 <strong>非平凡的 FD</strong></p><p>正如名称所示,平凡的 FD 并没有实际意义,根据规则 A1 就可以退出. 人们感兴趣的是非平凡的 FD.
只有非平凡的 FD 才和 <em>真正的</em> 完整性约束条件相关.</p><p>从规则 A4 和 A5. 立即可得到下面的定理</p><p>定理 3.3
: 如果 $A_1 \cdots A_n$ 是关系模式 R 的属性集, 那么 $X \rightarrow A_1 \cdots A_n$
成立的充分必要条件是 $X \rightarrow A_i (i = 1, \cdots, n)$ 成立</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="324-fd-和关键码的联系"></a>3.2.4 FD 和关键码的联系<a class="hash-link" href="#324-fd-和关键码的联系" title="Direct link to heading">#</a></h4><p>函数依赖是关键码概念的推广.</p><p>定义 3.6
: 设关系模式 R 的属性集是 U, X 是 U 的一个子集.如果 $X \rightarrow U$ 在 R 上成立,
那么称 X 是 R 的一个超键. 如果 $X \rightarrow U$子 R 上成立,但对于 X 的任一真子集
$X_1$ 都有 $X_1 \rightarrow U$ 不成立,那么称 X 是 R 上的一个候选键(没有多余属性).</p><p>一般键都是指候选键.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="325-属性集的闭包"></a>3.2.5 属性集的闭包<a class="hash-link" href="#325-属性集的闭包" title="Direct link to heading">#</a></h4><p>定义 3.7
: 设 F 是属性集 U 上的 FD 集, X 是 U 的子集. 那么(相对于 F)属性集 X 的闭包用 $X^+$
表示, 它是一个从 F 集使用 FD 推理规则推出的满足所有 $X \rightarrow A$的属性A的集合:
$$
X^+ = {\quad 属性 A \quad |\quad  F \models X \rightarrow A \quad }
$$</p><p>从属性集闭包的定义,立即可得出下面的定理</p><p>定理 3.4
: $X \rightarrow Y$ 能用 FD 推理规则推出的充分必要条件是 $Y \subseteq X^+$</p><p>算法 3.1
: 求属性集 X 相对于 FD 集 F 的闭包 $X^+$
: 设属性集 X 的闭包为 $X^+$, 其计算算法如下:
$$
\qquad X^+ = X; \qquad\
do  { \qquad\qquad\qquad\qquad \
oldX^+ := X^+; \
\qquad\qquad\qquad\qquad
for\quad {FD}\quad Y \rightarrow Z\quad in\quad F\quad do \
\qquad\qquad\qquad\qquad\qquad\qquad
if\quad Y \subseteq X^+ then\quad X^+ := X^+\cup Z; \
} while(X^+ != oldX^+);
$$</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="326-fd-集的最小依赖集"></a>3.2.6 FD 集的最小依赖集<a class="hash-link" href="#326-fd-集的最小依赖集" title="Direct link to heading">#</a></h4><p>定义 3.8
: 如果关系模式 R(U) 上的两个函数依赖集 F 和 G, 有 $F^+ = G^+ $,则称 F 和 G
是等价的函数依赖集</p><p>F 和 G 等价,意味着 F 中每一个 FD 都可以从 G 推导出来, 并且 G 中每一个 FD也都可以从F推导出来</p><p>函数依赖集 F 中的 FD 很多,我们应该从 F 中去掉平凡的 FD, 无关的 FD, FD 中无关的属性,
以求得与 F 等价的最小依赖集 G.</p><p><strong>定义 3.9</strong>
如果函数依赖集 G 满足下列三个条件,则称 G 是最小依赖集</p><ol><li>G 中每个 FD 的右边都是单属性</li><li>G 中没有冗余的 F, 即 G 中不存在这样的函数依赖 $X \rightarrow Y$,
使得 $G - { X \rightarrow Y }$ 与 G 等价</li><li>G 中每个 FD 的左边没有冗余的属性, 即 G 中不存在这样的函数依赖 $X \rightarrow Y$,
X 有真子集 W 使得 $G - {X \rightarrow Y } \cup { W \rightarrow Y }$
与 G 等价.</li></ol><blockquote><p>显然, 每个函数依赖集至少存在一个等价的最小依赖集,但并不一定唯一</p></blockquote><p><strong>算法 3.2</strong>
: 计算函数依赖集 F 的最小依赖集 G</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">1. 根据推理规则的分解特性(A5),得到一个与 F 等价的 FD 集 G,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">G中每个FD的左右均为单属性</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">2. 在 G 的每个 FD 中消除左边冗余的属性</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">3. 在 G 中消除冗余的 FD</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="33-关系模式的分解特性"></a>3.3 关系模式的分解特性<a class="hash-link" href="#33-关系模式的分解特性" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="331-关系模式的分解"></a>3.3.1 关系模式的分解<a class="hash-link" href="#331-关系模式的分解" title="Direct link to heading">#</a></h4><p>定义 3.10
: 设有关系模式 R(U), 属性集为 U, 而 $R_1,\cdots,R_k$都是 U 的子集,
并且有$R_1 \cup R_2 \cup \cdots \cup R_k = U$. 关系模式 $R_1,\cdots,R_k$
的集合用 $\rho$ 表示, $\rho = { R_1,\cdots,R_k }$. 用$\rho$代替 R 的过程
称为关系模式的分解.这里$\rho$称为 R 的一个分解.也称为<strong>数据库模式</strong>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="332-无损分解"></a>3.3.2 无损分解<a class="hash-link" href="#332-无损分解" title="Direct link to heading">#</a></h4><p>定义 3.11
: 在泛关系模式 R 分解陈数据库模式 $\rho = R_1,\cdots,R_k$时,
泛关系 r 在 $\rho$ 的每一模式 $R_i (1 \le i \le n)$上投影后
再连接起来,比原来r中多出来的元组,称为 <strong>寄生元组(Spurious Tuple)</strong>.</p><p>定义 3.12
: 设 R 是一个关系模式, F 是 R 上的一个 FD 集. R 分解成数据库模式
$\rho = R<em>1,\cdots,R_k$.如果对 R 中满足 F 的每一个关系 r, 都有
$$
r \quad=
\quad\pi</em>{R<em>2}\quad(r)
\quad\rhd\lhd \quad \pi</em>(R<em>2)(r)
\quad\rhd\lhd \quad \cdots \pi</em>(R_k)(r)
$$</p><p>那么称分解 $\rho$ 相对于 F 是<strong>无损连接分解(Lossless Join Decomposition)</strong>,
简称为 <em>无损分解</em>,否则称为 <strong>损失分解(Lossy Decomposition)</strong></p><p><em>损</em>是指信息的丢失,而不是元组的丢失.如果一个分解不具有<em>无损</em>性质,
那么泛关系在投影连接以后就可能产生寄生元组.寄生元组表示的是错误信息.</p><p>其中符号 $\pi<em>{R_i}(r)$ 表示关系 r 在模式 $R_i$属性上的投影.
r 的投影连接表达式 $\pi</em>{R<em>1}(r) \quad \rhd\lhd \quad \cdots \pi</em>{R<em>k}(r)$
用符号$m</em>{\rho}(r)$表示, 即
$$
m<em>{\rho}(r) = \overset {k}{\underset { i=1 }{ \rhd \lhd }}\pi</em>{R_i}(r)
$$</p><p>需要注意的是,上述定义有一个先决条件,即 r 是 R 的一个关系. 也就是先存在 r(泛关系)
的情况下,再去谈论分解,这是关系数据库理论中著名的<strong>泛关系假设(Universal Relation Assumption)</strong></p><p>定义 3.13
: 在无泛关系假设时,对两个关系进行自然连接中被丢失的元组称为悬挂元组.</p><blockquote><p>悬挂元组是造成两个关系不存在泛关系的原因.</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="333-模式分解的优缺点"></a>3.3.3 模式分解的优缺点<a class="hash-link" href="#333-模式分解的优缺点" title="Direct link to heading">#</a></h4><p>优点:</p><ol><li>模式分解能消除数据冗余和操作异常现象</li><li>在分解了的数据库中可以存储悬挂元组,存储泛关系中无法存储的信息</li></ol><p>缺点:</p><ol><li>分解以后,检索操作需要做笛卡尔积或连接操作,这将付出时间代价</li><li>在有泛关系假设时,对数据库中关系进行自然连接时,可能产生寄生元组,
即损失了信息.在无泛关系假设时,由于数据库可能存在悬挂元组,就有可能
不存在泛关系</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="334-无损分解的测试方法"></a>3.3.4 无损分解的测试方法<a class="hash-link" href="#334-无损分解的测试方法" title="Direct link to heading">#</a></h4><p>略</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="335-保持-fd-的分解"></a>3.3.5 保持 FD 的分解<a class="hash-link" href="#335-保持-fd-的分解" title="Direct link to heading">#</a></h4><p>分解的另一个特性是在分解的过程中能否保持函数依赖集,如果不能保持 FD, 那么数据的
寓意就会出现混乱.</p><p>定义 3.14
: 设 F 是属性集 U 上的 FD 集, Z 是 U 的子集, F 在 Z 上的投影用$\pi_Z(F)$
表示,定义为
$$
\pi_Z(F) = {\quad
X \rightarrow Y | X \rightarrow Y \in F^+, 且 XY \subseteq Z
\quad }
$$</p><p>定义 3.15
: 设 $\rho = { R<em>i, \cdots, R_k}$ 是 R 的一个分解, F 是R 上的 FD 集, 如果有
$\overset {k}{\underset { i=1 }{ \cup }}\pi</em>{R_i}(F) \models F$,
那么称分解 $\rho$ 保持函数依赖集 F.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="34-范式"></a>3.4 范式<a class="hash-link" href="#34-范式" title="Direct link to heading">#</a></h3><p>关系模式的好与坏,用什么标准来衡量? 这个标准就是模式的<strong>范式(Normal Forms, 简记为 FN)</strong>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="341-第一范式1nf"></a>3.4.1 第一范式(1NF)<a class="hash-link" href="#341-第一范式1nf" title="Direct link to heading">#</a></h4><p>定义 3.16
: 如果关系模式 R 的每个关系 r 的属性值都是不可分的原子值,那么称 R 是
<strong>第一范式(First Normal Forms, 简记为 1NF)</strong>的模式.</p><p>满足 1NF 的关系称为规范化的关系,否则称为非规范化的关系.关系数据库研究的关系都是规
范化的关系.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="342-第二范式2nf"></a>3.4.2 第二范式(2NF)<a class="hash-link" href="#342-第二范式2nf" title="Direct link to heading">#</a></h4><p>定义 3.17
: 对于 $FD\quad W\rightarrow A$,如果存在 $X \subset W$ 有 $X \rightarrow A$
成立, 那么称 $W \rightarrow A$ 是局部依赖(A 局部依赖于 W);否则称$W\rightarrow A$
是完全依赖.</p><p>完全依赖也称为<strong>左部不可约依赖</strong>.</p><p>定义 3.18
: 如果 A 是关系模式 R 的候选键的属性,那么称 A 是 R 的主属性; 否则称 A 是 R 的非主属性</p><p>定义 3.19
: 如果关系模式 R 是 1NF, 且每个非主属性完全函数依赖于候选键,那么称 R 是第二范式(2NF)的
模式.如果数据库模式中每个关系模式都是 2NF,则称数据库模式为 2NF 的数据库模式.</p><blockquote><p>不满足 2NF的关系模式中必定存在有非主属性对关键码的局部依赖.</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="343-第三范式3nf"></a>3.4.3 第三范式(3NF)<a class="hash-link" href="#343-第三范式3nf" title="Direct link to heading">#</a></h4><p>定义 3.20
: 如果 $X \rightarrow Y , Y \rightarrow A, 且 Y \nrightarrow X 和 A \notin Y
,那么称 X \rightarrow A $是传递依赖(A 传递依赖于 X).</p><p>定义 3.21
: 如果关系模式 R 是 1NF, 且每个非主属性都不传递依赖于 R 的候选键,那么称 R 是第三范式
(3NF)的模式.如果数据库模式中每个关系模式都是 3NF,则称其为 3NF 的数据库模式.</p><p>定义 3.22
: 设 F 是关系模式 R 的 FD 集, 如果对 F 中每个非平凡的 $FD\quad X\rightarrow Y$,
都有X是R的超键,或者 Y 的每个属性都是主属性, 那么称 R 是3NF 的模式.</p><p>定理 3.5
: 如果 R 是 3NF 模式,那么 R 也是2NF 模式.</p><p>局部依赖和传递依赖是模式产生冗余和异常的两个重要原因. 由于 3NF 模式中不存在非主属性
对候选键的局部依赖和传递依赖,因此消除了很大一部分存储异常.
将 1NF, 2NF 转换为 3NF 的过程称为 关系的规范化处理.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="344-bcnfboyoce-codd-nf"></a>3.4.4 BCNF(Boyoce-Codd NF)<a class="hash-link" href="#344-bcnfboyoce-codd-nf" title="Direct link to heading">#</a></h4><p>定义 3.33
: 如果关系模式 R 是 1NF, 且每个属性都不传递依赖于 R 的候选键,那么称 R 是 BCNF 模式.
如果数据库中的所有关系模式都是 BCNF, 则称为 BCNF 的数据库模式.</p><p>定义 3.34
: 设 F 设计关系模式 R 的FD 集, 如果对 F 中每个非平凡$FD \quad X \rightarrow Y$
都有 X 是 R 的超键,那么称 R 是 BCNF 模式.</p><p>这个定义表明,如果非平凡的 $FD\quad X\rightarrow Y$中 X 不包含超键,那么 Y 必定
传递依赖于候选键, 因此 R 不是 BCNF 模式.</p><p>定理
: 3.6 如果 R 是 BCNF 模式,那么 R 也是 3NF 模式</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="35-多值依赖和第四范式"></a>3.5 多值依赖和第四范式<a class="hash-link" href="#35-多值依赖和第四范式" title="Direct link to heading">#</a></h3><p>略</p><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="appendixa-er-模型"></a>Appendix.A ER 模型<a class="hash-link" href="#appendixa-er-模型" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="1-er-模型的基本元素"></a>1. ER 模型的基本元素<a class="hash-link" href="#1-er-模型的基本元素" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="11-实体"></a>1.1. 实体<a class="hash-link" href="#11-实体" title="Direct link to heading">#</a></h4><p>实体(Entity)
: 是一个数据对象,指应用中可以区别的客观存在的事物</p><p>实体集(Entity Set)
: 是指同一类</p><p>实体类型(Entity Type)
: 是对实体集中实体的定义</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="12-联系"></a>1.2. 联系<a class="hash-link" href="#12-联系" title="Direct link to heading">#</a></h4><p>联系(Relationship)
: 表示一个或多个实体之间的关联关系</p><p>联系集(Relationship Set)
: 是指同一类联系构成的集合</p><p>联系类型(Relationship Type)
: 是对联系集中联系的定义</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="13-属性"></a>1.3 属性<a class="hash-link" href="#13-属性" title="Direct link to heading">#</a></h4><p>实体的某一特性称为属性(Attribute).在一个实体中,能够唯一标识实体的属性或属性
集称为&quot;实体标识符&quot;.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-属性的分类"></a>2. 属性的分类<a class="hash-link" href="#2-属性的分类" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="21-简单属性和复合属性"></a>2.1 简单属性和复合属性<a class="hash-link" href="#21-简单属性和复合属性" title="Direct link to heading">#</a></h4><p>简单属性(Simple Attribute)
: 简单属性是不可再分割的属性.例如: 年龄,性别</p><p>复合属性(Composite Attribute)
: 复合属性是可以再分解为其他属性的属性.例如: 地址可分为省,市,区,街道等子属性</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="22-单值属性和多值属性"></a>2.2 单值属性和多值属性<a class="hash-link" href="#22-单值属性和多值属性" title="Direct link to heading">#</a></h4><p>单值属性(Single-Valued Attribute)
: 是指同一个实体的属性只能取一个值.例如: 年龄,性别</p><p>多值属性(Mulyi-Valued Attribute)
: 实体属性可取多个值.例如: 一个文章的标签,可能会有多个标签</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="分解多值属性的方法"></a>分解多值属性的方法<a class="hash-link" href="#分解多值属性的方法" title="Direct link to heading">#</a></h5><ol><li>将原来的多值属性用几个新的单值属性表示</li><li>将多值属性用一个新的实体类型表示</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="23-存储属性和派生属性"></a>2.3 存储属性和派生属性<a class="hash-link" href="#23-存储属性和派生属性" title="Direct link to heading">#</a></h4><p>派生属性(Derived Attribute)
: 两个(或两个以上)属性是相关的.可以从其他属性推导该属性的值</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&gt; 派生属性的值不必存储在数据库内</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>存储属性(Stored Attribute)
: 反之,除了能推导出值的派生属性,其他都是存储属性.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="24-可空属性"></a>2.4 可空属性<a class="hash-link" href="#24-可空属性" title="Direct link to heading">#</a></h4><p>可空属性(Null Value)
: 当实体在某个属性上没有值时,可以使用空值(Null Value)的属性
: 例如: 配偶,当未婚是该值无意义,即可为空,但也可以理解为已婚但配偶未知,或尚不知是否婚
: 否.在数据库中,空值是很难处理的一种值.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-联系的设计"></a>3. 联系的设计<a class="hash-link" href="#3-联系的设计" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="31-联系的元数"></a>3.1 联系的元数<a class="hash-link" href="#31-联系的元数" title="Direct link to heading">#</a></h4><p>元数/度数(Degree)
: 一个联系涉及到的实体集的个数
: 简单的可称之为 一元联系,二元联系,三元联系</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="32-联系类型的约束"></a>3.2 联系类型的约束<a class="hash-link" href="#32-联系类型的约束" title="Direct link to heading">#</a></h4><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="321-基数约束"></a>3.2.1 基数约束<a class="hash-link" href="#321-基数约束" title="Direct link to heading">#</a></h5><p>映射基数(Mapping Cardinalities)
: 实体集 E1 和 E2 之间有二元联系,则参与一个联系中的实体数目成为映射基数
: 对于二元联系类型,可能的映射基数有 1:1, 1:N, N:M,</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="322-参与约束"></a>3.2.2 参与约束<a class="hash-link" href="#322-参与约束" title="Direct link to heading">#</a></h5><p>完全参与
: 如果实体集 E 中的内阁实体都参与联系集 R 的至少一个联系中,则称实体集 E 完全参与 联系集 R</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="33-er模型的操作"></a>3.3 ER模型的操作<a class="hash-link" href="#33-er模型的操作" title="Direct link to heading">#</a></h4><p>ER 模型的操作包括实体类型,联系类型和属性的分裂,合并,增删 等</p><blockquote><p>分裂方式有水平分裂和垂直分裂两种
合并是分裂的逆操作过程,合并的联系类型必须是定义在相同的实体类型组合中</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="34-采用er模型的数据库概念设计步骤"></a>3.4 采用ER模型的数据库概念设计步骤<a class="hash-link" href="#34-采用er模型的数据库概念设计步骤" title="Direct link to heading">#</a></h4><p>采用 ER 模型进行数据库的概念设计,可以分成三步进行: 设计局部 ER 模型,然后把各局部 ER 模型综合成一个全局 ER 模型,最后对全局 ER 模型进行优化,得到最终的 ER 模型,即概念模型.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="341-设计局部-er-模型"></a>3.4.1 设计局部 ER 模型<a class="hash-link" href="#341-设计局部-er-模型" title="Direct link to heading">#</a></h5><ol><li><p>确定局部结构范围
一个数据结构是为多个不同用户服务的.各个用户使用数据的方法不同,需求不同.固先为各种用户确定局部的使用方法,并以 ER 模型来表示.
需要考虑的因素</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">1. 范围划分要自然,易于管理</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">2. 范围之间的界面要清晰,相互影响要小</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">3. 范围的大小要适度</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div></li><li><p>定义实体
每一个局部结构都包含一些实体类型,实体定义的任务就是从信息需求和局部范围定义出发,确定每一个实体类型的属性和键.
划分的依据通常有:</p><ol><li>采用人们习惯的划分</li><li>避免冗余</li><li>依据用户的信息处理需求</li></ol></li><li><p>定义联系</p></li><li><p>分配属性
分配属性分为两个步骤: 一是确定属性,二是把属性分配到
确定属性的原则:</p><ol><li>属性应该是不可再分解的寓意范围.不可分解是为了使模型结构简单化,不出现嵌套结构.</li><li>实体与属性之间的关系只能是 1:N 的</li><li>不同实体类型的属性之间应无直接关系</li></ol></li></ol><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="342-设计全局-er-模型"></a>3.4.2 设计全局 ER 模型<a class="hash-link" href="#342-设计全局-er-模型" title="Direct link to heading">#</a></h5><ol><li><p>确定公共实体类型
一般把同名实体类型作为公共实体类型的一类候选,把具有相同键的实体类型作为公共实体类型的另一类候选.</p></li><li><p>合并局部 ER 模型
合并原则: 首先进行两两合并; 先合并那些现实世界中有联系的局部结构;合并从公共实体类型开始,最后加入独立的局部结构.
进行二元合并是为了减少合并工作的复杂性.后两项则是为了使合并结果的规模尽可能小.</p></li><li><p>消除冲突</p><ul><li>属性冲突</li><li>结构冲突</li><li>命名冲突</li></ul></li></ol><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="343-全局-er-模型的优化"></a>3.4.3 全局 ER 模型的优化<a class="hash-link" href="#343-全局-er-模型的优化" title="Direct link to heading">#</a></h5><p>一个好的全局 ER 模型,除能准确,全面地反映用户功能需求外,还应满足下列条件(优化目标):</p><ol><li>实体类型的个数尽可能少</li><li>实体类型所含属性个数尽可能少</li><li>实体类型间联系无冗余</li></ol><p>优化规则:</p><ol><li>合并实体类型
可以把 1:1 联系的两个实体类型合并</li><li>消除冗余属性</li><li>消除冗余联系</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-er-模型到关系模型的转换"></a>4. ER 模型到关系模型的转换<a class="hash-link" href="#4-er-模型到关系模型的转换" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="41-er-图转换成关系模式集的算法"></a>4.1 ER 图转换成关系模式集的算法<a class="hash-link" href="#41-er-图转换成关系模式集的算法" title="Direct link to heading">#</a></h4><ol><li><p>实体类型的转换</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">实体 | 关系模式</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>:---:|:------:
实体 | 关系模式
实体属性 | 关系模式属性
实体标识符 | 关系模式的键</p></li><li><p>联系类型的转换</p><ol><li><p>二元联系的转换</p><ol><li>1:1 在任意一个关系模式中加入另一个关系模式的键作为外键</li><li>1:N 在N端实体转换成的关系模式中加入1端关系模式的键作为外键</li><li>N:M 将联系类型转换为关系模式,将两段的键作为外键加入到该关系模式,
并将联系类型的属性加入到该模式中,而键为两段实体键的组合</li></ol></li><li><p>一元联系的转换
和二元转换类似</p></li><li><p>三元联系类型的转换</p><ol><li>1:1:1 在任意一个关系模式中加入另外两个的键作为外键,加入联系类型的属性</li><li>1:1:N 同上,将键加入到 N 端实体转换成的关系模型中</li><li>1:M:N 将联系类型转换为关系模型,将 N 端和 M 端的键作为外键和联系类型的
属性加入到该关系模型中, 键为 N 端和 M 端实体键组合</li><li>M:N:P 同上,将三端的键(作为外键)和联系属性加入到该关系模型,
键为三端实体键的组合</li></ol></li></ol></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="42-采用-er-模型的逻辑设计步骤"></a>4.2 采用 ER 模型的逻辑设计步骤<a class="hash-link" href="#42-采用-er-模型的逻辑设计步骤" title="Direct link to heading">#</a></h4><ol><li><p>导出初始关系模式集
即把概念设计的结果(全局 ER 模型)转换为初始关系模式集</p></li><li><p>规范化处理
规范化的目的是减少乃至消除关系模式中存在的各种异常,改善完整性,一致性和存储效率</p></li><li><p>模式评价
主要包括功能和性能两方面</p></li><li><p>模式修正</p></li><li><p>设计子模式(外部模式
)</p></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5增强的-er-模型"></a>5.增强的 ER 模型<a class="hash-link" href="#5增强的-er-模型" title="Direct link to heading">#</a></h3><p>为了更准确的模拟现实世界,需要扩展基本 ER 模型的概念,从而产生了增强的 ER 模型(Enhanced-ER model, 简称 EER)</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="51-弱实体与强实体"></a>5.1 弱实体与强实体<a class="hash-link" href="#51-弱实体与强实体" title="Direct link to heading">#</a></h4><p>若实体
: 一个实体的存在必须依赖于其他实体</p><blockquote><p>若实体参与联系时是完全参与,强实体与弱实体的联系只能是 1:N或N:M</p></blockquote><p>强实体
: 可不必依赖于其他实体</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="52-子类实体与超类实体"></a>5.2 子类实体与超类实体<a class="hash-link" href="#52-子类实体与超类实体" title="Direct link to heading">#</a></h4><p>单较低层上实体类型表到了与之联系的较高层上的实体类型的特殊情况时,就称较高层上实体类型为<strong>超类型(Supertype)</strong>,较低层上实体类型为子<strong>类型(Subtype)</strong></p><p>在数据库设计中,子类到超类的抽象化过程称为<strong>概化</strong>,则是自底向上的概念<strong>综合(Synthesis)</strong>;从超类具化到之类的过程称为<strong>特化</strong>,则是自顶向下的概念<strong>发挥(Refinement)</strong>.</p><p>之类与超类有两个特点:</p><ol><li>之类与超类之间具有继承性特点</li><li>这种继承性是通过之类实体和超类实体具有相同的实体标识符实现的</li></ol><p>此外,有两种约束适用于特化过程.</p><p>不相交约束(Disjointness Constraint)
: 约束之类特化是是否相交,分为不相交和重叠两种情况</p><p>不相交(Disjoint)
: 约束规定了在特化过程中,之类必须是不想交的.</p><p>重叠(Overlap)
: 在特化过程中,子类可以相交</p><p>完备性约束(Complete Constraint):
: 分类整体特化和部分特化</p><p>整体特化(Total Specialization)
: 约束指定超类中的每个实体必须是特化中的某个子类的一个成员</p><p>部分特化(Partial Specialization)
: 超类中的实体可以不属于任何一个子类</p><p>在 ER 图中,所有的子类和超类组成了<strong>层次(Hierarchy)</strong>或 <strong>格(Lattice)</strong>的结构</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="6-er模型的基本表示"></a>6. ER模型的基本表示<a class="hash-link" href="#6-er模型的基本表示" title="Direct link to heading">#</a></h3><table><thead><tr><th align="center">定义</th><th align="center">表示</th></tr></thead><tbody><tr><td align="center">实体</td><td align="center">矩形</td></tr><tr><td align="center">联系</td><td align="center">菱形</td></tr><tr><td align="center">属性</td><td align="center">椭圆</td></tr><tr><td align="center">多值属性</td><td align="center">双线椭圆</td></tr><tr><td align="center">派生属性</td><td align="center">虚线椭圆</td></tr><tr><td align="center">实体标识符</td><td align="center">下划线</td></tr><tr><td align="center">实体与属性</td><td align="center">直线连接</td></tr><tr><td align="center">联系与属性</td><td align="center">直线连接</td></tr><tr><td align="center">联系的基数约束</td><td align="center">在连线上以(m,n)的形式表面</td></tr><tr><td align="center">联系的完全参与</td><td align="center">用双线连接</td></tr><tr><td align="center">联系的类型</td><td align="center">在直线两端指明(1:1,1:N,N:M)</td></tr><tr><td align="center">弱实体</td><td align="center">双线矩形框</td></tr><tr><td align="center">不相交</td><td align="center">小圆圈里为 <strong>d</strong></td></tr><tr><td align="center">重叠</td><td align="center">小圆圈里为 <strong>o</strong></td></tr><tr><td align="center">整体特化</td><td align="center">超类实体与圆圈之间用<strong>双线条</strong>连接</td></tr><tr><td align="center">部分特化</td><td align="center">超类实体与圆圈之间用<strong>单线条</strong>连接</td></tr></tbody></table><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="appendixb-关系模型"></a>Appendix.B 关系模型<a class="hash-link" href="#appendixb-关系模型" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="1-关系模型的基本术语"></a>1. 关系模型的基本术语<a class="hash-link" href="#1-关系模型的基本术语" title="Direct link to heading">#</a></h3><p>关系模型(Relation Model)
: 用二维表格表示实体集,用关键码表示实体之间联系的数据模型称为关系模型.</p><p>在关系模型中,字段称为属性,字段值称为属性值,记录类型称为关系模式,记录称为
<strong>元组(Tuple)</strong>,元组的集合称为<strong>关系(Relation)</strong> 或 <strong>实例(Instance)</strong>.</p><p>在关系中属性的个数称为<strong>元数(Arity)</strong>, 元素个数称为 <strong>基数(Cardinality)</strong></p><p><strong>关键码(Key,简称键)</strong>由一个或多个属性组成,一般有以下几种:</p><p>超键(Super Key)
: 在关系中能唯一标识元组的属性集称为关系模式的超键</p><p>候选键(Candidate Key)
: 不含有多余属性的超键称为候选键</p><p>主键(Primary Key)
: 用户选作元组标识的候选键称为主键</p><p>外键(Foreign Key)
: 如果模式R中,属性K是其他模式的主键,那么K在模式R中称为外键</p><p>关系中每一个属性都有一个取值范围,称为属性的<strong>值域(Domain)</strong>.属性A的取值范围用 DOM(A) 表示.每一个属性对应一个值域,不同的属性可对应于同一值域.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-关系的定义和性质"></a>2. 关系的定义和性质<a class="hash-link" href="#2-关系的定义和性质" title="Direct link to heading">#</a></h3><p>关系是一个属性数目相同的元组的集合.</p><p>如果一个关系的元组数目是无限的,则称为<strong>无限关系</strong>,否则称为<strong>有限关系</strong>.由于计算机存储系统限制,只限于研究有限关系.</p><p>在关系模型中,对关系有下列规范性限制:</p><ol><li>关系中每一个属性值都是不可分解的</li><li>关系中不允许出现重复元组</li><li>由于关系是一个集合,因此不考虑元组间的顺序,即没有行序</li><li>元组中的属性在理论上也是无序的,但使用时按习惯考虑列的顺序</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-三类完整性规则"></a>3. 三类完整性规则<a class="hash-link" href="#3-三类完整性规则" title="Direct link to heading">#</a></h3><ol><li><p>实体完整性规则(Entity Integrity Rule)
这条规则要求关系中元组在组成主键的属性上不能有空值.</p></li><li><p>参照完整性规则(Reference Integrity Rule)
即不允许引用不存在的实体.
这点规则有以下变通:</p><ol><li>外键和相应的主键可以不同名,只要定义在相同的值域上即可</li><li>外键可以是引用同一组关系模式, 此时表示了同一个关系中不同元组之间的联系</li><li>外键值是否允许空,应视具体情况而定</li></ol></li><li><p>用户定义的完整性规则</p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="appendixx-额外的笔记"></a>Appendix.X 额外的笔记<a class="hash-link" href="#appendixx-额外的笔记" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="名词定义"></a>名词定义<a class="hash-link" href="#名词定义" title="Direct link to heading">#</a></h3><p>完全非平凡函数依赖
: 仅当其右边集合的属性都不在左边的集合中时成立</p><p>完全还原模型
: 支持四种备份模式, 1.完全备份, 2.差异备份, 3.事务日志备份, 4.文件组备份</p><p>锁的类型
: 互斥锁,共享锁</p><p>分类
: 分类的目的是学会一个分类函数或分类魔心,该模型能把数据库中的数据项映射到给定
类别中的某一个.</p><p>聚类
: 聚类是把一组个体按照相似性归成若干类别,目的是使属于同一类别的个体之间距离尽
可能小,而不同类别上个体间距离尽可能大.</p><p>数据库恢复顺序
: 首先恢复完全备份,其次恢复差异备份,然后恢复日志备份</p><p>功能需求
: 是详细描述总体结构及功能,系统覆盖的功能范,各功能子系统的划分,功能描述及
子系统之间的关系等</p><p>信息需求/数据需求
: 是完整描述系统所涉及的信息范围, 数据的属性特征,数据之间的关系和约束.</p><p>性能需求
: 描述对系统的性能要求,包括响应时间,存储容量,系统适应性,数据库安全性,
一致性和可靠性.</p><p>元数据
: 是描述数据属性的信息,用来支持如指示存储位置,历史数据,资源查找,文件记录等功能.
元数据算是一种电子式目录,为了达到编制目录的目的,必须描述并收藏数据的内容
或特色,进而达到协助数据检索的目的.</p><p>需求分析
: 是指对即将要开发的系统要做什么以及完成什么功能的全面描述,它关注的是这个系统     必须要做什么.</p><p><strong>日常维护的相关工作</strong></p><ol><li>数据库的备份和恢复</li><li>完整性维护</li><li>安全性维护</li><li>存储空间管理</li><li>冰法控制及死锁处理</li></ol><p>可串行化调度
: 对n个事务组成的事务集 $TS={\quad T_1,T_2,\cdots, T_k,\cdots,T_n\quad}$,
如果并发调度 S 等价于某一在 TS 上的串行调度,那么 S 称为可串行化调度,
否则 S 是不可串行化调度.</p><p>冲突串行化
: 如果定义早事务集 TS 上的并发调度 S 冲突等价于事务集 TS 上的某个串行调度 S&#x27;,
则称 S 是冲突可串行的.冲突可串行的并发调度的执行结果与串行调度一致,是正确的,
同时又具有较高的执行效率.</p><p>触发器
: 通常用于保证业务规则和数据完整性, 其主要优点是用户可以用编程的方法来实现复杂的
处理逻辑和业务规则,增强了数据完整性约束的功能.</p><p>技术可行性
: 是根据用户提出的系统功能,性能及实现系统的各项约束条件,对系统软件,系统硬件,技术
方案作出评估和选择建议,它属于规划与分析阶段的可行性分析.</p><p>数据库应用系统的需求
: 数据需求分析, 数据处理需求分析, 业务需求分析以及在性能, 存储, 安全, 备份和恢复
等方面的要求. 数据操作相应时间, 系统吞吐量, 最大并发用户数都是性能需求分析的
重要指标.</p><p>数据库概念设计阶段的工作目标</p><ol><li>定义和描述应用领域设计的数据范围</li><li>获取应用领域或问题域的信息模型</li><li>描述清楚数据的属性特征</li><li>描述清楚数据之间的关系</li><li>定义和描述数据的约束</li><li>说明数据的安全性要求</li><li>支持用户的各种数据处理需求</li><li>保证信息模型方便地转换成数据库的逻辑结构(数据库模式),同时也便于用户理解.</li></ol><p>数据仓库的定义
: 是一个面向主题的,集成的,非易失的,且随时间变化的数据集合,用来支持管理人员的决策</p><p>数据仓库的特性
: 主题与面向主题,集成,不可更新,随时间变化.</p><p>聚集索引和非聚集索引
: 对数据文件和它的一个特定的索引文件,如果数据文件中数据记录的排列顺序与索引文件中
索引项的排列顺序一致,或者说,索引文件按其查找码指定的顺序与数据文件中数据记录
顺序一致,则该索引文件称为聚集索引,否则成为非聚集索引.</p><p>稠密索引和稀疏索引
: 如果数据文件的每个查找码值在索引文件中都对应一个所以记录,则该索引称为稠密索引.
如果只是一部分查找码对应一个索引记录,则该索引码称为稀疏索引.</p><p>主索引和辅索引
: 在数据文件包含的属性集上建立的索引称为主索引.在数据文件的非主属性上建立的索引
称为辅索引.</p><p>软件总体设计的依据包括 需求分析阶段得到的数据流图, 事务描述和业务规则等需求分析结果.
总体设计得到的系统总体结构和分层模块结构可以用模块结构图表示,模块结构图主要关心模块
的外部特性,即上下级模块以及同级模块间的数据传递和电泳关系,与内部处理流程无关.</p><p>数据模型
: 数据模型是数据库系统的形式框架,是用来描述数据的一组概念和定义.它是包括描述数据,数据
联系,数据操作,数据语义以及数据一致性的概念工具,是数据库系统的核心和基础.按照数据
模型在数据建模和数据管理中的不同作用,可以将其分为概念数据模型,数据结构模型和物理数
据模型.概念数据模型简称概念模型,是按用户的观点对数据和信息进行建模,是现实世界到
信息世界的第一层抽象.数据结构模型也称为表示型或实现型的数据模型,是机器世界中与具体
DBMS 相关的数据模型.物理数据模型属于底层数据模型,通过诸如记录格式,记录顺序和存取路
径等表示信息,描述数据在数据库系统中的实际存储方式/概念模式是对数据库中全体数据的
逻辑结构和特征的描述,是所有用户的公共数据视图,一个数据库只有一个模式.</p><p>数据库应用系统包括概念设计,逻辑设计,物理设计三个步骤.每个步骤按照数据组织与存储,数据
访问与处理,应用设计等几个方面进行.在概念设计阶段,采用自下而上的 E-R 设计.
将关系模式转换为具体 DBMS 平台支持的关系表是数据库物理设计阶段的工作.设计视图和关系
模式的完整性约束是数据逻辑设计阶段的工作.</p><p>OLTP 中的数据一般按面向应用的方式组织,数据仓库系统中的数据一般按面向分析主题的方式组织.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="日志文件的作用"></a>日志文件的作用<a class="hash-link" href="#日志文件的作用" title="Direct link to heading">#</a></h4><ol><li>用于事务故障恢复和系统故障恢复</li><li>动态转储中必须建立日志文件</li><li>静态转储中也可以建立日志文件</li></ol><p>为保证数据库是可恢复的,必须遵循两条规则</p><ol><li>登记的次序严格按并行事务执行的时间次序</li><li>必须先写入日志文件,后写入数据库.</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="人机界面设计原则"></a>人机界面设计原则<a class="hash-link" href="#人机界面设计原则" title="Direct link to heading">#</a></h4><ol><li>用户应当感觉系统的运行始终在自己的控制之下,保持用户与人机界面的双向交流</li><li>当系统发生错误或程序运行时间较长时,用户界面应该提供有意义的反馈信息,并有上下文感知的
帮助系统</li><li>用户界面能容忍用户在操作过程中发生的各种操作错误,并能方便的从错误中恢复,保证系统不受
用户错误操作的影响</li><li>界面遵循一定的标准和常规</li><li>界面应采取灵活多样的数据输入方式,尽量减少用户的输入负担.</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="性能需求分析"></a>性能需求分析<a class="hash-link" href="#性能需求分析" title="Direct link to heading">#</a></h4><ol><li>数据操作响应时间,或数据访问响应时间
指用户向数据库系统提交数据操作请求到操作返回用户的时间.</li><li>系统吞吐量
系统在单位时间内可以完成的数据库事务或数据查询的数量.
吞吐量可以表示为 每秒事务数(TPS).</li><li>允许并发访问的最大用户数
在保证单个用户查询响应时间的前提下,系统最多允许多少用户同时访问数据库.</li><li>TPS 代价值
用于衡量系统性价比的指标.</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="视图的作用"></a>视图的作用<a class="hash-link" href="#视图的作用" title="Direct link to heading">#</a></h4><ol><li>简化数据查询语句</li><li>使用户能从多角度看待同一数据</li><li>提高数据的安全性</li><li>提供了一定程度的逻辑独立性</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="结构化分析及建模方法的主要优点"></a>结构化分析及建模方法的主要优点<a class="hash-link" href="#结构化分析及建模方法的主要优点" title="Direct link to heading">#</a></h4><ol><li>不过早陷入具体的细节</li><li>从整体或宏观入手分析问题</li><li>通过图形化的模型对象直观的表示系统要做什么,完成什么功能</li><li>图形化建模方法方便系统分析员理解和描述系统</li><li>模型对象不涉及太多技术术语,便于用户理解模型</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="uml"></a>UML<a class="hash-link" href="#uml" title="Direct link to heading">#</a></h4><p>每一种 UML 的视图都是由一个或多个图组成的, UML 提供了9种不同的图,分为两类.</p><ol><li>静态图
用例图, 类图, 对象图, 组件图, 部署图</li><li>动态图
顺序图, 交互图, 状态图, 和 活动图</li></ol><p>可以根据不同的视图应用进行分类:</p><ol><li>用例视图: 用例图</li><li>结构视图: 类图, 对象图</li><li>行为视图: 顺序图, 交互图, 状态图, 活动图</li><li>实现视图: 组件图</li><li>环境视图: 部署图</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="分布式数据库"></a>分布式数据库<a class="hash-link" href="#分布式数据库" title="Direct link to heading">#</a></h4><p>目的是: 本地自治, 非集中式管理,高可用性,位置独立性,分布式查询处理,分布式事务管理等.</p><ol><li><p>分布式数据库系统概念
是物理上分散,逻辑上统一的数据库系统.</p></li><li><p>分布式数据的概念
分布式数据库则是分布式数据库系统中个场地上数据库的逻辑合.</p></li><li><p>分布式数据库的结构</p><ul><li>共享内存结构</li><li>共享磁盘结构</li><li>无共享结构
最好的并行结构</li><li>次结构
以上体系结构的结合.</li></ul></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="分布式数据库的分布策略"></a>分布式数据库的分布策略<a class="hash-link" href="#分布式数据库的分布策略" title="Direct link to heading">#</a></h4><p>数据分片
: 对某一个关系进行分片是将关系划分为多个片段, 这些片段中包含足够的信息可以使关系重构.</p><p>数据分片有四种基本方法:</p><ol><li>水平分片
在关系中从行的角度(元组)依据一定条件划分为不同的片段,关系中的每一行必须至少属于
一个片段,以便在需要时可以重构关系</li><li>垂直分片
在关系中从列的角度(属性)依据一定的条件分为不同的片段,各片段中应该包含关系的主码
属性,一边通过连接方法恢复关系.</li><li>导出分片
是导出水平分片,分片的依据不是本关系的条件,而是其他关系属性的条件.</li><li>混合分片
以上三种方法的混合</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="范式的简述"></a>范式的简述<a class="hash-link" href="#范式的简述" title="Direct link to heading">#</a></h4><ul><li>第一范式
指关系必须满足每一个属性值都是不可分解的数据项</li><li>第二范式
在第一范式的基础上,使关系中的每一个属性必须只依赖主码(非主属性完全依赖于候选键)</li><li>第三范式
在第二范式的基础上,每一个非主属性必须只依赖于主码
(非主属性都不传递依赖于候选键)</li></ul><p>一般关系模式规范化工作仅做到 3NF 就可以把关系中不合理的属性基本消除.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="关于性能优化"></a>关于性能/优化<a class="hash-link" href="#关于性能优化" title="Direct link to heading">#</a></h3><ul><li>将表的数据和索引放置在同一磁盘上不利于提高系统查询的效率</li><li>物理设计的目标是得到存储空间占用少,数据访问效率高和维护代价低的数据库物理模式.
设计一个好的索引和索引字段,可以提高数据查询的速度和效率.</li><li>尽可能先执行查询条件,把表连接放到最后执行</li><li>可以使用 FIFS 来避免活锁的产生</li><li>使用内连接替代左右连接</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="查询优化"></a>查询优化<a class="hash-link" href="#查询优化" title="Direct link to heading">#</a></h4><ol><li>合理使用索引</li><li>避免或简化排序</li><li>消除对大型表进行数据的顺序存取</li><li>避免相关子查询</li><li>避免困难的正则表达式</li><li>使用临时表加速查询</li><li>用排序来取代非顺序磁盘存取</li><li>不充分的连接条件(避免左右连接)</li><li>使用存储过程</li><li>不要随意使用游标</li><li>使用事务处理</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="分类方法"></a>分类/方法<a class="hash-link" href="#分类方法" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="sql-server-2000-数据库备份方式"></a>SQL Server 2000 数据库备份方式<a class="hash-link" href="#sql-server-2000-数据库备份方式" title="Direct link to heading">#</a></h4><ol><li>先创建备份设备,然后将数据库备份到备份设备上(这种设备称为永久备份设备)</li><li>直接将数据库备份到物理文件上(这种设备称为临时备份设备)</li></ol><p>在执行备份过程中, 可以同时向多个备份设备写备份内容,也称为并行备份.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="死锁的预防方法"></a>死锁的预防方法<a class="hash-link" href="#死锁的预防方法" title="Direct link to heading">#</a></h4><ol><li>一次加锁
要求每个事务在开始执行时必须将需要访问的数据项全部枷锁,否则不允许执行下去,
也就是要求事务必须能一次性的获得对需要访问的全部数据项的访问权.</li><li>顺序加锁
该方法对数据库中事务访问的所有数据项规定一个加锁顺序,每个事务在执行过程中
必须按此顺序对所需数据项加锁.</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="数据库管理员执行的工作"></a>数据库管理员执行的工作<a class="hash-link" href="#数据库管理员执行的工作" title="Direct link to heading">#</a></h4><ol><li>数据库的转储和恢复</li><li>数据库的安全和完整性控制</li><li>数据库的性能监控和分析</li><li>数据库的重组和重构</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="系统故障软故障-的处理方法"></a>系统故障/软故障 的处理方法<a class="hash-link" href="#系统故障软故障-的处理方法" title="Direct link to heading">#</a></h4><p>对于未完成的事务,可能已经写入数据库的内容,回滚所有未完成的事务写入的结果,以保证
数据库中数据的一致性.
对于已完成的事务可能部分或全部留在缓冲区的结果,需要重做所有已提交的事务,以将数据
库恢复到一致状态
即,撤销(Undo)所有未提交的事务,重做(Redo)所有已提交的事务.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="数据仓库中数据的维护策略"></a>数据仓库中数据的维护策略<a class="hash-link" href="#数据仓库中数据的维护策略" title="Direct link to heading">#</a></h4><ul><li>实时维护</li><li>延时维护
查询时触发维护,减少了对数据源的更新时间,但视图查询时间较长.</li><li>快照维护
定期对数据库进行维护,维护操作的触发条件是时间.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="数据库物理设计步骤"></a>数据库物理设计步骤<a class="hash-link" href="#数据库物理设计步骤" title="Direct link to heading">#</a></h4><ol><li>数据库逻辑模式调整</li><li>文件组织与存取设计</li><li>数据分布设计</li><li>安全模式设计</li><li>确定系统配置</li><li>物理模式评估</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="dbas-总体设计"></a>DBAS 总体设计<a class="hash-link" href="#dbas-总体设计" title="Direct link to heading">#</a></h4><ol><li>确定 DBAS 体系结构</li><li>系统硬件平台和操作系统,数据库管理系统等系统软件的选型和配置</li><li>应用软件结构设计</li><li>对需求分析阶段识别出的业务规则进行初步设计,细化业务规则流程,分析所处理的业务数据
和处理方式,明确采用的关键技术和算法等.</li><li>对系统采用的关键技术进行方案选型和初步设计.</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="raid-分级"></a>RAID 分级<a class="hash-link" href="#raid-分级" title="Direct link to heading">#</a></h4><table><thead><tr><th>RAID等级</th><th>n</th><th>最小容错硬盘数</th><th>可用容量</th><th>性能</th><th>安全性</th><th>目的</th><th>应用产业</th></tr></thead><tbody><tr><td>JBOD</td><td>≧1</td><td>0</td><td>n</td><td>不变</td><td>无(同RAID 0)</td><td>追求最大容量</td><td></td></tr><tr><td>0</td><td>≧2</td><td>0</td><td>n</td><td>最高</td><td>一个硬盘异常，全部硬盘即跟着异常</td><td>追求最大容量、速度</td><td>3D产业实时渲染、视频剪接高速缓存用途</td></tr><tr><td>1</td><td>≧2</td><td>总数的一半</td><td>总容量的一半</td><td>稍有提升</td><td>最高</td><td>追求最大安全性</td><td>个人、企业备份</td></tr><tr><td>5</td><td>≧3</td><td>1</td><td>n-1</td><td>高</td><td>高</td><td>追求最大容量、最小预算</td><td>个人、企业备份</td></tr><tr><td>6</td><td>≧4</td><td>2</td><td>n-2</td><td>比RAID 5稍慢</td><td>安全性较RAID 5高</td><td>同RAID 5，但较安全</td><td>个人、企业备份</td></tr><tr><td>10</td><td>≧4</td><td>总数的一半</td><td>总容量的一半</td><td>高</td><td>安全性最高</td><td>综合RAID 0/1优点，理论速度较快</td><td>大型数据库、服务器</td></tr></tbody></table></section><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/story/tags/数据库">数据库</a><a class="margin-horiz--sm" href="/story/tags/笔记">笔记</a></div></footer></article><div><a href="https://github.com/wenerme/wener/edit/master/story/2013/2013-09-24-数据库原理 for NCRE 4.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/story/java-siwng-textbubble"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« 简单的文字气泡框 for Swing</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/story/personal-project-page"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">个人作品展示页面 »</div></a></div></nav></div></main><div class="col col--2"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-数据库系统的基本概念" class="table-of-contents__link">1. 数据库系统的基本概念</a><ul><li><a href="#12-数据描述" class="table-of-contents__link">1.2 数据描述</a></li><li><a href="#13-数据的抽象级别" class="table-of-contents__link">1.3 数据的抽象级别</a></li><li><a href="#14-数据库管理系统dbms" class="table-of-contents__link">1.4 数据库管理系统(DBMS)</a></li><li><a href="#15-数据库系统dbs" class="table-of-contents__link">1.5 数据库系统(DBS)</a></li></ul></li><li><a href="#2-数据库设计和-er-模型" class="table-of-contents__link">2. 数据库设计和 ER 模型</a><ul><li><a href="#21-数据库系统生存期" class="table-of-contents__link">2.1 数据库系统生存期</a></li></ul></li><li><a href="#3-关系模式设计理论" class="table-of-contents__link">3. 关系模式设计理论</a><ul><li><a href="#31-关系模式的设计准则" class="table-of-contents__link">3.1 关系模式的设计准则</a></li><li><a href="#32-函数依赖" class="table-of-contents__link">3.2 函数依赖</a></li><li><a href="#33-关系模式的分解特性" class="table-of-contents__link">3.3 关系模式的分解特性</a></li><li><a href="#34-范式" class="table-of-contents__link">3.4 范式</a></li><li><a href="#35-多值依赖和第四范式" class="table-of-contents__link">3.5 多值依赖和第四范式</a></li></ul></li><li><a href="#appendixa-er-模型" class="table-of-contents__link">Appendix.A ER 模型</a><ul><li><a href="#1-er-模型的基本元素" class="table-of-contents__link">1. ER 模型的基本元素</a></li><li><a href="#2-属性的分类" class="table-of-contents__link">2. 属性的分类</a></li><li><a href="#3-联系的设计" class="table-of-contents__link">3. 联系的设计</a></li><li><a href="#4-er-模型到关系模型的转换" class="table-of-contents__link">4. ER 模型到关系模型的转换</a></li><li><a href="#5增强的-er-模型" class="table-of-contents__link">5.增强的 ER 模型</a></li><li><a href="#6-er模型的基本表示" class="table-of-contents__link">6. ER模型的基本表示</a></li></ul></li><li><a href="#appendixb-关系模型" class="table-of-contents__link">Appendix.B 关系模型</a><ul><li><a href="#1-关系模型的基本术语" class="table-of-contents__link">1. 关系模型的基本术语</a></li><li><a href="#2-关系的定义和性质" class="table-of-contents__link">2. 关系的定义和性质</a></li><li><a href="#3-三类完整性规则" class="table-of-contents__link">3. 三类完整性规则</a></li></ul></li><li><a href="#appendixx-额外的笔记" class="table-of-contents__link">Appendix.X 额外的笔记</a><ul><li><a href="#名词定义" class="table-of-contents__link">名词定义</a></li><li><a href="#关于性能优化" class="table-of-contents__link">关于性能/优化</a></li><li><a href="#分类方法" class="table-of-contents__link">分类/方法</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">笔记</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/notes/java/java">Java</a></li><li class="footer__item"><a class="footer__link-item" href="/notes/os/alpine/alpine">AlpineLinux</a></li><li class="footer__item"><a class="footer__link-item" href="/notes/devops/kubernetes/kubernetes">Kubernates</a></li><li class="footer__item"><a class="footer__link-item" href="/notes/voip/voip">VoIP</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Projects</h4><ul class="footer__items"><li class="footer__item">
              <div>
              <a class="footer__link-item" href="https://github.com/wenerme/wener">Wener</a>
              - <a class="footer__link-item" href="https://github.com/wenerme/wener/actions" title="wenerme/wener - ci">
                <img style="vertical-align: middle;opacity: .4;" src="https://github.com/wenerme/wener/workflows/Build/badge.svg">
                </a>
              </div>
              </li><li class="footer__item"><a href="https://apis.wener.me" target="_blank" rel="noopener noreferrer" class="footer__link-item">Wener&#x27;s Apis</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Social</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/story">Blog</a></li><li class="footer__item"><a href="https://github.com/wenerme" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li><li class="footer__item"><a href="https://twitter.com/wenerme" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><img class="footer__logo" alt="Wener Site" src="/img/wener-logo.svg"></div><div class="footer__copyright">Copyright © 1992-2021 Wener - 构建时间 2021-05-23 17:52</div></div></div></footer></div>
<script src="/styles.57f5dddf.js"></script>
<script src="/runtime~main.7902e8e5.js"></script>
<script src="/main.f820e005.js"></script>
<script src="/1.2eb87496.js"></script>
<script src="/2.77b0d6b5.js"></script>
<script src="/3.3b0f69d3.js"></script>
<script src="/ccc49370.097418e0.js"></script>
<script src="/65eaf7fb.29a51009.js"></script>
<script src="/e6b7e9c9.9ca64f84.js"></script>
</body>
</html>